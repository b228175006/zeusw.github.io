{"meta":{"title":"秋名山车神的博客","subtitle":"车神维基","description":"我本微末凡尘，却也心向天空。","author":"车神","url":"http://www.cheshen.wiki"},"pages":[{"title":"","date":"2017-03-29T12:04:00.375Z","updated":"2017-03-29T12:04:00.375Z","comments":true,"path":"404.html","permalink":"http://www.cheshen.wiki/404.html","excerpt":"","text":""},{"title":"分类","date":"2016-10-21T16:00:33.000Z","updated":"2016-10-21T16:00:36.074Z","comments":true,"path":"categories/index.html","permalink":"http://www.cheshen.wiki/categories/index.html","excerpt":"","text":""},{"title":"日程","date":"2016-10-21T16:05:09.000Z","updated":"2016-10-21T16:09:53.695Z","comments":true,"path":"schedule/index.html","permalink":"http://www.cheshen.wiki/schedule/index.html","excerpt":"","text":""},{"title":"关于我","date":"2016-10-21T16:02:07.000Z","updated":"2016-10-25T15:06:05.802Z","comments":true,"path":"about/index.html","permalink":"http://www.cheshen.wiki/about/index.html","excerpt":"","text":"联系方式Email: meteorshield@gmail.comQQ: 790625271 基本信息男/90后/天蝎座所在城市：广东深圳学历：专科未毕业(中途离开学校)工作年限：三年 个人简介曾担任Java全栈工程师，参加过大型项目开发。精通Spring，Hibernate等框架，开发过简易版Spring框架。熟悉MySQL性能优化。目前Python作为首选语言，在Github贡献过requests，pymysql等主流Python库。对Python图像识别，数据采集，网站建设，自动化测试等方面有比较深的了解。在慕课网担任讲师。喜欢有挑战，创新，妹子多的团队。 技能清单掌握语言：Python/Java/HTML/JavaScript前端框架：Zepto/Bootstrap/AngularJS/JQuery数据库相关：MySQL/Oracle/SQLite其他技能：微信公众号开发"},{"title":"小程序","date":"2016-10-26T14:41:42.557Z","updated":"2016-10-26T14:41:42.557Z","comments":true,"path":"small/index.html","permalink":"http://www.cheshen.wiki/small/index.html","excerpt":"","text":"注意事项：本页面所有小程序，你可以用在任何途径，如果可能的话，可以加上本站的链接或扫码捐献~ 绚丽的时钟阿尔法狗下五子棋"},{"title":"tags","date":"2016-10-21T16:02:33.000Z","updated":"2016-10-21T16:02:34.919Z","comments":true,"path":"tags/index.html","permalink":"http://www.cheshen.wiki/tags/index.html","excerpt":"","text":""},{"title":"","date":"2016-10-25T15:10:45.198Z","updated":"2016-04-02T10:06:10.316Z","comments":true,"path":"small/AlphaGo/win.js","permalink":"http://www.cheshen.wiki/small/AlphaGo/win.js","excerpt":"","text":"//用来计算所有赢的情况的数据结构 myGain = [ [0,0,1,1,0], [0,1,1,0], [1,0,1,0] ]; comGain = [ [0,0,2,2,0], [0,2,2,0], [2,0,2,0] ];"},{"title":"","date":"2016-10-26T13:51:29.467Z","updated":"2016-10-26T13:51:29.467Z","comments":true,"path":"small/AlphaGo/index.html","permalink":"http://www.cheshen.wiki/small/AlphaGo/index.html","excerpt":"","text":"五子棋 您的浏览器不支持audio，请使用其他浏览器或极速模式。 您的浏览器不支持canvas，请使用其他浏览器或极速模式。"},{"title":"","date":"2016-10-25T15:10:45.194Z","updated":"2016-04-01T15:34:01.426Z","comments":true,"path":"small/AlphaGo/index.css","permalink":"http://www.cheshen.wiki/small/AlphaGo/index.css","excerpt":"","text":".chess{ display: block; margin: 50px auto; box-shadow: -2px -2px 2px #EFEFEF, 5px 5px 5px #B9B9B9; }"},{"title":"","date":"2016-10-26T12:48:11.694Z","updated":"2016-10-26T12:48:11.694Z","comments":true,"path":"small/AlphaGo/chess.js","permalink":"http://www.cheshen.wiki/small/AlphaGo/chess.js","excerpt":"","text":"/** * Created by Administrator on 2016/3/31. */ var chess; //canvas对象 var downChess; //audio对象 var CHESS_WIDTH; //棋盘的高度 var CHESS_HEIGTH; //棋盘的宽度 var over = false; //表示是否有人赢了 var chessPen; var LINE; //一共有棋盘有多少行多少列 var LINTTOPADDIN; //棋盘的线距离棋盘左右上下的距离 var LINE_SIZEPX; //棋盘每条线的间隔 var isBlack = true; //用来存储下一个棋子的颜色，true为黑棋，默认为黑棋先下 var chessMap = []; //存储棋盘的棋子，0代表当前位置没有棋子，1代表黑棋，2代表白棋 var wins = []; //赢法数组 [x][y][k] x y 代表棋盘上的一个点 k代表第几种赢法 var myWin = []; //我方的赢法统计数组 var comWin = []; //计算机方的赢法统计数组 var count = 0; //代表有多少种赢法 /** wins start **/ //初始化数组 for (var x = 0; x < 15; x++) { wins[x] = []; for (var y = 0; y < 15; y++) { wins[x][y] = []; } } //横排的赢法 for (var x = 0; x < 15; x++) { for (var y = 0; y < 11; y++) { for (var k = 0; k < 5; k++) { wins[x][y + k][count] = true; } count++; } } //竖排的赢法 for (var x = 0; x < 15; x++) { for (var y = 0; y < 11; y++) { for (var k = 0; k < 5; k++) { wins[y + k][x][count] = true; } count++; } } //正斜线的赢法 for (var x = 0; x < 11; x++) { for (var y = 0; y < 11; y++) { for (var k = 0; k < 5; k++) { wins[x + k][y + k][count] = true; } count++; } } //反斜线的赢法 for (var x = 0; x < 11; x++) { for (var y = 14; y > 3; y--) { for (var k = 0; k < 5; k++) { wins[x + k][y - k][count] = true; } count++; } } /** wins end **/ /** 赢法统计数组初始化开始 **/ for (var i = 0; i < count; i++) { myWin[i] = 0; comWin[i] = 0; } /** 赢法统计数组初始化结束 **/ console.log(\"五子棋一共有 \" + count + \"种赢法\"); //打印日志 window.onload = function() { infoStart(); } var infoStart = function() { chess = document.getElementById(\"chess\"); downChess = document.getElementById(\"downChess\"); chessPen = chess.getContext(\"2d\"); chessPen.strokeStyle = \"#B9B9B9\"; CHESS_WIDTH = chess.width; //棋盘的高度 CHESS_HEIGTH = chess.height; //棋盘的宽度 LINE = 15; //一共有棋盘有多少行多少列 LINTTOPADDIN = 15; //棋盘的线距离棋盘左右上下的距离 LINE_SIZEPX = 30; //棋盘每条线的间隔 drawCheckerBoard(); //初始化棋盘 reloadBoard(); //初始化棋子 //棋盘单击事件 chess.onclick = function(e) { //如果已经有人获胜，就不处理 if (over) { return; } //只有黑棋才能手动下棋 if (!isBlack) { return; } var x = Math.floor(e.offsetX / LINE_SIZEPX); var y = Math.floor(e.offsetY / LINE_SIZEPX); if (chessMap[x][y] == 0) { drawOneChess(x, y, isBlack); chessMap[x][y] = 1; //黑棋 } else { return; } //遍历所有的赢法 for (var k = 0; k < count; k++) { //如果为true说明我们在K种赢法上面胜算大了一步 if (wins[x][y][k]) { myWin[k]++; //我方胜算统计增加 comWin[k] = 6; //计算机在这种赢法就不可能赢，设置一个异常的值6 //说明黑棋已经赢了 if (myWin[k] == \"5\") { window.alert(\"恭喜你获胜！\"); over = true; } } } //如果还没有结束，我们让计算机下棋 if (!over) { isBlack = !isBlack; //下一个棋 computerAI(); } }; } //初始化棋子 var reloadBoard = function() { for (var i = 0; i < LINE; i++) { chessMap[i] = []; for (var j = 0; j < LINE; j++) { chessMap[i][j] = 0; } } } //计算机AI下棋 var computerAI = function() { var myScore = []; //用户棋盘上点的得分 var comScore = []; //电脑棋盘上点的得分 var max = 0; //保存最高的分数 var maxX = 0, maxY = 0; //最高分的点的坐标 var myK = 0; //用户下了某一个点之后，将会产生多少个符合赢得条件 var comK = 0; //计算机下了某一个点之后，将会产生多少个符合赢得条件 var ruleCount = 0; for (var x = 0; x < 15; x++) { myScore[x] = []; comScore[x] = []; for (var y = 0; y < 15; y++) { myScore[x][y] = 0; comScore[x][y] = 0; } } for (var x = 0; x < 15; x++) { for (var y = 0; y < 15; y++) { //如果棋盘上这个点没有子 if (chessMap[x][y] == 0) { //检查是否有符合规则的棋子 if (upAspect(x, y, 0, -1, 1)) { ruleCount++; } if (downAspect(x, y, 0, -1, 1)) { ruleCount++; } if (leftAspect(x, y, 0, -1, 1)) { ruleCount++; } if (rightAspect(x, y, 0, -1, 1)) { ruleCount++; } if (upLeftAspect(x, y, 0, -1, 1)) { ruleCount++; } if (rightDownAspect(x, y, 0, -1, 1)) { ruleCount++; } if (rightUpAspect(x, y, 0, -1, 1)) { ruleCount++; } if (leftDownAspect(x, y, 0, -1, 1)) { ruleCount++; } //规则至少要有两个成立才可以 if (ruleCount >= 2) { myScore[x][y] += 4000; ruleCount = 0; } else { ruleCount = 0; } //电脑落子 //检查是否有符合规则的棋子 if (upAspect(x, y, 0, -1, 2)) { ruleCount++; } if (downAspect(x, y, 0, -1, 2)) { ruleCount++; } if (leftAspect(x, y, 0, -1, 2)) { ruleCount++; } if (rightAspect(x, y, 0, -1, 2)) { ruleCount++; } if (upLeftAspect(x, y, 0, -1, 2)) { ruleCount++; } if (rightDownAspect(x, y, 0, -1, 2)) { ruleCount++; } if (rightUpAspect(x, y, 0, -1, 2)) { ruleCount++; } if (leftDownAspect(x, y, 0, -1, 2)) { ruleCount++; } //规则至少要有两个成立才可以 if (ruleCount >= 2) { comScore[x][y] += 8000; ruleCount = 0; } else { ruleCount = 0; } for (var k = 0; k < count; k++) { if (wins[x][y][k]) { //判断黑棋的子，然后判断如何拦截 if (myWin[k] == 1) { myScore[x][y] += 200; } else if (myWin[k] == 2) { myScore[x][y] += 400; } else if (myWin[k] == 3) { myScore[x][y] += 2000; } else if (myWin[k] == 4) { myScore[x][y] += 10000; } //判断计算机棋盘子每一步的分数 if (comWin[k] == 1) { comScore[x][y] += 220; } else if (comWin[k] == 2) { comScore[x][y] += 420 } else if (comWin[k] == 3) { comScore[x][y] += 2100 } else if (comWin[k] == 4) { comScore[x][y] += 20000 } } } //判断拦截用户位置的分数最高 if (myScore[x][y] > max) { max = myScore[x][y]; maxX = x; maxY = y; } else if (myScore[x][y] == max) { if (comScore[x][y] > comScore[maxX][maxY]) { maxX = x; maxY = y; } } //判断自己下哪里分数最高 if (comScore[x][y] > max) { max = comScore[x][y]; maxX = x; maxY = y; } else if (comScore[x][y] == max) { if (myScore[x][y] > myScore[maxX][maxY]) { maxX = x; maxY = y; } } } } } //计算机落子 drawOneChess(maxX, maxY, false); //把棋盘上的一个点设置为计算机落了子 chessMap[maxX][maxY] = 2; //遍历所有的赢法 for (var k = 0; k < count; k++) { //如果为true说明我们在K种赢法上面胜算大了一步 if (wins[maxX][maxY][k]) { comWin[k]++; //我方胜算统计增加 myWin[k] = 6; //计算机在这种赢法就不可能赢，设置一个异常的值6 //说明黑棋已经赢了 if (comWin[k] == \"5\") { window.alert(\"很遗憾，你输了！\"); over = true; } } } //如果还没有结束，我们让计算机下棋 if (!over) { isBlack = !isBlack; //下一个棋 } } /** 检测棋盘上一个点的上方有多少个黑子 x = 棋子的纵坐标 0 - 14 y = 棋子的横坐标 0 - 14 isNull = 0 为没有棋子 isNull = 1 为有黑棋 isNull = 2 为有白棋 isNull 初始化为 -1 代表到达边界 chessType = 1 代表黑棋 chessType = 2 代表白棋 **/ var upAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (y == -1) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; y--; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (y == -1) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; y--; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的下方有多少个黑子 var downAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (y == 15) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; y++; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (y == 15) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; y++; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的左方有多少个黑子 //y轴不变，x-- var leftAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == -1) { //x的本身就在左方的边界，左方不存在任何东西，直接返回 return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x--; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == -1) { //x的本身就在左方的边界，左方不存在任何东西，直接返回 return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x--; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的右方有多少个黑子 //y轴不变，x++ var rightAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == 15) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x++; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == 15) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x++; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的左上方有多少个黑子 // x-- y-- var upLeftAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == -1 || y == -1) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x--; y--; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == -1 || y == -1) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x--; y--; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的右上方有多少个黑子 //x++ y-- var rightUpAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == 15 || y == -1) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x++; y--; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == 15 || y == -1) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x++; y--; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的左下方有多少个黑子 //x-- y++ var leftDownAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == -1 || y == 15) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x--; y++; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == -1 || y == 15) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x--; y++; } } if (winCount == comGain[i].length) { return true; } } return false; } } //检测棋盘上一个点的右下方有多少个黑子 //x++ y++ var rightDownAspect = function(x, y, flag, isNull, chessType) { var thisX = x; var thisY = y; //黑棋用户 if (chessType == 1) { for (var i = 0; i < myGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < myGain[i].length; j++) { if (x == 15 || y == 15) { return false; } if (chessMap[x][y] == myGain[i][j]) { winCount++; x++; y++; } } if (winCount == myGain[i].length) { return true; } } return false; } else { for (var i = 0; i < comGain.length; i++) { x = thisX; y = thisY; var winCount = 0; for (var j = 0; j < comGain[i].length; j++) { if (x == 15 || y == 15) { return false; } if (chessMap[x][y] == comGain[i][j]) { winCount++; x++; y++; } } if (winCount == comGain[i].length) { return true; } } return false; } } //绘制棋盘 var drawCheckerBoard = function() { for (var i = 0; i < LINE; i++) { chessPen.beginPath(); chessPen.moveTo(LINTTOPADDIN + i * LINE_SIZEPX, 0 + LINE); chessPen.lineTo(LINTTOPADDIN + i * LINE_SIZEPX, CHESS_HEIGTH - LINE); chessPen.stroke(); chessPen.beginPath(); chessPen.moveTo(0 + LINTTOPADDIN, LINTTOPADDIN + i * LINE_SIZEPX); chessPen.lineTo(CHESS_WIDTH - LINTTOPADDIN, LINTTOPADDIN + i * LINE_SIZEPX); chessPen.stroke(); } }; //绘制棋子 var drawOneChess = function(x, y, isBlack) { downChess.load(); //每次单击重新载入音频 downChess.play(); //单击播放音频 chessPen.beginPath(); chessPen.arc(LINTTOPADDIN + x * LINE_SIZEPX, LINTTOPADDIN + y * LINE_SIZEPX, 13, 0, 2 * Math.PI); chessPen.closePath(); var gradient = chessPen.createRadialGradient(LINTTOPADDIN + x * LINE_SIZEPX + 2, LINTTOPADDIN + y * LINE_SIZEPX - 2, 13, LINTTOPADDIN + x * LINE_SIZEPX + 2, LINTTOPADDIN + y * LINE_SIZEPX - 2, 0); if (isBlack) { gradient.addColorStop(0, \"#0A0A0A\"); gradient.addColorStop(1, \"#636766\"); } else { gradient.addColorStop(0, \"#D1D1D1\"); gradient.addColorStop(1, \"#F9F9F9\"); } chessPen.fillStyle = gradient; chessPen.fill(); };"},{"title":"","date":"2016-10-26T14:00:34.149Z","updated":"2016-10-26T14:00:34.149Z","comments":true,"path":"small/time/index.html","permalink":"http://www.cheshen.wiki/small/time/index.html","excerpt":"","text":"绚丽的时钟 当前浏览器不支持Canvas，请更换浏览器后再试"},{"title":"","date":"2016-10-25T14:38:27.746Z","updated":"2014-07-14T06:16:52.711Z","comments":true,"path":"small/time/js/digit.js","permalink":"http://www.cheshen.wiki/small/time/js/digit.js","excerpt":"","text":"digit = [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,1,1,0,0], [0,1,1,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [1,1,1,1,1,1,1] ],//1 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,0,0,1,1], [1,1,1,1,1,1,1] ],//2 [ [1,1,1,1,1,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//3 [ [0,0,0,0,1,1,0], [0,0,0,1,1,1,0], [0,0,1,1,1,1,0], [0,1,1,0,1,1,0], [1,1,0,0,1,1,0], [1,1,1,1,1,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,1,1] ],//4 [ [1,1,1,1,1,1,1], [1,1,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,1,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//5 [ [0,0,0,0,1,1,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//6 [ [1,1,1,1,1,1,1], [1,1,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0] ],//7 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//8 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,1,1,0,0,0,0] ],//9 [ [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0] ]//: ];"},{"title":"","date":"2016-10-25T15:00:44.533Z","updated":"2016-10-25T15:00:44.533Z","comments":true,"path":"small/time/js/countdown.js","permalink":"http://www.cheshen.wiki/small/time/js/countdown.js","excerpt":"","text":"var WINDOW_WIDTH = 1024; //宽 var WINDOW_HEIGHT = 768; //高 var RADIUS = 8; //绘制每个数字小圆球的半径 var MARGIN_TOP = 60; //每一个数字距离画布上边距的距离 var MARGIN_LEFT = 30; //第一个数字距离画布的左边距的距离 const FRICTION = 0.65; //彩色小球弹跳起来时功的消耗 //在js中月份0代表1月 const endTime = new Date(2016, 2, 10, 18, 47, 52); //倒计时的时间 var curShowTimeSeconds = 0; //现在倒计时需要多少秒 var balls = []; //用来记录小球的数组 //用于生成滚动小球的颜色，随机抽取 const colors = [\"#33B5E5\", \"#0099CC\", \"#AA66CC\", \"#9933CC\", \"#99CC00\", \"#669900\", \"#FFBB33\", \"#FF8800\", \"#FF4444\", \"#CC0000\"]; //页面加载执行 window.onload = function () { //自适应处理 /** * 但是这样做得不到整个屏幕的宽度和高度，需要给body * 和canvas加一个style height=100% * @type {number} */ // WINDOW_WIDTH = document.body.clientWidth; // WINDOW_HEIGHT = document.body.clientHeight; /* 为了匹配博客的样式 -- start */ WINDOW_HEIGHT = document.body.clientHeight / 2; WINDOW_WIDTH = $(\".content-wrap\").width() /* 为了匹配博客的样式 -- end */ MARGIN_LEFT = Math.round(WINDOW_WIDTH / 10);//宽度是整个屏幕的十分之一 RADIUS = Math.round(WINDOW_WIDTH * 4 / 5 / 108)-1; MARGIN_TOP = Math.round(WINDOW_HEIGHT /5);//高度是整个屏幕的五分之一 var canvas = document.getElementById('canvas'); var context = canvas.getContext('2d'); canvas.width = WINDOW_WIDTH; canvas.height = WINDOW_HEIGHT; curShowTimeSeconds = getCurShowTimeSeconds(); /** * 动画的基本模型 */ setInterval(function () { //绘制当前的动画 render(context); //对当前数据进行调整 update(); }, 50); }; //当前时间和倒计时时间的秒数 function getCurShowTimeSeconds() { //倒计时效果 //var curTime = new Date(); //var ret = endTime.getTime() - curTime.getTime(); //ret = Math.round(ret / 1000); //return ret >= 0 ? ret : 0; //时钟效果 var curTime = new Date(); var ret = curTime.getHours() * 3600 + curTime.getMinutes() * 60 + curTime.getSeconds(); return ret; } //绘制方法 function render(ctx) { //对一个举行空间内的图形进行一次刷新操作 ctx.clearRect(0, 0, WINDOW_WIDTH, WINDOW_HEIGHT); var hours = parseInt(curShowTimeSeconds / 3600); var minutes = parseInt((curShowTimeSeconds - hours * 3600) / 60); var seconds = curShowTimeSeconds % 60; //绘制小时的第一个数字 renderDigit(MARGIN_LEFT, MARGIN_TOP, parseInt(hours / 10), ctx); /** * 绘制小时的第二个数字 * 因为半径是8，实际上的距离是7 * 2 所以是 14 * （半径 + 1）的距离 * 为了留有一定的空隙，所以改成 15 * （半径 + 1） */ renderDigit(MARGIN_LEFT + 15 * (RADIUS + 1), MARGIN_TOP, parseInt(hours % 10), ctx); /** * 绘制冒号 * 一个数字是15 那么第二个数字是30 */ renderDigit(MARGIN_LEFT + 30 * (RADIUS + 1), MARGIN_TOP, 10, ctx); //绘制分钟，因为冒号占用的是4，4*2+1是9 renderDigit(MARGIN_LEFT + 39 * (RADIUS + 1), MARGIN_TOP, parseInt(minutes / 10), ctx); renderDigit(MARGIN_LEFT + 54 * (RADIUS + 1), MARGIN_TOP, parseInt(minutes % 10), ctx); //又一个冒号 renderDigit(MARGIN_LEFT + 69 * (RADIUS + 1), MARGIN_TOP, 10, ctx); //绘制秒数 renderDigit(MARGIN_LEFT + 78 * (RADIUS + 1), MARGIN_TOP, parseInt(seconds / 10), ctx); renderDigit(MARGIN_LEFT + 93 * (RADIUS + 1), MARGIN_TOP, parseInt(seconds % 10), ctx); //绘制彩色小球 for (var i = 0; i < balls.length; i++) { ctx.fillStyle = balls[i].color; ctx.beginPath(); ctx.arc(balls[i].x, balls[i].y, RADIUS, 0, 2 * Math.PI, true); ctx.closePath(); ctx.fill(); } } //绘制一个具体的数字 function renderDigit(x, y, num, ctx) { ctx.fillStyle = \"rgb(0,102,153)\"; for (var i = 0; i < digit[num].length; i++) { for (var j = 0; j < digit[num][i].length; j++) { if (digit[num][i][j] == 1) { ctx.beginPath(); ctx.arc( x + j * 2 * (RADIUS + 1) + (RADIUS + 1), y + i * 2 * (RADIUS + 1) + (RADIUS + 1), RADIUS, 0, 2 * Math.PI ); ctx.closePath(); ctx.fill(); } } } } //对当前数据进行调整 function update() { //得到下一次时间 var nextShowTimeSeconds = getCurShowTimeSeconds(); var nextHours = parseInt(nextShowTimeSeconds / 3600); var nextMinutes = parseInt((nextShowTimeSeconds - nextHours * 3600) / 60); var nextSeconds = nextShowTimeSeconds % 60; //得到当前时间 var curHours = parseInt(curShowTimeSeconds / 3600); var curMinutes = parseInt((curShowTimeSeconds - curHours * 3600) / 60); var curSeconds = curShowTimeSeconds % 60; //比较两个时间是不是已经变化的，实际上只用看秒数就可以了 if (curSeconds != nextSeconds) { //判断当前小时的十位数是不是不等于下一次小时的十位数 if (parseInt(curHours / 10) != parseInt(nextHours / 10)) { //成立则记录这个小球 addBalls(MARGIN_LEFT + 0, MARGIN_TOP, parseInt(curHours / 10)); } if (parseInt(curHours % 10) != parseInt(nextHours % 10)) { addBalls(MARGIN_LEFT + 15 * (RADIUS + 1), MARGIN_TOP, parseInt(curHours / 10)); } if (parseInt(curMinutes / 10) != parseInt(nextMinutes / 10)) { addBalls(MARGIN_LEFT + 39 * (RADIUS + 1), MARGIN_TOP, parseInt(curMinutes / 10)); } if (parseInt(curMinutes % 10) != parseInt(nextMinutes % 10)) { addBalls(MARGIN_LEFT + 54 * (RADIUS + 1), MARGIN_TOP, parseInt(curMinutes % 10)); } if (parseInt(curSeconds / 10) != parseInt(nextSeconds / 10)) { addBalls(MARGIN_LEFT + 78 * (RADIUS + 1), MARGIN_TOP, parseInt(curSeconds / 10)); } if (parseInt(curSeconds % 10) != parseInt(nextSeconds % 10)) { addBalls(MARGIN_LEFT + 93 * (RADIUS + 1), MARGIN_TOP, parseInt(nextSeconds % 10)); } //如果成立，就让当前时间等于下一次的时间 curShowTimeSeconds = nextShowTimeSeconds; } //更新所有的小球位置 updateBalls(); // console.log( balls.length); } //对所有的小球位置进行更新 function updateBalls() { //循环得到每一个小球 for (var i = 0; i < balls.length; i++) { balls[i].x += balls[i].vx; //小球的x轴加上x轴的速度值 balls[i].y += balls[i].vy; //小球的y轴加上y轴的速度值 balls[i].vy += balls[i].g; //小球在y轴的速度受到重力的影响 //对地板底部碰撞进行判断 if (balls[i].y >= WINDOW_HEIGHT - RADIUS) { balls[i].y = WINDOW_HEIGHT - RADIUS; //碰撞地板后小球的y轴位置就等于底部接触地板的坐标 balls[i].vy = -balls[i].vy * FRICTION; //小球每次弹起功耗的消耗情况 } } var cnt = 0; //记录还有个小球还在整个画布内 //清除已经不在屏幕上的小球，避免运行时间过长内存溢出 for (var i = 0; i < balls.length; i++) { //小球在X轴的位置，大于0，并且大于canvas画布的宽度，满足条件则说明在屏幕内 if(balls[i].x - RADIUS > 0 && balls[i].x-RADIUS < WINDOW_WIDTH){ //从0-cnt个小球，都是在屏幕内的小球 balls[cnt++] = balls[i]; } } //删除cnt后面的小球 //如果cnt大于300，也清空 while(balls.length > Math.min(500,cnt)){ balls.pop(); } } //添加一个彩色的小球 function addBalls(x, y, num) { for (var i = 0; i < digit[num].length; i++) { for (var j = 0; j < digit[num][i].length; j++) { if (digit[num][i][j] == 1) { var aBall = { x: x + j * 2 * (RADIUS + 1) + (RADIUS + 1), //x坐标 y: y + i * 2 * (RADIUS + 1) + (RADIUS + 1), //y坐标 g: 1.5 + Math.random(), //重力加速度，随机产生1.5 - 2.5的速度让小球有所不同 //小球在X轴的速度，0 - 1 随机数 乘 1000 用 ceil 取整 //如果取整结果为偶数为+1，如果为负数则为-1，最后乘4，速度为+4或-4. vx: Math.pow(-1, Math.ceil(Math.random() * 1000)) * 4, vy: -5, //小球在y轴有一个上抛的动作 //随机小球的颜色，用0-1随机数，乘以 coolors 的length //用下取整函数floor求出0-10 不包含10的随机数 color: colors[Math.floor(Math.random() * colors.length)] } balls.push(aBall); } } } }"}],"posts":[{"title":"jQuery源码探索之旅","slug":"jQuery源码探索之旅","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.278Z","comments":true,"path":"2017/04/15/jQuery源码探索之旅/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/jQuery源码探索之旅/","excerpt":"本路线共：8门课程 学习人数：13150人在学 章节预览：JavaScript入门篇JavaScript进阶篇jQuery基础(一)—样式篇jQuery基础(二)—DOM篇jQuery基础(三)—事件篇jQuery基础(四)—动画篇jQuery源码解析（架构与依赖模块）jQuery源码解析（DOM与核心模块）","text":"本路线共：8门课程 学习人数：13150人在学 章节预览：JavaScript入门篇JavaScript进阶篇jQuery基础(一)—样式篇jQuery基础(二)—DOM篇jQuery基础(三)—事件篇jQuery基础(四)—动画篇jQuery源码解析（架构与依赖模块）jQuery源码解析（DOM与核心模块） 奠定JavaScript基础JavaScript入门篇 本视频教程让您快速认识JavaScript，熟悉JavaScript基本语法、窗口交互方法和通过DOM进行网页元素的操作，学会如何编写JS代码，如何运用JavaScript去操作HTML元素和CSS样式，本JavaScript教程分为四个章节，能够让您快速入门，为JavaScript深入学习打下基础。初级·444787人在学 JavaScript进阶篇 做为WEB攻城师必备技术JavaScript，本课程从如何插入JS代码开始，学习JS基础语法、语法、函数、方法等，让你掌握JS编程思路、知识的使用等，实现运用JS语言为网页增加动态效果，达到与用户交互的目的。中级·283624人在学 必学jQuery框架jQuery基础(一)—样式篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第一个部分—样式篇，本课程主要介绍jQuery的基础语法，选择器以及jQuery的一些属性和样式，通过本课程的学习，我们可以用最少的代码做更多的事，让我们一起出发学习吧！初级·108678人在学 jQuery基础(二)—DOM篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第二个部分—DOM篇。本课程主要讲解jQuery中节点的创建、插入、删除与替换，除此之外我们还可以了解到jQuery中丰富的遍历节点的方法。初级·65840人在学 jQuery基础(三)—事件篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第三个部分—事件篇。此部分当中包含了，鼠标事件，表单事件，键盘事件，事件的绑定和解绑以及自定义事件。通过本课程的事件，我们能更快速的对页面进行交互的操作。初级·48560人在学 jQuery基础(四)—动画篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为最后一个部分—动画篇。通过本课程的学习，我们可以制作出以下效果：隐藏和显示、上卷下来、淡入淡出。我们也可以通过自定义动画去完成一些我们想要的效果。初级·49275人在学 深入剖析JQuery源码jQuery源码解析（架构与依赖模块） 本课程是目前真正意义上的第一部完整的jQuery2.1.1版本源码课程，课程共14章，分两个部分，本课程是第一部分课程。先从整体入手理解架构，再逐个攻破每个依赖模块包括回调函数、异步加载、数据缓存、动画队列等。最后整合分析选择器、DOM处理、事件、AJAX、动画模块。高级·61671人在学 jQuery源码解析（DOM与核心模块） 本课程是目前真正意义上第一部完整的jQuery2.1.1版本源码课程，课程共14章，分两个部分，本课程是第一部分课程。本课程主要讲解DOM处理与核心模块部分，可以让我们由浅入深的剖析jQuery库的设计与实现。高级·55428人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"高手锻造","slug":"高手锻造","permalink":"http://www.cheshen.wiki/tags/高手锻造/"},{"name":"jQuery高手","slug":"jQuery高手","permalink":"http://www.cheshen.wiki/tags/jQuery高手/"},{"name":"框架初探","slug":"框架初探","permalink":"http://www.cheshen.wiki/tags/框架初探/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Android必备技能之基础组件","slug":"Android必备技能之基础组件","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-15T06:00:57.611Z","comments":true,"path":"2017/04/15/Android必备技能之基础组件/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Android必备技能之基础组件/","excerpt":"本路线共：9门课程 学习人数：3164人在学 章节预览：与AndroidStudio的第一次亲密接触AndroidStudio技巧全集超快的Android模拟器GenymotionAndroid-重识ActivityAndroid-深入ActivityAndroid-精通ActivityAndroid-Service系列之Notification综合应用Android-Service系列之断点续传下载Android-Service系列之多线程断点续传下载","text":"本路线共：9门课程 学习人数：3164人在学 章节预览：与AndroidStudio的第一次亲密接触AndroidStudio技巧全集超快的Android模拟器GenymotionAndroid-重识ActivityAndroid-深入ActivityAndroid-精通ActivityAndroid-Service系列之Notification综合应用Android-Service系列之断点续传下载Android-Service系列之多线程断点续传下载 开发环境搭配模拟器与AndroidStudio的第一次亲密接触 AndroidStudio是Google在I/O大会上发布的一个新的集成开发环境，可以让Android开发变的更简单。本课程会详细的向您介绍AndroidStudio的安装配置、使用技巧以及相对于Eclipse开发的优势，并通过实际的操作让大家快速熟悉AndroidStudio的使用，让您体验更强大的开发工具初级·82319人在学 AndroidStudio技巧全集 AndroidStudio是一个Android开发环境，基于IntelliJIDEA.类似EclipseADT，AndroidStudio提供了集成的Android开发工具用于开发和调试。随着AndroidStudio的普及，掌握使用技巧刻不容缓！中级·43195人在学 超快的Android模拟器Genymotion 本课程将介绍Android平台下的一款最快的、最流行的Android模拟器，以及如何安装Genymotion模拟器，并对eclipse和Intellij等开发工具进行配置初级·45876人在学 前台界面Activity五彩缤纷Android-重识Activity Activity作为Android开发实在是太常见了,但是你真的会用Activity吗？本课程为Activity的系列课程的第一讲，将带大家学习Android中最常用的Activity组件的那些事初级·37470人在学 Android-深入Activity Activity作为Android开发实在是太常见了,但是你真的会用Activity吗？本课程是Activity系列的第2部分，将继续为大家讲解Activity的相关知识中级·26836人在学 Android-精通Activity 带领大家学习Android体系中最常见的Acvitiy组件，深入Activity内部，剖析Activity的生命周期分析以及Framew层的相关介绍高级·37538人在学 后台服务Service兢兢业业Android-Service系列之Notification综合应用 Notification是Android中常用的消息提醒机制，被应用在各式各样的APP上，主要用作消息推送的提醒。本课程将结合Service和Handler来为大家实现Notification的经典应用场景中级·13620人在学 Android-Service系列之断点续传下载 本门课程将带大家从无到有搭建多线程断线续传的实用案例中级·17331人在学 Android-Service系列之多线程断点续传下载 在日常下载文件的过程，由于网速问题或者突然断电等等使我们正在下载的东西处于暂停状态，当我们在点击它时还能在之前下载的基础上进行下载，这就是今天我们要学习的多线程续传下载程序的开发中级·18543人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.cheshen.wiki/tags/Android/"},{"name":"组件","slug":"组件","permalink":"http://www.cheshen.wiki/tags/组件/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Android加薪利器——断点续传","slug":"Android加薪利器——断点续传","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.247Z","comments":true,"path":"2017/04/15/Android加薪利器——断点续传/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Android加薪利器——断点续传/","excerpt":"本路线共：11门课程 学习人数：6581人在学 章节预览：Android-重识ActivityAndroid-深入ActivityAndroid-精通ActivityAndroid必学-BaseAdapter的使用与优化Android-打造万能适配器Android中的Http通信Android必学-AsyncTask基础Android面试常客Handler详解Android攻城狮的第二门课（第3季）Android-Service系列之断点续传下载Android-Service系列之多线程断点续传下载","text":"本路线共：11门课程 学习人数：6581人在学 章节预览：Android-重识ActivityAndroid-深入ActivityAndroid-精通ActivityAndroid必学-BaseAdapter的使用与优化Android-打造万能适配器Android中的Http通信Android必学-AsyncTask基础Android面试常客Handler详解Android攻城狮的第二门课（第3季）Android-Service系列之断点续传下载Android-Service系列之多线程断点续传下载 踏上远征之基石Android-重识Activity Activity作为Android开发实在是太常见了,但是你真的会用Activity吗？本课程为Activity的系列课程的第一讲，将带大家学习Android中最常用的Activity组件的那些事初级·37470人在学 Android-深入Activity Activity作为Android开发实在是太常见了,但是你真的会用Activity吗？本课程是Activity系列的第2部分，将继续为大家讲解Activity的相关知识中级·26836人在学 Android-精通Activity 带领大家学习Android体系中最常见的Acvitiy组件，深入Activity内部，剖析Activity的生命周期分析以及Framew层的相关介绍高级·37538人在学 第一关：装备Android必学-BaseAdapter的使用与优化 本次课程将带领大家了解Android中BaseAdapter的使用，以及我们如何写出高效、文艺的BaseAdapter。初级·37633人在学 Android-打造万能适配器 本课程通过对传统的ListView的数据绑定的写法，进行一步一步的抽取与封装，首先设计出一个万能的ViewHolder，再抽取一个CommonAdapter复用多数重复的代码，最后为ViewHolder添加操作控件的能力。最终成功的将原本一堆代码浓缩至几行。中级·30842人在学 第二关：技能Android中的Http通信 本次课程将带领大家android当中网络交互处理，例如常见的post、get请求以及相关知识的应用。初级·54119人在学 Android必学-AsyncTask基础 本次课程将带领大家了解Android中AsyncTask，体会如何在Android中进行异步操作进行各种网络请求，熟练掌握异步线程的使用。初级·35637人在学 Android面试常客Handler详解 本课程将深入理解Android的Handler机制，并结合源码实例，讲解Looper、MessageqQueue、Handler之间的关系，同时介绍HandlerThread的原理和使用，并分析Handler在开发中遇到的异常的原因，最后从源码的角度分析一下Handler更新UI的流程高级·44265人在学 第三关：坐骑Android攻城狮的第二门课（第3季） 本课程深入的讲解了Android中的手势识别原理、数据存储方式、对组件的详细剖析以及对Service的深度讲解，每一个知识点都对应有实际案例。本课程内容不仅使您牢牢掌握之前的基础知识点，学完之后也会有新的收获、新的体会。初级·62568人在学 放大招，秒BOSSAndroid-Service系列之断点续传下载 本门课程将带大家从无到有搭建多线程断线续传的实用案例中级·17331人在学 Android-Service系列之多线程断点续传下载 在日常下载文件的过程，由于网速问题或者突然断电等等使我们正在下载的东西处于暂停状态，当我们在点击它时还能在之前下载的基础上进行下载，这就是今天我们要学习的多线程续传下载程序的开发中级·18543人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"升职加薪","slug":"升职加薪","permalink":"http://www.cheshen.wiki/tags/升职加薪/"},{"name":"热门技术","slug":"热门技术","permalink":"http://www.cheshen.wiki/tags/热门技术/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Android工程师","slug":"Android工程师","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.253Z","comments":true,"path":"2017/04/15/Android工程师/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Android工程师/","excerpt":"本路线共：18门课程 学习人数：82648人在学 章节预览：Java入门第一季Java入门第二季Android攻城狮的第一门课（入门篇）Android攻城狮的第二门课（第1季）Android必学-BaseAdapter的使用与优化Android必学-AsyncTask基础Android必学-异步加载Android攻城狮的第二门课（第3季）Android面试常客Handler详解Android中的Http通信Android攻城狮的第二门课（第2季）浅谈Android动画Android属性动画赏析千变万化的ViewPager切换动画高仿微信5.2.1主界面及消息提醒多种多样的App主界面Tab实现方法与AndroidStudio的第一次亲密接触超快的Android模拟器Genymotion","text":"本路线共：18门课程 学习人数：82648人在学 章节预览：Java入门第一季Java入门第二季Android攻城狮的第一门课（入门篇）Android攻城狮的第二门课（第1季）Android必学-BaseAdapter的使用与优化Android必学-AsyncTask基础Android必学-异步加载Android攻城狮的第二门课（第3季）Android面试常客Handler详解Android中的Http通信Android攻城狮的第二门课（第2季）浅谈Android动画Android属性动画赏析千变万化的ViewPager切换动画高仿微信5.2.1主界面及消息提醒多种多样的App主界面Tab实现方法与AndroidStudio的第一次亲密接触超快的Android模拟器Genymotion Java基础Java入门第一季 欢迎来到精彩的Java编程世界！Java语言已经成为当前软件开发行业中主流的开发语言。本课程将介绍Java环境搭建、工具使用、基础语法。带领大家一步一步的踏入Java达人殿堂！Let’sgo!初级·601606人在学 Java入门第二季 本课程是程序猿质变课程，理解面向对象的思想，掌握面向对象的基本原则以及Java面向对象编程基本实现原理，熟练使用封装、继承、多态面向对象三大特性，带你进一步探索Java世界的奥秘！初级·288694人在学 打开Android大门Android攻城狮的第一门课（入门篇） 本课程涵盖全部Android应用开发的基础，根据技能点的作用分为5个篇章，包括环境篇、控件篇、布局篇、组件篇和通用篇，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。初级·241158人在学 Android中的网络Android攻城狮的第二门课（第1季） 本课程由浅入深地带您学会Android的常用控件的开发和使用，以知识概念为主导，实例代码为驱动，带您走入一个神奇的移动开发世界。初级·92119人在学 Android必学-BaseAdapter的使用与优化 本次课程将带领大家了解Android中BaseAdapter的使用，以及我们如何写出高效、文艺的BaseAdapter。初级·37633人在学 Android必学-AsyncTask基础 本次课程将带领大家了解Android中AsyncTask，体会如何在Android中进行异步操作进行各种网络请求，熟练掌握异步线程的使用。初级·35637人在学 Android必学-异步加载 重量级的课程来了：Android必须系列。本系列课程中的内容为Android开发中用处最多，面试问的最多的知识点。本次课程将带领大家了解Android中异步加载的一般处理方法中级·42663人在学 Android攻城狮的第二门课（第3季） 本课程深入的讲解了Android中的手势识别原理、数据存储方式、对组件的详细剖析以及对Service的深度讲解，每一个知识点都对应有实际案例。本课程内容不仅使您牢牢掌握之前的基础知识点，学完之后也会有新的收获、新的体会。初级·62568人在学 Android面试常客Handler详解 本课程将深入理解Android的Handler机制，并结合源码实例，讲解Looper、MessageqQueue、Handler之间的关系，同时介绍HandlerThread的原理和使用，并分析Handler在开发中遇到的异常的原因，最后从源码的角度分析一下Handler更新UI的流程高级·44265人在学 Android中的Http通信 本次课程将带领大家android当中网络交互处理，例如常见的post、get请求以及相关知识的应用。初级·54119人在学 Android动画基础Android攻城狮的第二门课（第2季） 本课程讲带你熟悉Android开发中常用的调试方式，各种对话框，各种提示菜单，各种动画效果等，来进一步充实你的Android知识初级·51108人在学 浅谈Android动画 通过各式各样的案例，实现各种Android各种炫酷的动画效果，增加用户对Android系统的喜爱，同时也可以培养同学们的学习兴趣。初级·44645人在学 Android属性动画赏析 动画几乎是一个好的App所不可缺少的一部分，它体现了一种更友好的交互方式，在iOS、AndroidL中动画的使用越来越多，特别是后者更是着重强调设计更好的动画。从3.0开始，Android就提供了一种更为强大的属性动画框架。本次课程，将向你介绍如何使用属性动画做出更好的动画中级·32288人在学 流行开发工具千变万化的ViewPager切换动画 本课程将带领大家实现个性的ViewPager切换动画，首先介绍通过PageTransformer结合ViewPager.setPageTransformer来实现动画效果，然后教大家如何让其兼容到3.0以后，其中会涉及到属性动画等知识点；最后将介绍通过自定义ViewPager的方式来实现动画切换效果中级·40377人在学 高仿微信5.2.1主界面及消息提醒 本课程将带领大家从无到有的实现微信的整体界面和ViewPager指示器跟随手指拖动的动画效果。课程包含ViewPager与FragmentPagerAdapter的使用，通过分析OnPageChangeListener手动控制指示器的动画效果，以及如何将BadgeView作为消息通知用于我们的项目之中高级·51926人在学 多种多样的App主界面Tab实现方法 Tab选项卡几乎成为了App必备的一个功能，它的实现方法也是多种多样，本课程就将讲解迄今为止最主流的4种实现Tab的方法，包括ViewPager、Fragment、FragmentPagerAdapter和ViewPagerIndicator中级·42493人在学 与AndroidStudio的第一次亲密接触 AndroidStudio是Google在I/O大会上发布的一个新的集成开发环境，可以让Android开发变的更简单。本课程会详细的向您介绍AndroidStudio的安装配置、使用技巧以及相对于Eclipse开发的优势，并通过实际的操作让大家快速熟悉AndroidStudio的使用，让您体验更强大的开发工具初级·82319人在学 超快的Android模拟器Genymotion 本课程将介绍Android平台下的一款最快的、最流行的Android模拟器，以及如何安装Genymotion模拟器，并对eclipse和Intellij等开发工具进行配置初级·45876人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.cheshen.wiki/tags/Android/"},{"name":"求职","slug":"求职","permalink":"http://www.cheshen.wiki/tags/求职/"},{"name":"实战","slug":"实战","permalink":"http://www.cheshen.wiki/tags/实战/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"C++远征攻略","slug":"C++远征攻略","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.260Z","comments":true,"path":"2017/04/15/C++远征攻略/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/C++远征攻略/","excerpt":"本路线共：11门课程 学习人数：16958人在学 章节预览：C语言入门LinuxC语言编程基本原理与实践LinuxC语言指针与内存LinuxC语言结构体C++远征之起航篇C++远征之离港篇C++远征之封装篇（上）C++远征之封装篇（下）C++远征之继承篇C++远征之多态篇C++远征之模板篇","text":"本路线共：11门课程 学习人数：16958人在学 章节预览：C语言入门LinuxC语言编程基本原理与实践LinuxC语言指针与内存LinuxC语言结构体C++远征之起航篇C++远征之离港篇C++远征之封装篇（上）C++远征之封装篇（下）C++远征之继承篇C++远征之多态篇C++远征之模板篇 远征前准备C语言入门 本C语言教程从以下几个模块来贯穿主要知识点：初始C程序、数据类型、运算符、语句结构、函数和数组。每个阶段都配有练习题同时提供在线编程任务。希望通过本教程帮助C语言入门学习者迅速掌握程序逻辑并开始C语言编程。初级·423695人在学 LinuxC语言编程基本原理与实践 介绍C语言基本工作原理以及适用与C的实际开发方式，并指导童鞋们能在Linux环境下编写并运行符合实际商业开发环境下的C语言程序。中级·113454人在学 LinuxC语言指针与内存 本课程通过图形与程序实验，配合gdb调试工具，将c语言编程中最难理解的内存管理与指针形象的展示在大家面前。由于内存地址的概念偏底层，想真正掌握还需按照课程中教授的方法多做实验以加深映像，相信反复试验几次之后，大家都能够对c语言有更加深刻的理解。中级·60389人在学 LinuxC语言结构体 本课程深入的讲解了C语言中，预处理是怎么回事，结构体和公用体又是如何使用及他们之间的区别，动态数据结构体是什么以及位运算的秘密。希望通过本课程的学习，能帮助小伙伴们进一步的理解C语言。中级·67552人在学 远征起航C++远征之起航篇 本课程是C++的初级课程，是在C语言基础上的一个延伸，讲述了包括新增数据类型、命名空间等内容，最后通过一个通俗易懂的例子将所述知识点融会贯通，以达到知识灵活运用，最终得以升华的目的。初级·150268人在学 C++远征之离港篇 本课程是C++起航篇的延伸，讲述了引用、const、函数默认值、函数重载、内存管理等内容，最后通过一个通俗易懂的例子将所述知识点融会贯通，以达到知识灵活运用，最终得以升华的目的。初级·67016人在学 远征面向对象C++远征之封装篇（上） 本课程将代领小伙伴们真正迈入C++语言的面向对象大门，在课程中，将会深入讲解类的定义方法，属性的封装方法，构造函数和析构函数等内容，并且所有知识均会通过编码实践的方式讲解到操作层面，力求帮助小伙伴们即学即会！初级·56648人在学 C++远征之封装篇（下） 本课程是真正跨入C++面向对象之门，讲述了对象数组、成员、指针，this指针，常对象、引用、指针、成员函数以及深拷贝和浅拷贝，课程的最后讲述了一个迷宫案例，通过这个案例可以将C++所学知识融会贯通，所有知识均通过编码实践的方式讲解到操作层面，力求即学即会。初级·37933人在学 C++远征之继承篇 本课程将带领大家体会C++面向对象三大特性中的继承特性，讲述了基类、派生类的概念，公有继承、保护继承和私有继承、多重继承及多继承，虚析构函数及虚继承的作用，理解课程内容对于面向对象的学习将大有裨益，所有知识均通过编码实践的方式讲解到操作层面，力求即学即会。初级·40296人在学 C++远征之多态篇 本课程将带领大家体会面向对象三大特性中的多态特性，讲述了虚函数、抽象类和接口类等概念，以及多态的实现原理，课程的最后引入RTTI及异常处理，使整个多态篇更加完整，更具实战指导性，本门课程是C++远征课程的高潮和经典，对于面向对象的语言的学习将大有裨益。初级·37240人在学 远征模板C++远征之模板篇 本课程将带领大家体会更为奇妙的C++，讲述了静态、友元、运算符重载的定义及使用方法，其中重点讲述函数模板、类模板以及标准模板库的相关知识，知识内容更重实用性，本门课程对于面向对象的语言的学习将大有裨益，所有知识均以实践的方式讲解到操作层面，力求即学即会。初级·57462人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"C++基础","slug":"C-基础","permalink":"http://www.cheshen.wiki/tags/C-基础/"},{"name":"面向对象","slug":"面向对象","permalink":"http://www.cheshen.wiki/tags/面向对象/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Android-微信热门功能合集","slug":"Android-微信热门功能合集","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.244Z","comments":true,"path":"2017/04/15/Android-微信热门功能合集/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Android-微信热门功能合集/","excerpt":"本路线共：6门课程 学习人数：4591人在学 章节预览：高仿微信5.2.1主界面及消息提醒微信6.0主界面Android-仿微信语音聊天Android-仿微信图片选择器Android高级特效-索引微信SDK-分享你的朋友圈","text":"本路线共：6门课程 学习人数：4591人在学 章节预览：高仿微信5.2.1主界面及消息提醒微信6.0主界面Android-仿微信语音聊天Android-仿微信图片选择器Android高级特效-索引微信SDK-分享你的朋友圈 界面的进化高仿微信5.2.1主界面及消息提醒 本课程将带领大家从无到有的实现微信的整体界面和ViewPager指示器跟随手指拖动的动画效果。课程包含ViewPager与FragmentPagerAdapter的使用，通过分析OnPageChangeListener手动控制指示器的动画效果，以及如何将BadgeView作为消息通知用于我们的项目之中高级·51926人在学 微信6.0主界面 本课程将讲解微信6.0主界面的实现方法，包括主界面的上中下三部分，主要难点在于Title的实现和底部Tab的实现两部分，并且此次将根据童鞋们的反馈和建议来实现部分的功能，其中包括使用ActionBar制作Title以及监听ViewPager界面切换的处理高级·51776人在学 热门功能赏析Android-仿微信语音聊天 本课程通过结合自定义View、媒体相关API、Dialog管理等实现Android仿微信语音功能，课程主要涉及自定义录音Button与用户的交互，MediaRecorder实现录音,MediaPlayer实现播放，以及三者间的交互与协作和一系列的UI效果。中级·35984人在学 Android-仿微信图片选择器 微信大家天天用，有没有想过功能如何实现的呢？本门课程老师讲带领同学实现Android中高仿微信图片选择器，此功能较完整，结合了ImageLoader/Handler/PopWindow等常用类，从整体思路分析，到一步步的功能实现，值得一学！中级·25005人在学 Android高级特效-索引 本门课程为小伙伴们带来了一个APP中的熟面孔，索引功能。索引可以在通讯录的右侧实现字母搜索，有效增加了查找的便捷度。是应用中不可缺少的功能，放眼望去，微信，QQ等各大APP中都缺少不了他，还等什么？跟着李宁老师一起学习吧！高级·26984人在学 说到微信，离不开分享微信SDK-分享你的朋友圈 本门课程介绍Android微信SDK的使用，通过案例讲解实现分享朋友圈功能。中级·38252人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"微信功能","slug":"微信功能","permalink":"http://www.cheshen.wiki/tags/微信功能/"},{"name":"加薪升职","slug":"加薪升职","permalink":"http://www.cheshen.wiki/tags/加薪升职/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"C语言学习攻略","slug":"C语言学习攻略","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.264Z","comments":true,"path":"2017/04/15/C语言学习攻略/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/C语言学习攻略/","excerpt":"本路线共：4门课程 学习人数：33271人在学 章节预览：C语言入门LinuxC语言编程基本原理与实践LinuxC语言指针与内存LinuxC语言结构体","text":"本路线共：4门课程 学习人数：33271人在学 章节预览：C语言入门LinuxC语言编程基本原理与实践LinuxC语言指针与内存LinuxC语言结构体 基础奠基C语言入门 本C语言教程从以下几个模块来贯穿主要知识点：初始C程序、数据类型、运算符、语句结构、函数和数组。每个阶段都配有练习题同时提供在线编程任务。希望通过本教程帮助C语言入门学习者迅速掌握程序逻辑并开始C语言编程。初级·423695人在学 原理实践LinuxC语言编程基本原理与实践 介绍C语言基本工作原理以及适用与C的实际开发方式，并指导童鞋们能在Linux环境下编写并运行符合实际商业开发环境下的C语言程序。中级·113454人在学 核心秘籍LinuxC语言指针与内存 本课程通过图形与程序实验，配合gdb调试工具，将c语言编程中最难理解的内存管理与指针形象的展示在大家面前。由于内存地址的概念偏底层，想真正掌握还需按照课程中教授的方法多做实验以加深映像，相信反复试验几次之后，大家都能够对c语言有更加深刻的理解。中级·60389人在学 LinuxC语言结构体 本课程深入的讲解了C语言中，预处理是怎么回事，结构体和公用体又是如何使用及他们之间的区别，动态数据结构体是什么以及位运算的秘密。希望通过本课程的学习，能帮助小伙伴们进一步的理解C语言。中级·67552人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"编程基础","slug":"编程基础","permalink":"http://www.cheshen.wiki/tags/编程基础/"},{"name":"零基础","slug":"零基础","permalink":"http://www.cheshen.wiki/tags/零基础/"},{"name":"C语言基础","slug":"C语言基础","permalink":"http://www.cheshen.wiki/tags/C语言基础/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Java工程师","slug":"Java工程师","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.276Z","comments":true,"path":"2017/04/15/Java工程师/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Java工程师/","excerpt":"本路线共：40门课程 学习人数：138079人在学 章节预览：Java入门第一季Java入门第二季Java入门第三季二进制基础文件传输基础——JavaIO流Java眼中的XML—文件读取Java眼中的XML文件写入JavaSocket应用—通信是这样练成的深入浅出Java多线程与MySQL的零距离接触Oracle数据库开发必备利器之SQL基础JDBC之“对岸的女孩看过来”HTML+CSS基础课程JavaScript入门篇JavaScript进阶篇JAVA遇见HTML——JSP篇JavaWeb开发技术应用——过滤器JAVA遇见HTML——Servlet篇JAVAWeb开发技术应用——监听器使用JSP+Servlet技术生成报表Java实现验证码制作反射——Java高级开发必须懂的全面解析Java注解Hibernate初探之单表映射Hibernate初探之一对多映射HQL数据查询基础通过自动回复机器人学Mybatis—基础版通过自动回复机器人学Mybatis—加强版Struts2入门Struts2拦截器浅析Spring入门篇Spring事务管理SpringMVC起步SpringMVC拦截器版本管理工具介绍—SVN篇JUnit—Java单元测试必备工具项目管理利器——mavenJava中的文件上传下载Java分页原理与实践（上）使用Struts2+Hibernate开发学生信息管理功能","text":"本路线共：40门课程 学习人数：138079人在学 章节预览：Java入门第一季Java入门第二季Java入门第三季二进制基础文件传输基础——JavaIO流Java眼中的XML—文件读取Java眼中的XML文件写入JavaSocket应用—通信是这样练成的深入浅出Java多线程与MySQL的零距离接触Oracle数据库开发必备利器之SQL基础JDBC之“对岸的女孩看过来”HTML+CSS基础课程JavaScript入门篇JavaScript进阶篇JAVA遇见HTML——JSP篇JavaWeb开发技术应用——过滤器JAVA遇见HTML——Servlet篇JAVAWeb开发技术应用——监听器使用JSP+Servlet技术生成报表Java实现验证码制作反射——Java高级开发必须懂的全面解析Java注解Hibernate初探之单表映射Hibernate初探之一对多映射HQL数据查询基础通过自动回复机器人学Mybatis—基础版通过自动回复机器人学Mybatis—加强版Struts2入门Struts2拦截器浅析Spring入门篇Spring事务管理SpringMVC起步SpringMVC拦截器版本管理工具介绍—SVN篇JUnit—Java单元测试必备工具项目管理利器——mavenJava中的文件上传下载Java分页原理与实践（上）使用Struts2+Hibernate开发学生信息管理功能 数据操作Java入门第一季 欢迎来到精彩的Java编程世界！Java语言已经成为当前软件开发行业中主流的开发语言。本课程将介绍Java环境搭建、工具使用、基础语法。带领大家一步一步的踏入Java达人殿堂！Let’sgo!初级·601606人在学 Java入门第二季 本课程是程序猿质变课程，理解面向对象的思想，掌握面向对象的基本原则以及Java面向对象编程基本实现原理，熟练使用封装、继承、多态面向对象三大特性，带你进一步探索Java世界的奥秘！初级·288694人在学 Java入门第三季 在本课程中，@陈码农携手@laurenyany将带领小伙伴们进一步探索Java的奥秘，希望通过本次课程的学习，能够帮助小伙伴们快速掌握关于Java中的异常处理、集合框架、字符串的操作和常用类的使用。不容错过的精彩，快来加入吧！！初级·224060人在学 二进制基础 二进制是计算机唯一能识别的语言，是学习计算机技术必须要懂的知识。本门课程将带您认识二进制的由来，如何进行不同进制间的转换，如二进制与十进制减的相互转换，以及位运算，最后介绍Java中的进制。初级·70287人在学 文件传输基础——JavaIO流 如何在Java中进行文件的读写，JavaIO流是必备的知识。本门课程主要为您带来Java中的输入输出流的内容，包括文件编码、使用File类对文件和目录进行管理、字节流和字符流的基本操作，以及对象的序列化和反序列化的内容。中级·84207人在学 Java眼中的XML—文件读取 文件的形态是千变万化的，在Internet中，我们通常使用一种叫做XML的文件来传输或者存储数据。本次课程中，@JessicaJiang将会带领小伙伴们把这种XML文件应用与Java程序结合起来，教你如何应用Java“解析XML”。中级·58083人在学 Java眼中的XML文件写入 XML在数据传输及存储等方面非常流行，所以使用JAVA程序来生成相应用途的XML文件就变得非常重要，那么问题来了：如何使用JAVA程序生成一个XML文档呢？本节课将详细为你解答！中级·40438人在学 JavaSocket应用—通信是这样练成的 网络无处不在，移动互联时代也早已到来，单机版程序慢慢的已没有生命力，所有的程序都要能够访问网络，比如QQ网络聊天程序、迅雷下载程序等，这些程序都要同网络打交道，本次将与各位小伙伴们分享的就是Java中的网络编程——Socket通信高级·78706人在学 深入浅出Java多线程 多线程是日常开发中的常用知识，也是难用知识。通过本视频，你可以了解Java中多线程相关的基本概念，如何创建，启动和停止线程？什么是正确的多线程，怎样编写多线程程序。在掌握基础之后，将为你展望进阶路线，为进一步的学习提供方向。中级·102847人在学 与MySQL的零距离接触 本课程涵盖全部MySQL数据库的基础，主要学习MySQL数据库的基础知识、数据表的常用操作及各种约束的使用，以及综合的运用各种命令实现记录进行CURD等操作，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。初级·219607人在学 Oracle数据库开发必备利器之SQL基础 OracleDatabase，又名OracleRDBMS，或简称Oracle，是甲骨文公司的一款关系数据库管理系统。本课程主要介绍Oracle的SQL基础，包括表空间的概念，如何登录Oracle数据库，如何管理表及表中的数据，以及约束的应用。为后续课程的学习打下一个良好的基础。初级·86561人在学 JDBC之“对岸的女孩看过来” JDBC技术是Java开发必备的知识，并且是学习Hibernate和Mybatis的基础，本视频通过实例贯穿的方式，给大家一点一点的剖析JDBC技术，使大家由浅入深的了解JDBC技术的全貌，什么是JDBC，怎么使用JDBC，为进一步学习集成框架打下良好的基础。中级·63114人在学 简单Web应用HTML+CSS基础课程 本课程从最基本的概念开始讲起，步步深入，带领大家学习HTML、CSS样式基础知识，了解各种常用标签的意义以及基本用法，后半部分讲解CSS样式代码添加，为后面的案例课程打下基础。初级·676735人在学 JavaScript入门篇 本视频教程让您快速认识JavaScript，熟悉JavaScript基本语法、窗口交互方法和通过DOM进行网页元素的操作，学会如何编写JS代码，如何运用JavaScript去操作HTML元素和CSS样式，本JavaScript教程分为四个章节，能够让您快速入门，为JavaScript深入学习打下基础。初级·444787人在学 JavaScript进阶篇 做为WEB攻城师必备技术JavaScript，本课程从如何插入JS代码开始，学习JS基础语法、语法、函数、方法等，让你掌握JS编程思路、知识的使用等，实现运用JS语言为网页增加动态效果，达到与用户交互的目的。中级·283624人在学 JAVA遇见HTML——JSP篇 亲，这里有资深讲师为初学者量身打造的JavaWeb入门级课程JSP，讲师将通过大量的案例向您展示JavaWeb开发环境搭建、工具使用和JSP的基本语法，深入理解JavaWeb开发思想，最终使您能独立开发简单的JavaWeb应用。初级·131124人在学 JavaWeb开发技术应用——过滤器 本课程主要是从实际生活当中的过滤器入手,详细讲解了JavaWeb过滤器的概念、工作原理、生命周期以及过滤器的API。然后从一个过滤器引入多个过滤器链的相关知识，同时课程还详细介绍了过滤器的分类。最后以两个实际项目当中的案例诠释了过滤器的应用。中级·47598人在学 JAVA遇见HTML——Servlet篇 Servlet是JAVAWeb开发的核心基础，在项目中的应用非常广泛。本门课程在JSP课程的基础上，深入介绍Servlet的基础知识。包括Servlet的执行流程和生命周期，Tomcat对Servlet的装载情况，如何获取表单数据以及Servlet路径跳转。最后会带大家使用流行的MVC架构进行项目开发。初级·88922人在学 JAVAWeb开发技术应用——监听器 本课程从JavaWeb中的监听器的概念和用途入手，紧接着讲解监听器的第一个实例，然后由浅到深地从启动顺序到分类、从Servelt2.5到Servlet3.0，重点讲解了两种分类，包括按监听的对象划分和按监听的事件划分，最后以一个实际项目中统计在线人数的案例进行讲解。中级·53425人在学 使用JSP+Servlet技术生成报表 报表就是用表格、图表等格式来动态显示数据。本课程是JavaWeb的案例课程，主要关注于用表格形式来显示数据。主要内容包括报表的基础知识，报表实现原理和核心技术，以及如何使用JSP+Servlet技术来生成报表。中级·48945人在学 Java实现验证码制作 验证码的应用十分普遍，我们经常会在网上看到数字字母组合的验证码、包含中文的验证码、以及算式形式的验证码等等。本门课程就会带大家使用JavaWeb中的servlet以及Jcaptcha、Kaptcha两种开源组件来实现各式各样的验证码。中级·42540人在学 实用工具反射——Java高级开发必须懂的 反射是Java开发中一个非常重要的概念，掌握了反射的知识，才能更好的学习Java高级课程，因此必须要学习——你懂的！本门课程主要介绍Class类的使用，方法和成员变量的反射，以及通过反射了解集合泛型的本质等知识。中级·84465人在学 全面解析Java注解 在项目开发中，注解的使用无处不在。注解的使用简化了代码，减少了程序员的工作量。本课程带领小伙伴们全面认识Java的注解，包括为什么使用注解、Java中的常见注解、注解的分类和如何自定义注解，最后通过一个实战案例来演示注解在实际项目中的应用。中级·72172人在学 Hibernate初探之单表映射 Hibernate是一个著名的对象关系映射框架，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。本门课程是Hibernate的入门课程，主要介绍ORM和hibernate的概念，如何在eclipse中创建hibernate实例及相关配置文件的详解说明。高级·47401人在学 Hibernate初探之一对多映射 现实世界中的对象很少有孤立存在的，例如学生，往往与所在班级和授课老师之间存在关联关系。在本次课程中，@laurenyang将带领小伙伴们一起学习Hibernate中的关联映射——一对多映射，会依次向大家介绍单向一对多和单向多对一的配置，以及cascade和inverse属性的作用。高级·29170人在学 HQL数据查询基础 本次课程是Hibernate的进阶课程，将帮助小伙伴们，在掌握了使用Hibernate进行数据表管理之后，进一步认识什么是HQL，HQL常用的语句格式以及在Hibernate框架中如何执行HQL查询获取我们需要的数据。高级·28945人在学 通过自动回复机器人学Mybatis—基础版 各位小伙伴们，你是否还在为使用Java中原始JDBC的开发方式的繁琐而苦恼呢？Mybatis可以帮你解决这个难题，在本次课程中，让我们通过基础教程加案例实战开发的学习方式，逐步学习Mybatis的下载与配置以及基本功能应用。高级·60267人在学 通过自动回复机器人学Mybatis—加强版 你是愿意停留在仅仅会使用Mybatis的层次上，还是愿意与我一起揭开Mybatis面纱，看看背后的故事？本课程将继续上一课程中的案例来介绍Java中Mybatis的功能，与上一课程不同的是：本课程在介绍功能的同时，尽可能多的介绍Mybatis源码。高级·32986人在学 Struts2入门 Struts2是当前流行的JavaWeb框架！本门课程首先介绍Strust2的基本概念和发展历史，然后从一个案例入手，带领小伙伴们对Struts2有一个全面的了解。接着有对Struts2进行了更深入的讲解。相信通过本课程的学习，小伙伴们一定能够有所收获。高级·59819人在学 Struts2拦截器浅析 Struts2大多数核心功能是通过拦截器实现的，每个拦截器完成某项功能，比如，params拦截器负责解析HTTP请求的参数，并设置Action的属性。本次将与各位小伙伴们分享的就是Struts2中的拦截器。高级·26394人在学 Spring入门篇 Spring是为解决企业应用程序开发复杂性而创建的一个Java开源框架，应用非常广泛。业内非常流行的SSH架构中的其中一个“S”指的就是Spring。本门课程作为Spring的入门级课程，将结合实例为您带来依赖注入、IOC和AOP的基本概念及用法，为后续高级课程的学习打下基础。高级·120237人在学 Spring事务管理 事务管理是Spring中的一个非常重要的知识。本门课程首先介绍Spring的基本概念，然后以银行转账为例，介绍Spring的编程式事务管理和声明式事务管理的应用场景和实现方式！希望通过本门课程的学习，使得小伙伴们可以在开发中灵活地应用事务。高级·45699人在学 SpringMVC起步 SpringMVC为我们提供了一个基于组件和松耦合的MVC实现框架。在使用Java中其它MVC框架多年之后，面对SpringMVC有一种相见恨晚的感觉。SpringMVC是如此的优雅，轻盈与简洁，让人从其它框架的桎梏解脱出来。本课程将带你步入SpringMVC。高级·99701人在学 SpringMVC拦截器 拦截器是SpringMVC中一个十分重要且应用广泛的内容。本课程通过乱码问题的解决引入SpringMVC拦截器的使用，介绍了拦截器的工作原理、实现方法和使用场景，最后介绍了拦截器与过滤器的区别。高级·42065人在学 版本管理工具介绍—SVN篇 多人协作开发是程序猿不可避免的话题，版本控制工具不可或缺，学会SVN，让初入公司的你与他人的合作不再尴尬！本课程主要介绍版本控制工具之一SVN的安装、结合Java代码的简单操作及常见问题解决。版本控制的环境下才能共创程序猿梦想，大家代码都好才是真的好！初级·59747人在学 JUnit—Java单元测试必备工具 如何加快项目进度，提升Java代码质量？如何未雨绸缪，从此维护代码不再苦逼？学会使用junit对代码进行单元测试，从此腰不酸了腿不疼了陪女朋友逛街也更有劲了。这么好的东东，赶快来看看吧。中级·41991人在学 项目管理利器——maven maven是优秀的项目管理和构建工具，能让我们更为方便的来管理和构建项目，从最基础的环境配置，到maven核心知识点的应用，本套视频将带领大家进行一段轻松的maven之旅。让我们一起使用maven来构建和管理Java项目吧！中级·74641人在学 综合实战Java中的文件上传下载 现实JavaWeb开发过程当中经常会遇到文件上传、下载的场景。如何实现轻松、快捷的文件上传下载功能呢？本节课程由简入深，从Jsp+Servlet开始逐步分析、实现文件上传下载功能及相关框架的使用。中级·49276人在学 Java分页原理与实践（上） 分页功能是系统和应用最基本的组成部分。本课程通过总结常见的分页样式以及分析对比分页原理以及实现方式，通过代码实例，让你轻松学会分页功能的开发。通过学习本课程，你也能轻松的实现facebook，QQ空间，京东商城等分页的效果。中级·43415人在学 使用Struts2+Hibernate开发学生信息管理功能 本课程通过学生信息管理功能的开发，来介绍Struts2和Hibernate的整合。主要内容包括：Struts2和Hibernate整合，用户登录模块和学生信息管理模块的设计和实现。通过本课程的学习，一定会使小伙伴们的JavaWeb开发技能更上一层楼。高级·56204人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"求职","slug":"求职","permalink":"http://www.cheshen.wiki/tags/求职/"},{"name":"Java","slug":"Java","permalink":"http://www.cheshen.wiki/tags/Java/"},{"name":"小白","slug":"小白","permalink":"http://www.cheshen.wiki/tags/小白/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Cocos2d-x游戏开发快速入门","slug":"Cocos2d-x游戏开发快速入门","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.262Z","comments":true,"path":"2017/04/15/Cocos2d-x游戏开发快速入门/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Cocos2d-x游戏开发快速入门/","excerpt":"本路线共：7门课程 学习人数：5874人在学 章节预览：C++远征之起航篇C++远征之继承篇C++远征之多态篇Cocos2d-x游戏开发初体验-C++篇Cocos2d-x基础教程二-会动的时钟新春特辑-Cocos抢红包Cocos2d-x游戏之七夕女神抓捕计划","text":"本路线共：7门课程 学习人数：5874人在学 章节预览：C++远征之起航篇C++远征之继承篇C++远征之多态篇Cocos2d-x游戏开发初体验-C++篇Cocos2d-x基础教程二-会动的时钟新春特辑-Cocos抢红包Cocos2d-x游戏之七夕女神抓捕计划 语言基础C++远征之起航篇 本课程是C++的初级课程，是在C语言基础上的一个延伸，讲述了包括新增数据类型、命名空间等内容，最后通过一个通俗易懂的例子将所述知识点融会贯通，以达到知识灵活运用，最终得以升华的目的。初级·150268人在学 C++远征之继承篇 本课程将带领大家体会C++面向对象三大特性中的继承特性，讲述了基类、派生类的概念，公有继承、保护继承和私有继承、多重继承及多继承，虚析构函数及虚继承的作用，理解课程内容对于面向对象的学习将大有裨益，所有知识均通过编码实践的方式讲解到操作层面，力求即学即会。初级·40296人在学 C++远征之多态篇 本课程将带领大家体会面向对象三大特性中的多态特性，讲述了虚函数、抽象类和接口类等概念，以及多态的实现原理，课程的最后引入RTTI及异常处理，使整个多态篇更加完整，更具实战指导性，本门课程是C++远征课程的高潮和经典，对于面向对象的语言的学习将大有裨益。初级·37240人在学 初始游戏引擎Cocos2d-x游戏开发初体验-C++篇 游戏开发博大精深，在这个后页游时期的手游时代，还在为无法入门游戏行业而烦恼吗？Cocos2d-x就是一款专门为手机游戏打造的开源游戏引擎，够轻量、够简单。在这个不一样的时代，雷哥将带着你走出一个不一样的自己初级·47969人在学 Cocos2d-x基础教程二-会动的时钟 是否在玩游戏的时候听到过很多名词？比如精灵，场景，粒子，渲染，骨骼动画等等。是否对这些名词既熟悉又陌生？那么你的救星来了!本节课程是对基础元素的讲解，旨在入门Cocos2d-x引擎初级·13062人在学 游戏案例制作新春特辑-Cocos抢红包 过年啦雷哥给大家发福利了~不过福利不是妹子而是一项技能：本门课程为一门实例课，同学们可以在课程中体验到动画与动作的基本使用，可作为Cocos第二课到第三课的过渡。中级·15246人在学 Cocos2d-x游戏之七夕女神抓捕计划 想抱得美人归么？想从高富帅手中“绑”走女神么？如果你想逆袭，那么快来学习吧。本课程将带领大家从0开始做一款真正的RPG的游戏，其中涉及到很多当下热门游戏所用到的技术。帧动画，待机动画，渲染等等。小编哈喇子都出来了～～我在课程中等大家哦～高级·30066人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://www.cheshen.wiki/tags/游戏开发/"},{"name":"游戏开发攻略","slug":"游戏开发攻略","permalink":"http://www.cheshen.wiki/tags/游戏开发攻略/"},{"name":"游戏开发速成","slug":"游戏开发速成","permalink":"http://www.cheshen.wiki/tags/游戏开发速成/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Linuxshell运维实战","slug":"Linux shell运维实战","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.279Z","comments":true,"path":"2017/04/15/Linux shell运维实战/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Linux shell运维实战/","excerpt":"本路线共：4门课程 学习人数：7695人在学 章节预览：Shell典型应用之主控脚本实现Shell典型应用之系统信息及运行状态获取Shell典型应用之nginx和mysql应用状态分析Shell典型应用之应用日志分析","text":"本路线共：4门课程 学习人数：7695人在学 章节预览：Shell典型应用之主控脚本实现Shell典型应用之系统信息及运行状态获取Shell典型应用之nginx和mysql应用状态分析Shell典型应用之应用日志分析 控制中心Shell典型应用之主控脚本实现 《shell典型应用》系列主要使用shell脚本来实现企业中的常见应用，包括主控脚本实现、Linux系统信息及运行状态获取、ngnix和mysql应用状态分析、应用日志分析四个部分。本门课程主要介绍主控脚本实现，以及案例的一些准备工作。高级·24043人在学 状态监控Shell典型应用之系统信息及运行状态获取 本门课程是《shell典型应用》系列的第二门课程，主要分为两个部分，一是介绍如何提取内核版本、系统版本和网络地址等操作系统信息。二是介绍如何分析系统的运行状态，包括CPU负载、内存及磁盘使用率等。高级·15704人在学 Shell典型应用之nginx和mysql应用状态分析 本课程是《Shell典型应用》系列课程的第三门，主要介绍如何监控nginx和mysql的运行状态。包括对nginx服务器的响应状态和QPS等的并发响应参数进行分析，以及对mysql服务情况和主从响应状态的监控。高级·20106人在学 日志分析Shell典型应用之应用日志分析 本课程是《Shell典型应用》系列课程的最后一门，主要介绍如何应用shell脚本分析系统日志。包括Linux系统日志的分类和HTTP状态码的介绍，接着又通过分析HTTP状态码在不同区间请求条数的案例，来展示如何分析系统日志。高级·19961人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://www.cheshen.wiki/tags/实战/"},{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"http://www.cheshen.wiki/tags/shell/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"高德开发者必由之路——JSAPI篇","slug":"高德开发者必由之路——JS API篇","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.358Z","comments":true,"path":"2017/04/15/高德开发者必由之路——JS API篇/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/高德开发者必由之路——JS API篇/","excerpt":"本路线共：6门课程 学习人数：8168人在学 章节预览：HTML+CSS基础课程JavaScript入门篇JavaScript进阶篇JavaScript深入浅出阿当大话西游之WEB组件如何使用高德JS-API进行基于LBS的开发","text":"本路线共：6门课程 学习人数：8168人在学 章节预览：HTML+CSS基础课程JavaScript入门篇JavaScript进阶篇JavaScript深入浅出阿当大话西游之WEB组件如何使用高德JS-API进行基于LBS的开发 夯实基础之HTML、CSSHTML+CSS基础课程 本课程从最基本的概念开始讲起，步步深入，带领大家学习HTML、CSS样式基础知识，了解各种常用标签的意义以及基本用法，后半部分讲解CSS样式代码添加，为后面的案例课程打下基础。初级·676735人在学 夯实基础之JavaScriptJavaScript入门篇 本视频教程让您快速认识JavaScript，熟悉JavaScript基本语法、窗口交互方法和通过DOM进行网页元素的操作，学会如何编写JS代码，如何运用JavaScript去操作HTML元素和CSS样式，本JavaScript教程分为四个章节，能够让您快速入门，为JavaScript深入学习打下基础。初级·444787人在学 JavaScript进阶篇 做为WEB攻城师必备技术JavaScript，本课程从如何插入JS代码开始，学习JS基础语法、语法、函数、方法等，让你掌握JS编程思路、知识的使用等，实现运用JS语言为网页增加动态效果，达到与用户交互的目的。中级·283624人在学 JavaScript深入浅出 这是一个帮助您系统学习JavaScript编程语言的课程，该课由浅入深的介绍JavaScript的语言特性，结合实际例子解析常见误区，启发你的思考，帮助学习者从入门到掌握，提升您的JavaScript技能。高级·169230人在学 初探WEB组件开发阿当大话西游之WEB组件 我们在实际前端开发过程中,能否封装出易用易维护可定制可扩展的组件，是衡量工程师能力是否成熟的非常重要的一个指标。本课程以弹窗组件为例，讲解如何开发web前端组件,如何实现可读性、扩展性、易用性、重用性、模块化等等技巧,让您的组件开发技能不在空白。高级·22546人在学 变身高德开发者如何使用高德JS-API进行基于LBS的开发 本课程为大家带来如何使用JS-API进行基于LBS的开发。高德地图JS-API能帮助你在网站或移动端中构建功能丰富交互性强的地图应用程序。除基本地图功能接口外还提供本地搜索、路线规划等服务，可以根据你的需要选择使用。通过本课程你可以动手实现你的第一个地图应用！初级·14386人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"地图开发","slug":"地图开发","permalink":"http://www.cheshen.wiki/tags/地图开发/"},{"name":"从基础到实践","slug":"从基础到实践","permalink":"http://www.cheshen.wiki/tags/从基础到实践/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Linux运维工程师","slug":"Linux运维工程师","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.285Z","comments":true,"path":"2017/04/15/Linux运维工程师/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Linux运维工程师/","excerpt":"本路线共：22门课程 学习人数：44292人在学 章节预览：Linux达人养成计划ILinux达人养成计划IILinux网络管理Linux软件安装管理Linux权限管理之基本权限Linux权限管理之特殊权限Linux中的计划任务之CrontabLinux服务管理Linux系统管理shell编程之变量shell编程之运算符shell编程之环境变量配置文件shell编程之正则表达式shell编程之条件判断与流程控制Shell典型应用之主控脚本实现Shell典型应用之系统信息及运行状态获取Shell典型应用之nginx和mysql应用状态分析Shell典型应用之应用日志分析Linux系统扫描技术及安全防范用iptables搭建一套强大的安全防护盾Linux智能DNS服务搭建之Bind服务在UbuntuServer下搭建LAMP环境","text":"本路线共：22门课程 学习人数：44292人在学 章节预览：Linux达人养成计划ILinux达人养成计划IILinux网络管理Linux软件安装管理Linux权限管理之基本权限Linux权限管理之特殊权限Linux中的计划任务之CrontabLinux服务管理Linux系统管理shell编程之变量shell编程之运算符shell编程之环境变量配置文件shell编程之正则表达式shell编程之条件判断与流程控制Shell典型应用之主控脚本实现Shell典型应用之系统信息及运行状态获取Shell典型应用之nginx和mysql应用状态分析Shell典型应用之应用日志分析Linux系统扫描技术及安全防范用iptables搭建一套强大的安全防护盾Linux智能DNS服务搭建之Bind服务在UbuntuServer下搭建LAMP环境 Linux基础Linux达人养成计划I 本课程以通俗易懂的语言、风趣幽默的实例、清晰严谨的逻辑介绍了Linux的基础内容。课程以CentOS操作系统为例，为你带来Linux的简介、系统安装和常用命令等内容。让您在轻松的氛围中感受到Linux之美。初级·225890人在学 Linux达人养成计划II 本课程介绍Linux系统下操作VI编辑器、创建文本文件、VI的三种操作模式、磁盘分区与格式化、用户及用户组权限的相关操作与管理等，让童鞋们对Linux系统有进一步的理解，对Linux服务器的维护操作更加得心应手。初级·78875人在学 服务管理Linux网络管理 Linux装好以后是不能和网络中的其他机器进行通信的，本课程会为你解决Linux网络配置的问题。首先会介绍网络基础知识，然后进行IP地址的配置，并总结了在配置网络环境中经常遇到的问题，最后介绍了几种常用远程登录工具的使用，如XShell和SecureCRT。中级·66036人在学 Linux软件安装管理 软件安装对于操作系统来说是常用的操作，那如何在Linux中使用命令进行软件安装呢？本课程就带你来了解Linux中的软件如何进行安装、卸载、升级等管理。课程内容包括rpm命令管理、yum在线管理、源码包管理和脚本安装包。中级·45680人在学 Linux权限管理之基本权限 权限管理是Linux中一个十分重要的概念，也是系统安全性的重要保障。本门课程主要介绍Linux的基本权限和默认权限，通过理论讲解与实验演示，小伙们可以了解到权限的相关操作及其重要性。中级·25420人在学 Linux权限管理之特殊权限 本课程是《Linux权限管理之基本权限》的后续篇，为小伙伴们带来了Linux中常用的一些特殊权限命令，包括ACL权限、sudo权限、文件特殊权限和不可改变位权限。通过@Tony老师的精彩讲解，一定会让你对Linux中的权限有更深刻的认识。中级·21268人在学 Linux中的计划任务之Crontab Crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。本课程通过对Crontab的介绍以及案例演示，带领大家学习在实际工作中通过crontab进行计划任务设置，让重复的任务自动化执行，提高大家工作效率。高级·24453人在学 Linux服务管理 本课程主要对Linux的服务管理进行介绍，包括系统的运行级别、服务管理的分类、RPM包管理和源码包服务管理。本门课程对于Linux运维人员来说非常重要。同时，Linux服务的知识点经过Tony老师的梳理，定然会使小伙伴们受益匪浅。中级·28340人在学 Linux系统管理 本课程为小伙伴们介绍如何对Linux系统进行管理，包括进程管理、工作管理、系统资源查看和定时任务，每个部分讲师都进行了详细的讲解。相信通过本课程的学习，你的Linux技能会有进一步提升。中级·34391人在学 shell实战shell编程之变量 本课程是《Linux达人养成计划I》中第九章课程的延续，主要介绍Linuxshell编程基础中的变量。包括Bash变量的分类和各变量的详细使用，如：用户自定义变量、环境变量、语系变量、位置参数变量和预定义变量。中级·31345人在学 shell编程之运算符 本课程是《Tony老师聊shell——变量》课程的延续，主要介绍Linuxshell编程基础中的运算符。包括declare命令、数值运算方法和变量测试。首先在declare命令中介绍了数值型和数组类型的声明，然后介绍了运算符的详细使用，最后对不同场景下的变量进行了测试。中级·18973人在学 shell编程之环境变量配置文件 本课程是《Tony老师聊shell》系列课程的第三篇，为你带来常用的Linux环境变量配置文件的使用。对环境变量配置文件的功能进行了详解，然后又介绍了其他环境变量配置文件，包括注销时生效的环境变量配置文件、历史命令相关的环境变量配置文件、shell登录信息配置文件等。中级·19946人在学 shell编程之正则表达式 正则表达式在查找中的作用是非常重要的。本课程是《Tony老师聊shell》系列课程的第四篇，为你带来Linuxshell中的正则表达式，字符截取命令cut、printf、awk和sed,字符处理命令sort和wc。中级·23789人在学 shell编程之条件判断与流程控制 本门课程是《Tony老师聊shell》系列课程的最后一篇，多个典型案例贯穿整个课程。课程内容包括：条件判断式语句、单分支if语句、双分支if语句、多分支if语句、case语句、for循环、while循环和until循环等。学习完本门课程一定会使你的Linux运维能力再次提高。中级·20731人在学 Shell典型应用之主控脚本实现 《shell典型应用》系列主要使用shell脚本来实现企业中的常见应用，包括主控脚本实现、Linux系统信息及运行状态获取、ngnix和mysql应用状态分析、应用日志分析四个部分。本门课程主要介绍主控脚本实现，以及案例的一些准备工作。高级·24043人在学 Shell典型应用之系统信息及运行状态获取 本门课程是《shell典型应用》系列的第二门课程，主要分为两个部分，一是介绍如何提取内核版本、系统版本和网络地址等操作系统信息。二是介绍如何分析系统的运行状态，包括CPU负载、内存及磁盘使用率等。高级·15704人在学 Shell典型应用之nginx和mysql应用状态分析 本课程是《Shell典型应用》系列课程的第三门，主要介绍如何监控nginx和mysql的运行状态。包括对nginx服务器的响应状态和QPS等的并发响应参数进行分析，以及对mysql服务情况和主从响应状态的监控。高级·20106人在学 Shell典型应用之应用日志分析 本课程是《Shell典型应用》系列课程的最后一门，主要介绍如何应用shell脚本分析系统日志。包括Linux系统日志的分类和HTTP状态码的介绍，接着又通过分析HTTP状态码在不同区间请求条数的案例，来展示如何分析系统日志。高级·19961人在学 服务搭建Linux系统扫描技术及安全防范 安全在互联网的中越来越受到企业和boss们的重视，本课给大家介绍一些网络扫描的技术手段，其中包括主机扫描、路由扫描、批量服务扫描。同时我们也会了解什么是恶意扫描行为，在实际工作中如何合理设置利用基于Linux的内核参数或者利用相关的工具规避一些安全的隐患。中级·21572人在学 用iptables搭建一套强大的安全防护盾 在”黑与白“的新型互联网时代，不经意间你的站点就可能被一个买地瓜的小朋友标记上了“俺到此地一游！”。安全已经成了互联网、物联网革命时代必须关注并且掌握的一门技术。本课程围绕Linux的iptables为您从简到繁的介绍，如何用iptables守护好您家的前门和后院。高级·21273人在学 Linux智能DNS服务搭建之Bind服务 《Linux系统下智能DNS服务搭建》系列课程分为三部，分别为Bind服务篇、Bind负载均衡篇和智能DNS篇。本门课程作为系列课程的第一部，首先介绍了DNS的原理和应用，然后自动动手搭建Bind服务，并进行测试，最后还介绍了DNS正向解析工具的使用。高级·8133人在学 在UbuntuServer下搭建LAMP环境 本课程通过详细的细分教学，让你理解LAMP环境各个组件之间的关系与作用，并能掌握从无到有的在UbuntuServer操作系统下搭建LAMP环境、配置虚拟主机、数据库远程维护等常见的服务器搭建维护技能，为学习PHP铺平道路。中级·32768人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"求职","slug":"求职","permalink":"http://www.cheshen.wiki/tags/求职/"},{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/tags/Linux/"},{"name":"运维","slug":"运维","permalink":"http://www.cheshen.wiki/tags/运维/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Hibernate开发宝典","slug":"Hibernate开发宝典","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.268Z","comments":true,"path":"2017/04/15/Hibernate开发宝典/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Hibernate开发宝典/","excerpt":"本路线共：7门课程 学习人数：6746人在学 章节预览：Hibernate初探之单表映射Hibernate初探之一对多映射Hibernate初探之多对多映射HQL数据查询基础Hibernate缓存策略Hibernate注解使用Struts2+Hibernate开发学生信息管理功能","text":"本路线共：7门课程 学习人数：6746人在学 章节预览：Hibernate初探之单表映射Hibernate初探之一对多映射Hibernate初探之多对多映射HQL数据查询基础Hibernate缓存策略Hibernate注解使用Struts2+Hibernate开发学生信息管理功能 入门必备Hibernate初探之单表映射 Hibernate是一个著名的对象关系映射框架，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。本门课程是Hibernate的入门课程，主要介绍ORM和hibernate的概念，如何在eclipse中创建hibernate实例及相关配置文件的详解说明。高级·47401人在学 Hibernate初探之一对多映射 现实世界中的对象很少有孤立存在的，例如学生，往往与所在班级和授课老师之间存在关联关系。在本次课程中，@laurenyang将带领小伙伴们一起学习Hibernate中的关联映射——一对多映射，会依次向大家介绍单向一对多和单向多对一的配置，以及cascade和inverse属性的作用。高级·29170人在学 高手进阶Hibernate初探之多对多映射 多对多关联也是常见的一种关联关系，如项目和员工之间就是典型的多对多关系。在本次课程中，@laurenyany将与各位小伙伴们分享Hibernate中的关联映射——多对多映射，将向大家依次介绍多对多的概念、应用场景以及在Eclipse中的配置实现。高级·16470人在学 HQL数据查询基础 本次课程是Hibernate的进阶课程，将帮助小伙伴们，在掌握了使用Hibernate进行数据表管理之后，进一步认识什么是HQL，HQL常用的语句格式以及在Hibernate框架中如何执行HQL查询获取我们需要的数据。高级·28945人在学 Hibernate缓存策略 Hibernate是目前最老牌和主流的JavaORM框架，而缓存是ORM框架中的一个重难点，是数据库访问性能优化的重要手段，本课程主要介绍Hibernate中缓存的原理、分类和使用。高级·19741人在学 Hibernate注解 注解在Java程序开发中的应用越来越广泛，可以有效地提高代码的简洁度。本门课程主要介绍Hibernate的常用注解，包括类级别注解、属性级别注解和关联映射注解。希望小伙伴们学习完本门课程后，能够灵活应用Hibernate注解进行开发。高级·21953人在学 实战演练使用Struts2+Hibernate开发学生信息管理功能 本课程通过学生信息管理功能的开发，来介绍Struts2和Hibernate的整合。主要内容包括：Struts2和Hibernate整合，用户登录模块和学生信息管理模块的设计和实现。通过本课程的学习，一定会使小伙伴们的JavaWeb开发技能更上一层楼。高级·56204人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Hibernate开发","slug":"Hibernate开发","permalink":"http://www.cheshen.wiki/tags/Hibernate开发/"},{"name":"加薪利器","slug":"加薪利器","permalink":"http://www.cheshen.wiki/tags/加薪利器/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://www.cheshen.wiki/tags/JavaWeb/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Oracle数据库开发必备利器","slug":"Oracle数据库开发必备利器","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.290Z","comments":true,"path":"2017/04/15/Oracle数据库开发必备利器/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Oracle数据库开发必备利器/","excerpt":"本路线共：6门课程 学习人数：10247人在学 章节预览：Oracle数据库开发必备利器之SQL基础Oracle数据库开发利器之函数Oracle高级查询Oracle数据库开发必备利器之PL/SQL基础Oracle存储过程和自定义函数Oracle触发器","text":"本路线共：6门课程 学习人数：10247人在学 章节预览：Oracle数据库开发必备利器之SQL基础Oracle数据库开发利器之函数Oracle高级查询Oracle数据库开发必备利器之PL/SQL基础Oracle存储过程和自定义函数Oracle触发器 入门——SQL基础Oracle数据库开发必备利器之SQL基础 OracleDatabase，又名OracleRDBMS，或简称Oracle，是甲骨文公司的一款关系数据库管理系统。本课程主要介绍Oracle的SQL基础，包括表空间的概念，如何登录Oracle数据库，如何管理表及表中的数据，以及约束的应用。为后续课程的学习打下一个良好的基础。初级·86561人在学 Oracle数据库开发利器之函数 Oracle中的函数主要为了方便数据的统计以及处理查询结果。本课程主要介绍Oracle中的常用函数，包括数值函数、字符函数、日期函数和转换函数，并且介绍了这些函数如何在查询中应用。中级·18023人在学 Oracle高级查询 高级查询在数据库的开发过程中应用广泛，本课程通过大量的案例和@collen7788老师的详细讲解，从分组查询、多表查询和子查询三个方面介绍Oracle的高级查询，最后为大家安排了典型案例的应用和练习题。中级·29797人在学 成长——数据库开发Oracle数据库开发必备利器之PL/SQL基础 PL/SQL是Oracle数据库对SQL语句的扩展，是存储过程和自定义函数的高级内容学习的必备基础。本门课程为大家带来PL/SQL的基本语法、光标和例外的概念，并通过案例演示了PL/SQL开发的过程。中级·37499人在学 Oracle存储过程和自定义函数 本门课程是Java开发Oracle数据库的一门十分重要的课程。本门课程首先介绍了Oracle的存储过程和存储函数（自定义函数）的创建和调用，之后讲师又通过案例介绍了存储过程和存储函数在Java项目中的应用，以及如何在应用程序中访问包下的存储过程。中级·26468人在学 Oracle触发器 触发器是在事件发生时隐式地自动运行的PL/SQL程序块，不能接收参数，不能被调用。本课程是《Oracle数据库开发必备利器》的最后一门课程，课程介绍了触发器的基本概念、应用场景和语法，并通过四个案例介绍了触发器在项目中的应用。中级·18832人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://www.cheshen.wiki/tags/Oracle/"},{"name":"数据库开发","slug":"数据库开发","permalink":"http://www.cheshen.wiki/tags/数据库开发/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"PHP工程师","slug":"PHP工程师","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.292Z","comments":true,"path":"2017/04/15/PHP工程师/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/PHP工程师/","excerpt":"本路线共：27门课程 学习人数：60046人在学 章节预览：HTML+CSS基础课程JavaScript入门篇JavaScript进阶篇Linux达人养成计划IPHP入门篇与MySQL的零距离接触PHP与MySQL关系大揭秘Duang~MySQLi扩展库来袭PDO—数据库抽象层PHP进阶篇GD库实现图片水印与缩略图PHP实现验证码制作PHP实现文件上传与下载jQuery基础(一)—样式篇jQuery基础(二)—DOM篇jQuery基础(三)—事件篇jQuery基础(四)—动画篇手把手教你实现电商网站开发手把手教你实现电商网站后台开发MVC架构模式分析与设计快速入门ThinkPHP框架—理论篇与《Yii框架》不得不说的故事—基础篇与《Yii框架》不得不说的故事—高效篇与《Yii框架》不得不说的故事—安全篇与《Yii框架》不得不说的故事—扩展篇与《Yii框架》不得不说的故事—工具篇从零开始打造自己的PHP框架","text":"本路线共：27门课程 学习人数：60046人在学 章节预览：HTML+CSS基础课程JavaScript入门篇JavaScript进阶篇Linux达人养成计划IPHP入门篇与MySQL的零距离接触PHP与MySQL关系大揭秘Duang~MySQLi扩展库来袭PDO—数据库抽象层PHP进阶篇GD库实现图片水印与缩略图PHP实现验证码制作PHP实现文件上传与下载jQuery基础(一)—样式篇jQuery基础(二)—DOM篇jQuery基础(三)—事件篇jQuery基础(四)—动画篇手把手教你实现电商网站开发手把手教你实现电商网站后台开发MVC架构模式分析与设计快速入门ThinkPHP框架—理论篇与《Yii框架》不得不说的故事—基础篇与《Yii框架》不得不说的故事—高效篇与《Yii框架》不得不说的故事—安全篇与《Yii框架》不得不说的故事—扩展篇与《Yii框架》不得不说的故事—工具篇从零开始打造自己的PHP框架 PHP基础HTML+CSS基础课程 本课程从最基本的概念开始讲起，步步深入，带领大家学习HTML、CSS样式基础知识，了解各种常用标签的意义以及基本用法，后半部分讲解CSS样式代码添加，为后面的案例课程打下基础。初级·676735人在学 JavaScript入门篇 本视频教程让您快速认识JavaScript，熟悉JavaScript基本语法、窗口交互方法和通过DOM进行网页元素的操作，学会如何编写JS代码，如何运用JavaScript去操作HTML元素和CSS样式，本JavaScript教程分为四个章节，能够让您快速入门，为JavaScript深入学习打下基础。初级·444787人在学 JavaScript进阶篇 做为WEB攻城师必备技术JavaScript，本课程从如何插入JS代码开始，学习JS基础语法、语法、函数、方法等，让你掌握JS编程思路、知识的使用等，实现运用JS语言为网页增加动态效果，达到与用户交互的目的。中级·283624人在学 Linux达人养成计划I 本课程以通俗易懂的语言、风趣幽默的实例、清晰严谨的逻辑介绍了Linux的基础内容。课程以CentOS操作系统为例，为你带来Linux的简介、系统安装和常用命令等内容。让您在轻松的氛围中感受到Linux之美。初级·225890人在学 PHP入门篇 轻松学习PHP基础知识，了解PHP中的变量、变量的类型、常量等概念，认识PHP中的运算符，掌握PHP中顺序结构、条件结构、循环结构三种语言结构语句。初级·306364人在学 数据库操作与MySQL的零距离接触 本课程涵盖全部MySQL数据库的基础，主要学习MySQL数据库的基础知识、数据表的常用操作及各种约束的使用，以及综合的运用各种命令实现记录进行CURD等操作，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。初级·219607人在学 PHP与MySQL关系大揭秘 你听说过php吗？你听说过mysql吗？他俩结合几十年了你知道了吗？让我们一起走上探秘之旅，找寻php和mysql恋爱的真谛。GO！GO！GO！中级·57023人在学 Duang~MySQLi扩展库来袭 本课程从面向对象和面向过程两个方面，讲解了MySQLi的具体使用和注意事项，最后通过无刷新评论系统的实战演练，详细剖析实际开发中如何使用MySQLi完成对数据库的操作。中级·21515人在学 PDO—数据库抽象层 PDO扩展为PHP访问数据库定义了一个轻量级的、一致性的接口，PDO解决了数据库连接不统一的问题，本课程以MySQL数据库为例，讲解了PDO的安装和配置方法，以及操作数据的函数，此外还介绍了PDO的事务处理相关知识，最后通过实战演练深入剖析PDO以加深理解。中级·22931人在学 项目实战PHP进阶篇 通过PHP学习的进阶篇的学习，你可以对PHP的理论知识由浅入深有更深一步的掌握，这些知识能够使您更加全面的掌握PHP，从而助您在实际工作中使用PHP快速开发网站程序。中级·124711人在学 GD库实现图片水印与缩略图 本课程将带领大家通过PHP中的GD库巧妙的实现图片水印与缩略图功能，大家可以轻松掌握案例的实现思路，同时课程中也讲解了如何将此过程封装成类，可以进一步加深对面向对象的理解。中级·16028人在学 PHP实现验证码制作 通过分析验证码实现原理，以基础的文字+字母验证码，分析讲解实现方法。并举一反三的讲解如何实现中文、图片、视频验证码。其中会穿插讲解实现过程中可能出现的技术难点、隐患。中级·29260人在学 PHP实现文件上传与下载 本课程讲解了文件上传的原理和配置，并带领大家使用面向对象和面向过程两种方式，完成了对单文件和多文件上传的处理，以及文件下载功能的实现，通过本课程的学习，能够掌握对文件上传和下载的处理办法，并加深对类与面向对象的封装的理解。中级·32089人在学 jQuery基础(一)—样式篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第一个部分—样式篇，本课程主要介绍jQuery的基础语法，选择器以及jQuery的一些属性和样式，通过本课程的学习，我们可以用最少的代码做更多的事，让我们一起出发学习吧！初级·108678人在学 jQuery基础(二)—DOM篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第二个部分—DOM篇。本课程主要讲解jQuery中节点的创建、插入、删除与替换，除此之外我们还可以了解到jQuery中丰富的遍历节点的方法。初级·65840人在学 jQuery基础(三)—事件篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第三个部分—事件篇。此部分当中包含了，鼠标事件，表单事件，键盘事件，事件的绑定和解绑以及自定义事件。通过本课程的事件，我们能更快速的对页面进行交互的操作。初级·48560人在学 jQuery基础(四)—动画篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为最后一个部分—动画篇。通过本课程的学习，我们可以制作出以下效果：隐藏和显示、上卷下来、淡入淡出。我们也可以通过自定义动画去完成一些我们想要的效果。初级·49275人在学 手把手教你实现电商网站开发 本课程主要介绍电商网站基本制作流程，通过电商网站分步的教学让大家了解和掌握电商网站制作的流程和注意事项。并且运用网站内学习过的知识点，更加快速的掌握整站的开发过程，增加开发经验。中级·119511人在学 手把手教你实现电商网站后台开发 本系统从慕课网电子商务系统的需求分析、数据表设计入手，从后台搭建，到后台模块实现，由浅入深教你如何搭建电子商务系统，包括前台数据的显示并详细讲解了电商系统开发流程以及开发过程中会遇到的问题及如何解决。中级·87328人在学 框架开发MVC架构模式分析与设计 本课程前部分通过学习MVC理论知识，引入MVC设计简单的框架的方法，并带领学生掌握对框架MVC三层框架简化的方法。后半部分通过视图层的介绍引入smarty的概念，详细介绍smarty的语法，通过实例再次加深对smarty的理解，并演示smarty各个内置函数与php、自定义函数的用法。中级·59874人在学 快速入门ThinkPHP框架—理论篇 通过对ThinkPHP框架基础知识的讲解，带领大家由浅入深轻松掌握ThinkPHP的理论基础，更加全面的掌握ThinkPHP框架运行机制，帮助大家在实际工作中使用ThinkPHP框架实现快速开发。高级·66695人在学 与《Yii框架》不得不说的故事—基础篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习YII的安装和mvc的基本使用方式，为后面学习YII的快速、安全、专业的特性打下基础。高级·29705人在学 与《Yii框架》不得不说的故事—高效篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习YII如何提升程序运行效率以及开发效率。高级·16940人在学 与《Yii框架》不得不说的故事—安全篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习XSS、CSRF、SQL注入、文件上传漏洞等攻击方式，以及YII框架对它们的防范和处理方式。高级·13109人在学 与《Yii框架》不得不说的故事—扩展篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习模块、事件机制、mixin以及依赖注入技术，可以让程序拥有更好的扩展性，更能够适应需求的变化。高级·12010人在学 与《Yii框架》不得不说的故事—工具篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习在开发项目中常用的一些工具，主要包括Composer、Debug和GII等，使用这些工具可以大大提高了我们的开发效率。高级·15849人在学 从零开始打造自己的PHP框架 你觉得Thinkphp框架很不错？Laravel很优雅？Yii很稳定？CI很高效？哼哼，其实你自己开发的才是最最好用最最适合你的框架中级·26697人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"求职","slug":"求职","permalink":"http://www.cheshen.wiki/tags/求职/"},{"name":"实战","slug":"实战","permalink":"http://www.cheshen.wiki/tags/实战/"},{"name":"PHP","slug":"PHP","permalink":"http://www.cheshen.wiki/tags/PHP/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"PHP微信公众平台开发攻略","slug":"PHP微信公众平台开发攻略","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.295Z","comments":true,"path":"2017/04/15/PHP微信公众平台开发攻略/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/PHP微信公众平台开发攻略/","excerpt":"本路线共：8门课程 学习人数：9528人在学 章节预览：PHP实现微信公众平台开发—基础篇PHP实现微信公众平台开发—提升篇PHP微信公众平台开发高级篇—生成二维码接口PHP微信公众平台开发高级篇—模板消息接口PHP微信公众平台开发高级篇—群发接口PHP微信公众平台开发高级篇—自定义菜单PHP微信公众平台开发高级篇—微信JS-SDKPHP微信公众平台开发高级篇—网页授权接口","text":"本路线共：8门课程 学习人数：9528人在学 章节预览：PHP实现微信公众平台开发—基础篇PHP实现微信公众平台开发—提升篇PHP微信公众平台开发高级篇—生成二维码接口PHP微信公众平台开发高级篇—模板消息接口PHP微信公众平台开发高级篇—群发接口PHP微信公众平台开发高级篇—自定义菜单PHP微信公众平台开发高级篇—微信JS-SDKPHP微信公众平台开发高级篇—网页授权接口 初识微信公众平台PHP实现微信公众平台开发—基础篇 本课程作为学习微信开发的基础课程，详细介绍了微信开发的准备条件，以及如何申请一个微信公众账号，并在项目应用中如何成功接入微信开发的api接口，课程由浅入深，内容详实，非常适合新手学习。中级·74010人在学 深入微信公众平台PHP实现微信公众平台开发—提升篇 本课程详细讲解了如何接收微信用户发送的消息和接收订阅关注的事件推送，以及发送各种类型的消息给微信用户，并深入剖析了access_token在微信中的使用技巧，最后展示了第三方接口与微信深度结合的应用示例。中级·47951人在学 攻克微信公众平台PHP微信公众平台开发高级篇—生成二维码接口 二维码接口可以带给用户方便又快捷的体验！本课程主要讲解二维码接口的实现，以及二维码事件推送功能的实现。高级·18160人在学 PHP微信公众平台开发高级篇—模板消息接口 模板消息仅用于公众号向用户发送重要的服务通知，只能用于符合其要求的服务场景中，如信用卡刷卡通知，商品购买成功通知等。高级·13861人在学 PHP微信公众平台开发高级篇—群发接口 对于某些具备开发能力的公众号运营者，可以通过高级群发接口，实现更灵活的群发能力。高级·11533人在学 PHP微信公众平台开发高级篇—自定义菜单 自定义菜单是微信开发中必不可少的环节，掌握好自定义菜单可以让你的公众号与微信用户之间实现更便捷的交互。高级·18912人在学 PHP微信公众平台开发高级篇—微信JS-SDK 通过使用微信JS-SDK，网页开发者可借助微信高效地使用拍照、选图、语音、位置等手机系统的能力，为微信用户提供更优质的网页体验。高级·19128人在学 PHP微信公众平台开发高级篇—网页授权接口 在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。高级·15844人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.cheshen.wiki/tags/PHP/"},{"name":"微信公众号","slug":"微信公众号","permalink":"http://www.cheshen.wiki/tags/微信公众号/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"高德开发者必由之路——AndroidSDK篇","slug":"高德开发者必由之路——Android SDK篇","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.356Z","comments":true,"path":"2017/04/15/高德开发者必由之路——Android SDK篇/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/高德开发者必由之路——Android SDK篇/","excerpt":"本路线共：12门课程 学习人数：4179人在学 章节预览：Java入门第一季Java入门第二季Java入门第三季Java实现Base64加密深入浅出Java多线程反射——Java高级开发必须懂的Android攻城狮的第一门课（入门篇）与AndroidStudio的第一次亲密接触Android攻城狮的第二门课（第3季）AndroidUI模板设计Android面试常客Handler详解如何使用高德AndroidSDK进行LBS的开发","text":"本路线共：12门课程 学习人数：4179人在学 章节预览：Java入门第一季Java入门第二季Java入门第三季Java实现Base64加密深入浅出Java多线程反射——Java高级开发必须懂的Android攻城狮的第一门课（入门篇）与AndroidStudio的第一次亲密接触Android攻城狮的第二门课（第3季）AndroidUI模板设计Android面试常客Handler详解如何使用高德AndroidSDK进行LBS的开发 熟悉语言基础Java入门第一季 欢迎来到精彩的Java编程世界！Java语言已经成为当前软件开发行业中主流的开发语言。本课程将介绍Java环境搭建、工具使用、基础语法。带领大家一步一步的踏入Java达人殿堂！Let’sgo!初级·601606人在学 Java入门第二季 本课程是程序猿质变课程，理解面向对象的思想，掌握面向对象的基本原则以及Java面向对象编程基本实现原理，熟练使用封装、继承、多态面向对象三大特性，带你进一步探索Java世界的奥秘！初级·288694人在学 Java入门第三季 在本课程中，@陈码农携手@laurenyany将带领小伙伴们进一步探索Java的奥秘，希望通过本次课程的学习，能够帮助小伙伴们快速掌握关于Java中的异常处理、集合框架、字符串的操作和常用类的使用。不容错过的精彩，快来加入吧！！初级·224060人在学 Java工具箱Java实现Base64加密 本门课程是Java加解密系列的第一门课，旨在为大家介绍Java加密解密的基础知识，并使用Base64算法实现加解密。本门课程在整个加解密系列中十分重要，是Java加解密必备的入门基础。中级·24444人在学 深入浅出Java多线程 多线程是日常开发中的常用知识，也是难用知识。通过本视频，你可以了解Java中多线程相关的基本概念，如何创建，启动和停止线程？什么是正确的多线程，怎样编写多线程程序。在掌握基础之后，将为你展望进阶路线，为进一步的学习提供方向。中级·102847人在学 反射——Java高级开发必须懂的 反射是Java开发中一个非常重要的概念，掌握了反射的知识，才能更好的学习Java高级课程，因此必须要学习——你懂的！本门课程主要介绍Class类的使用，方法和成员变量的反射，以及通过反射了解集合泛型的本质等知识。中级·84465人在学 了解Android开发Android攻城狮的第一门课（入门篇） 本课程涵盖全部Android应用开发的基础，根据技能点的作用分为5个篇章，包括环境篇、控件篇、布局篇、组件篇和通用篇，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。初级·241158人在学 与AndroidStudio的第一次亲密接触 AndroidStudio是Google在I/O大会上发布的一个新的集成开发环境，可以让Android开发变的更简单。本课程会详细的向您介绍AndroidStudio的安装配置、使用技巧以及相对于Eclipse开发的优势，并通过实际的操作让大家快速熟悉AndroidStudio的使用，让您体验更强大的开发工具初级·82319人在学 准备剖析高德地图AndroidSDKAndroid攻城狮的第二门课（第3季） 本课程深入的讲解了Android中的手势识别原理、数据存储方式、对组件的详细剖析以及对Service的深度讲解，每一个知识点都对应有实际案例。本课程内容不仅使您牢牢掌握之前的基础知识点，学完之后也会有新的收获、新的体会。初级·62568人在学 AndroidUI模板设计 UI设计一直是程序设计中非常重要的一环，也是最让人抓狂的一环，好的设计需要不断修改、不断完善，那么我们如何才能减少UI设计中的重复劳动呢、如何在修改设计时减少工作量呢、如何一次开发，重复使用呢？如果你也有这样的疑问，那么本次课程一定会让你获益匪浅。中级·58834人在学 Android面试常客Handler详解 本课程将深入理解Android的Handler机制，并结合源码实例，讲解Looper、MessageqQueue、Handler之间的关系，同时介绍HandlerThread的原理和使用，并分析Handler在开发中遇到的异常的原因，最后从源码的角度分析一下Handler更新UI的流程高级·44265人在学 变身高德开发者如何使用高德AndroidSDK进行LBS的开发 本课程为大家带来如何使用AndroidSDK进行基于LBS的开发。高德地图AndroidSDK版是一套地图开发调用接口，供开发者在自己的应用中加入地图相关的功能。你可以轻松地开发出地图显示与操作、兴趣点搜索、地理编码等功能。通过本课程的学习你可以动手实现你的第一个地图应用！初级·13620人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"地图开发","slug":"地图开发","permalink":"http://www.cheshen.wiki/tags/地图开发/"},{"name":"定位检索","slug":"定位检索","permalink":"http://www.cheshen.wiki/tags/定位检索/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"PHP开发工程师闯关记--初识PHP","slug":"PHP开发工程师闯关记--初识PHP","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.293Z","comments":true,"path":"2017/04/15/PHP开发工程师闯关记--初识PHP/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/PHP开发工程师闯关记--初识PHP/","excerpt":"本路线共：10门课程 学习人数：36889人在学 章节预览：PHP入门篇PHP进阶篇HTML+CSS基础课程WEB在线文件管理器PHP与MySQL关系大揭秘PHP实现验证码制作PHP面向对象编程JSON应用场景与实战手把手教你实现电商网站后台开发MVC架构模式分析与设计","text":"本路线共：10门课程 学习人数：36889人在学 章节预览：PHP入门篇PHP进阶篇HTML+CSS基础课程WEB在线文件管理器PHP与MySQL关系大揭秘PHP实现验证码制作PHP面向对象编程JSON应用场景与实战手把手教你实现电商网站后台开发MVC架构模式分析与设计 第一关PHP基础入门PHP入门篇 轻松学习PHP基础知识，了解PHP中的变量、变量的类型、常量等概念，认识PHP中的运算符，掌握PHP中顺序结构、条件结构、循环结构三种语言结构语句。初级·306364人在学 PHP进阶篇 通过PHP学习的进阶篇的学习，你可以对PHP的理论知识由浅入深有更深一步的掌握，这些知识能够使您更加全面的掌握PHP，从而助您在实际工作中使用PHP快速开发网站程序。中级·124711人在学 HTML+CSS基础课程 本课程从最基本的概念开始讲起，步步深入，带领大家学习HTML、CSS样式基础知识，了解各种常用标签的意义以及基本用法，后半部分讲解CSS样式代码添加，为后面的案例课程打下基础。初级·676735人在学 第二关PHP基础应用WEB在线文件管理器 作为嗷嗷待补的程序猿，我们在不断觅食，不断接收和掌握新技能和新知识，而作为PHP开发中我们必不可少的一项就是文件目录函数库。通过本课程文件目录函数库的学习，可以把他应用到我们真实项目中实现对项目文件目录的管理，如果你具备前端的技能，可以把它变得更绚丽多彩！中级·27662人在学 PHP与MySQL关系大揭秘 你听说过php吗？你听说过mysql吗？他俩结合几十年了你知道了吗？让我们一起走上探秘之旅，找寻php和mysql恋爱的真谛。GO！GO！GO！中级·57023人在学 PHP实现验证码制作 通过分析验证码实现原理，以基础的文字+字母验证码，分析讲解实现方法。并举一反三的讲解如何实现中文、图片、视频验证码。其中会穿插讲解实现过程中可能出现的技术难点、隐患。中级·29260人在学 PHP面向对象编程 本课程通过讲述面向对象的基本概念以及相关的案例实践，让小伙伴们对面向对象有一个基本的认识，能够掌握把实际问题抽象成为类对象用以解决实际问题的方法，掌握面向对象的最重要的核心能力。中级·51131人在学 第三关PHP应用进阶JSON应用场景与实战 现今Json数据以短小、读取方便等优点，越来越受广大开发人员喜欢。本课分为两部分，前半部分详细介绍JSON的基础知识，后半部分通过两个实站案例再次加深对Json的理解，并演示Json在各个实际场景的用法。中级·54480人在学 手把手教你实现电商网站后台开发 本系统从慕课网电子商务系统的需求分析、数据表设计入手，从后台搭建，到后台模块实现，由浅入深教你如何搭建电子商务系统，包括前台数据的显示并详细讲解了电商系统开发流程以及开发过程中会遇到的问题及如何解决。中级·87328人在学 MVC架构模式分析与设计 本课程前部分通过学习MVC理论知识，引入MVC设计简单的框架的方法，并带领学生掌握对框架MVC三层框架简化的方法。后半部分通过视图层的介绍引入smarty的概念，详细介绍smarty的语法，通过实例再次加深对smarty的理解，并演示smarty各个内置函数与php、自定义函数的用法。中级·59874人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"网站后端","slug":"网站后端","permalink":"http://www.cheshen.wiki/tags/网站后端/"},{"name":"小白入门","slug":"小白入门","permalink":"http://www.cheshen.wiki/tags/小白入门/"},{"name":"从基础到实战","slug":"从基础到实战","permalink":"http://www.cheshen.wiki/tags/从基础到实战/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"电商网站全站开发攻略","slug":"电商网站全站开发攻略","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.349Z","comments":true,"path":"2017/04/15/电商网站全站开发攻略/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/电商网站全站开发攻略/","excerpt":"本路线共：8门课程 学习人数：26566人在学 章节预览：PHP入门篇HTML+CSS基础课程JavaScript入门篇与MySQL的零距离接触PHP进阶篇PHP与MySQL关系大揭秘手把手教你实现电商网站开发手把手教你实现电商网站后台开发","text":"本路线共：8门课程 学习人数：26566人在学 章节预览：PHP入门篇HTML+CSS基础课程JavaScript入门篇与MySQL的零距离接触PHP进阶篇PHP与MySQL关系大揭秘手把手教你实现电商网站开发手把手教你实现电商网站后台开发 时刻准备着PHP入门篇 轻松学习PHP基础知识，了解PHP中的变量、变量的类型、常量等概念，认识PHP中的运算符，掌握PHP中顺序结构、条件结构、循环结构三种语言结构语句。初级·306364人在学 HTML+CSS基础课程 本课程从最基本的概念开始讲起，步步深入，带领大家学习HTML、CSS样式基础知识，了解各种常用标签的意义以及基本用法，后半部分讲解CSS样式代码添加，为后面的案例课程打下基础。初级·676735人在学 JavaScript入门篇 本视频教程让您快速认识JavaScript，熟悉JavaScript基本语法、窗口交互方法和通过DOM进行网页元素的操作，学会如何编写JS代码，如何运用JavaScript去操作HTML元素和CSS样式，本JavaScript教程分为四个章节，能够让您快速入门，为JavaScript深入学习打下基础。初级·444787人在学 打通业务逻辑与数据与MySQL的零距离接触 本课程涵盖全部MySQL数据库的基础，主要学习MySQL数据库的基础知识、数据表的常用操作及各种约束的使用，以及综合的运用各种命令实现记录进行CURD等操作，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。初级·219607人在学 PHP进阶篇 通过PHP学习的进阶篇的学习，你可以对PHP的理论知识由浅入深有更深一步的掌握，这些知识能够使您更加全面的掌握PHP，从而助您在实际工作中使用PHP快速开发网站程序。中级·124711人在学 PHP与MySQL关系大揭秘 你听说过php吗？你听说过mysql吗？他俩结合几十年了你知道了吗？让我们一起走上探秘之旅，找寻php和mysql恋爱的真谛。GO！GO！GO！中级·57023人在学 动起来手把手教你实现电商网站开发 本课程主要介绍电商网站基本制作流程，通过电商网站分步的教学让大家了解和掌握电商网站制作的流程和注意事项。并且运用网站内学习过的知识点，更加快速的掌握整站的开发过程，增加开发经验。中级·119511人在学 手把手教你实现电商网站后台开发 本系统从慕课网电子商务系统的需求分析、数据表设计入手，从后台搭建，到后台模块实现，由浅入深教你如何搭建电子商务系统，包括前台数据的显示并详细讲解了电商系统开发流程以及开发过程中会遇到的问题及如何解决。中级·87328人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"电商全站","slug":"电商全站","permalink":"http://www.cheshen.wiki/tags/电商全站/"},{"name":"菜鸟进阶","slug":"菜鸟进阶","permalink":"http://www.cheshen.wiki/tags/菜鸟进阶/"},{"name":"细致全面","slug":"细致全面","permalink":"http://www.cheshen.wiki/tags/细致全面/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"玩嗨Python进阶","slug":"玩嗨Python进阶","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.347Z","comments":true,"path":"2017/04/15/玩嗨Python进阶/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/玩嗨Python进阶/","excerpt":"本路线共：3门课程 学习人数：5312人在学 章节预览：Python文件处理Python错误和异常python正则表达式","text":"本路线共：3门课程 学习人数：5312人在学 章节预览：Python文件处理Python错误和异常python正则表达式 文件处理Python文件处理 任何语言都离不开对文件的操作，Python语言是如何来操作和管理文件的。今天就让我们带您走入文件的世界，一起创建文件，一起读写文件，一起管理我们的文件。掌握文件的基本概念、基本操作，了解文件属性、linux系统的文件管理机制及os模块对文件和目录的处理等相关内容。中级·44369人在学 错误和异常Python错误和异常 在我们代码编译和执行过程中，总会遇到语法、逻辑和算法错误，导致程序无法继续编译和执行；尤其在程序执行过程中某些错误并不是致命的，我们可以使用某种方式来处理这种错误，使我们代码更加健壮；让我们一起来学习Python对于错误和异常的处理方式。中级·19969人在学 正则表达式python正则表达式 正则表达式可以提高复杂文本分析的效率，本课程介绍了Python正则表达式基本概念、为什么使用正则表达式、正则语法、re模块及相关方法使用，如何使用正则表达式处理文件，让您对python正则全面了解。中级·37738人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"求职加薪","slug":"求职加薪","permalink":"http://www.cheshen.wiki/tags/求职加薪/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"模式宗师养成宝典之Java版","slug":"模式宗师养成宝典之Java版","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.346Z","comments":true,"path":"2017/04/15/模式宗师养成宝典之Java版/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/模式宗师养成宝典之Java版/","excerpt":"本路线共：8门课程 学习人数：14891人在学 章节预览：模式的秘密—单例模式模式的秘密——工厂模式模式的秘密—代理模式模式的秘密—适配器模式观察者模式模式的秘密—责任链模式模式的秘密–策略模式模式的秘密—模板方法模式","text":"本路线共：8门课程 学习人数：14891人在学 章节预览：模式的秘密—单例模式模式的秘密——工厂模式模式的秘密—代理模式模式的秘密—适配器模式观察者模式模式的秘密—责任链模式模式的秘密–策略模式模式的秘密—模板方法模式 创建型模式模式的秘密—单例模式 设计模式是前辈们在多年开发工作中经验的总结，可以提高代码的可重用性、可靠性和规范性，让代码更容易理解，而单例模式是在Java中最重要、最简单、最常用的设计模式之一，让我们一起来揭开它的神秘面纱吧。高级·44009人在学 模式的秘密——工厂模式 工厂模式和抽象工厂模式是在日常开发中使用非常广泛的设计模式。主要用于实现将对象的实例化部分取出来，进而优化系统架构，增强系统的扩展性。本课程即将讲解Java中的工厂模式和抽象工厂模式的应用。中级·37827人在学 结构型模式模式的秘密—代理模式 代理模式是一种非常重要的设计模式，在Java语言中有着广泛的应用，包括SpringAOP的核心设计思想，都和代理模式有密切关系。什么场景使用代理模式？代理模式实现原理是什么？本节课程将带你领略代理模式的奥妙。高级·31159人在学 模式的秘密—适配器模式 所谓适配器，就是连接“源”和“目标”的纽带。本课程由生活中常见的例子入手，深入浅出的讲解适配器模式的含义以及该模式的角色关系，讲解在适配器模式中如何通过“组合”和“继承”实现代码重用，为你的Java达人锻造添砖加瓦~~高级·22169人在学 行为型模式观察者模式 本课程通过一个天气预报的发布和订阅案例，来讲解观察者模式在Java项目中的应用。主要包括观察者模式的结构，观察者模式的两种实现方式推模型和拉模型，以及何时使用观察者模式等内容。高级·35349人在学 模式的秘密—责任链模式 责任链模式在我们日常开发工作中随处可见，但却并不一定唯你所熟知。通过本视频，你可以了解什么是责任链模式，如何用Java语言实现策略模式。作者将用简单生动的例子带你认识责任链模式的，通过学习，理解模式学习的要义。高级·17750人在学 模式的秘密–策略模式 策略模式是在日常开发中使用最为广泛的设计模式之一。在本视频中，@Arthur将用简单生动的例子带你领略策略模式的真意、如何用Java语言实现策略模式、最后还将用实际的行业案例告诉你策略模式的强大功能。小伙伴们，还等什么呢，快来加入学习吧！！高级·19802人在学 模式的秘密—模板方法模式 模板方法模式是在日常开发中使用最为广泛的设计模式之一。通过本视频，你可以了解什么是模板方法模式，如何用Java语言实现模板方法模式。@Arthur将用简单生动的例子带你领略模板方法模式的真意，最后还将用实际的行业案例告诉你模板方法模式的强大功能。高级·20571人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"加薪利器","slug":"加薪利器","permalink":"http://www.cheshen.wiki/tags/加薪利器/"},{"name":"java","slug":"java","permalink":"http://www.cheshen.wiki/tags/java/"},{"name":"模式认知","slug":"模式认知","permalink":"http://www.cheshen.wiki/tags/模式认知/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"教你HTML5开发爱心鱼游戏","slug":"教你HTML5开发爱心鱼游戏","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.344Z","comments":true,"path":"2017/04/15/教你HTML5开发爱心鱼游戏/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/教你HTML5开发爱心鱼游戏/","excerpt":"本路线共：4门课程 学习人数：16325人在学 章节预览：JavaScript深入浅出Canvas绘图详解HTML5小游戏—爱心鱼（上）HTML5小游戏—爱心鱼（下）","text":"本路线共：4门课程 学习人数：16325人在学 章节预览：JavaScript深入浅出Canvas绘图详解HTML5小游戏—爱心鱼（上）HTML5小游戏—爱心鱼（下） 打好基础JavaScript深入浅出 这是一个帮助您系统学习JavaScript编程语言的课程，该课由浅入深的介绍JavaScript的语言特性，结合实际例子解析常见误区，启发你的思考，帮助学习者从入门到掌握，提升您的JavaScript技能。高级·169230人在学 Canvas开发基础Canvas绘图详解 本课程为Canvas系列课程第二课。通过对《绚丽的倒计时效果的学习》，在大家对Canvas绘图有一定了解的基础上，本课程对Canvas的各个图形接口进行了系统详细地介绍，并辅以示例，让同学彻底掌握Canvas绘图，随心所欲在浏览器上绘制炫丽效果！高级·48477人在学 大显身手HTML5小游戏—爱心鱼（上） 这款html5“爱心鱼”游戏适合刚入手游戏开发的同学，或是想学习html5API的同学。本课程将带领你学习主要的html5API，通过一个清新美好的小游戏，帮助你熟悉游戏开发流程。课程分两部分，第一部分完成游戏核心，第二部分完善游戏内容。中级·62633人在学 HTML5小游戏—爱心鱼（下） html5游戏适合刚入手游戏开发的同学，或是想学习html5API的同学。本课程将带领你学习主要的html5API，通过一个清新美好的小游戏，熟悉游戏开发流程。课程分两部分，第一部分完成游戏核心，第二部分完善游戏内容。中级·32303人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"游戏开发","slug":"游戏开发","permalink":"http://www.cheshen.wiki/tags/游戏开发/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.cheshen.wiki/tags/HTML5/"},{"name":"Canvas","slug":"Canvas","permalink":"http://www.cheshen.wiki/tags/Canvas/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"SSH框架探幽","slug":"SSH框架探幽","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.300Z","comments":true,"path":"2017/04/15/SSH框架探幽/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/SSH框架探幽/","excerpt":"本路线共：11门课程 学习人数：4755人在学 章节预览：Spring入门篇Struts2入门Hibernate初探之单表映射Spring事务管理Struts2拦截器浅析Hibernate缓存策略Hibernate注解Hibernate初探之一对多映射Hibernate初探之多对多映射基于SSH实现员工管理系统之框架整合篇基于SSH实现员工管理系统之案例实现篇","text":"本路线共：11门课程 学习人数：4755人在学 章节预览：Spring入门篇Struts2入门Hibernate初探之单表映射Spring事务管理Struts2拦截器浅析Hibernate缓存策略Hibernate注解Hibernate初探之一对多映射Hibernate初探之多对多映射基于SSH实现员工管理系统之框架整合篇基于SSH实现员工管理系统之案例实现篇 初窥门径Spring入门篇 Spring是为解决企业应用程序开发复杂性而创建的一个Java开源框架，应用非常广泛。业内非常流行的SSH架构中的其中一个“S”指的就是Spring。本门课程作为Spring的入门级课程，将结合实例为您带来依赖注入、IOC和AOP的基本概念及用法，为后续高级课程的学习打下基础。高级·120237人在学 Struts2入门 Struts2是当前流行的JavaWeb框架！本门课程首先介绍Strust2的基本概念和发展历史，然后从一个案例入手，带领小伙伴们对Struts2有一个全面的了解。接着有对Struts2进行了更深入的讲解。相信通过本课程的学习，小伙伴们一定能够有所收获。高级·59819人在学 Hibernate初探之单表映射 Hibernate是一个著名的对象关系映射框架，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。本门课程是Hibernate的入门课程，主要介绍ORM和hibernate的概念，如何在eclipse中创建hibernate实例及相关配置文件的详解说明。高级·47401人在学 略有小成Spring事务管理 事务管理是Spring中的一个非常重要的知识。本门课程首先介绍Spring的基本概念，然后以银行转账为例，介绍Spring的编程式事务管理和声明式事务管理的应用场景和实现方式！希望通过本门课程的学习，使得小伙伴们可以在开发中灵活地应用事务。高级·45699人在学 Struts2拦截器浅析 Struts2大多数核心功能是通过拦截器实现的，每个拦截器完成某项功能，比如，params拦截器负责解析HTTP请求的参数，并设置Action的属性。本次将与各位小伙伴们分享的就是Struts2中的拦截器。高级·26394人在学 Hibernate缓存策略 Hibernate是目前最老牌和主流的JavaORM框架，而缓存是ORM框架中的一个重难点，是数据库访问性能优化的重要手段，本课程主要介绍Hibernate中缓存的原理、分类和使用。高级·19741人在学 Hibernate注解 注解在Java程序开发中的应用越来越广泛，可以有效地提高代码的简洁度。本门课程主要介绍Hibernate的常用注解，包括类级别注解、属性级别注解和关联映射注解。希望小伙伴们学习完本门课程后，能够灵活应用Hibernate注解进行开发。高级·21953人在学 Hibernate初探之一对多映射 现实世界中的对象很少有孤立存在的，例如学生，往往与所在班级和授课老师之间存在关联关系。在本次课程中，@laurenyang将带领小伙伴们一起学习Hibernate中的关联映射——一对多映射，会依次向大家介绍单向一对多和单向多对一的配置，以及cascade和inverse属性的作用。高级·29170人在学 Hibernate初探之多对多映射 多对多关联也是常见的一种关联关系，如项目和员工之间就是典型的多对多关系。在本次课程中，@laurenyany将与各位小伙伴们分享Hibernate中的关联映射——多对多映射，将向大家依次介绍多对多的概念、应用场景以及在Eclipse中的配置实现。高级·16470人在学 融会贯通基于SSH实现员工管理系统之框架整合篇 本案例介绍如何使用Struts2+Hibernate+Spring框架实现员工管理系统，本套案例课程分为框架整合篇和案例实现篇。本门课程主要介绍环境搭建和SSH框架是如何整合的！分为Struts2整合Spring和Spring整合Hibernate两大步骤进行，逐层深入，更有利于理解和学习！高级·21637人在学 基于SSH实现员工管理系统之案例实现篇 本案例介绍如何使用Struts2+Hibernate+Spring框架实现员工管理系统，本套案例课程分为框架整合篇和案例实现篇，学习本门课程前请先学习《基于SSH实现员工管理系统之框架整合篇》。本门课程主要介绍员工管理系统案例是如何实现的！包括部门管理和员工管理两个功能模块。高级·22025人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.cheshen.wiki/tags/Spring/"},{"name":"Struts2","slug":"Struts2","permalink":"http://www.cheshen.wiki/tags/Struts2/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://www.cheshen.wiki/tags/Hibernate/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Swift加薪利器-iOS动画特辑","slug":"Swift加薪利器-iOS动画特辑","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.305Z","comments":true,"path":"2017/04/15/Swift加薪利器-iOS动画特辑/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Swift加薪利器-iOS动画特辑/","excerpt":"本路线共：7门课程 学习人数：3356人在学 章节预览：SwiftWeatherAPP一起来做价值百万的AppleWatchApp：分歧终端机iOS基础教程之界面初体验iOS-动画入门iOS-动画进阶iOS动画案例之会跳舞的界面(上)iOS动画案例之会跳舞的界面(下)","text":"本路线共：7门课程 学习人数：3356人在学 章节预览：SwiftWeatherAPP一起来做价值百万的AppleWatchApp：分歧终端机iOS基础教程之界面初体验iOS-动画入门iOS-动画进阶iOS动画案例之会跳舞的界面(上)iOS动画案例之会跳舞的界面(下) 初出茅庐SwiftWeatherAPP 本课程将带领大家使用Swift语言开发一个完整的天气iOSAPP。同时大家能够学习到InterfaceBuilder、CocoaPods、CoreLocation、AFNetworking的使用，以及如何通过Swift调用Objective-C组件，如何通过IBOutlets更新View。高级·32487人在学 一起来做价值百万的AppleWatchApp：分歧终端机 展示了如何使用WatchKit，如何通过MVC的绑定来处理用户事件，如何制作动画的功能。高级·20389人在学 游刃有余iOS基础教程之界面初体验 本课程为ios的基础课程，将为大家介绍如何在ios上进行界面的开发，在这里可以学会怎样在界面上显示自己喜欢的图片，展示自己喜欢的文字，让你体会到界面的神奇所在。初级·37799人在学 iOS-动画入门 自从iOS7.0更新以来，苹果官方全面采用扁平化来设计UI。作为iOS开发者，如何在功能完成的情况下使得自己的UI更漂亮，用户体验更高，就成了现在iOS开发者们着重考虑的问题。本课程将从动画基础开始为大家讲解在扁平化设计中如何嵌入柔和的动画来提高用户体验初级·31966人在学 iOS-动画进阶 本课程将继续为大家带来iOS的常用特效处理。本课程为iOS-动画入门的进阶篇，在这里能够学习到更加高级的动画效果实现，丰富界面的动画效果设计中级·16700人在学 大显身手iOS动画案例之会跳舞的界面(上) Jake大神的又一个新作,利用在iOS动画基础课程的基础上，添加了更丰富的动画使界面有了生命，很大程度的提升用户体验，让我们的界面更加优美生动高级·18936人在学 iOS动画案例之会跳舞的界面(下) 通过对之前《iOS动画案例之会跳舞的界面（上）》的学习我们需要使用的元素都已经设计好了。接下来我们就可以使用这些元素将它们组合在一起让它们来跳舞吧!高级·14467人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"加薪","slug":"加薪","permalink":"http://www.cheshen.wiki/tags/加薪/"},{"name":"动画特辑","slug":"动画特辑","permalink":"http://www.cheshen.wiki/tags/动画特辑/"},{"name":"swift","slug":"swift","permalink":"http://www.cheshen.wiki/tags/swift/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Tony老师聊shell","slug":"Tony老师聊shell","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.307Z","comments":true,"path":"2017/04/15/Tony老师聊shell/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Tony老师聊shell/","excerpt":"本路线共：6门课程 学习人数：9108人在学 章节预览：Linux达人养成计划Ishell编程之变量shell编程之运算符shell编程之环境变量配置文件shell编程之正则表达式shell编程之条件判断与流程控制","text":"本路线共：6门课程 学习人数：9108人在学 章节预览：Linux达人养成计划Ishell编程之变量shell编程之运算符shell编程之环境变量配置文件shell编程之正则表达式shell编程之条件判断与流程控制 入门必备Linux达人养成计划I 本课程以通俗易懂的语言、风趣幽默的实例、清晰严谨的逻辑介绍了Linux的基础内容。课程以CentOS操作系统为例，为你带来Linux的简介、系统安装和常用命令等内容。让您在轻松的氛围中感受到Linux之美。初级·225890人在学 语法基础shell编程之变量 本课程是《Linux达人养成计划I》中第九章课程的延续，主要介绍Linuxshell编程基础中的变量。包括Bash变量的分类和各变量的详细使用，如：用户自定义变量、环境变量、语系变量、位置参数变量和预定义变量。中级·31345人在学 shell编程之运算符 本课程是《Tony老师聊shell——变量》课程的延续，主要介绍Linuxshell编程基础中的运算符。包括declare命令、数值运算方法和变量测试。首先在declare命令中介绍了数值型和数组类型的声明，然后介绍了运算符的详细使用，最后对不同场景下的变量进行了测试。中级·18973人在学 技能提升shell编程之环境变量配置文件 本课程是《Tony老师聊shell》系列课程的第三篇，为你带来常用的Linux环境变量配置文件的使用。对环境变量配置文件的功能进行了详解，然后又介绍了其他环境变量配置文件，包括注销时生效的环境变量配置文件、历史命令相关的环境变量配置文件、shell登录信息配置文件等。中级·19946人在学 shell编程之正则表达式 正则表达式在查找中的作用是非常重要的。本课程是《Tony老师聊shell》系列课程的第四篇，为你带来Linuxshell中的正则表达式，字符截取命令cut、printf、awk和sed,字符处理命令sort和wc。中级·23789人在学 实用案例shell编程之条件判断与流程控制 本门课程是《Tony老师聊shell》系列课程的最后一篇，多个典型案例贯穿整个课程。课程内容包括：条件判断式语句、单分支if语句、双分支if语句、多分支if语句、case语句、for循环、while循环和until循环等。学习完本门课程一定会使你的Linux运维能力再次提高。中级·20731人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/tags/Linux/"},{"name":"加薪利器","slug":"加薪利器","permalink":"http://www.cheshen.wiki/tags/加薪利器/"},{"name":"shell入门","slug":"shell入门","permalink":"http://www.cheshen.wiki/tags/shell入门/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Web前端工程师","slug":"Web前端工程师","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.309Z","comments":true,"path":"2017/04/15/Web前端工程师/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Web前端工程师/","excerpt":"本路线共：28门课程 学习人数：179216人在学 章节预览：前端开发工具技巧介绍—DW篇前端开发工具技巧介绍—Sublime篇HTML+CSS基础课程如何用CSS进行网页布局网页布局基础网页简单布局之结构与表现原则导航条菜单的制作JavaScript入门篇JavaScript进阶篇DOM事件探秘JS动画效果倒计时效果信息滚动效果制作商城分类导航效果jQuery基础(一)—样式篇jQuery基础(二)—DOM篇jQuery基础(三)—事件篇jQuery基础(四)—动画篇jQuery插件——ValidationPluginAjax全接触网页定位导航特效瀑布流布局搜索框制作企业网站综合布局实战手把手教你实现电商网站开发SEO在网页制作中的应用Yahoo军规WEB调试工具—Firebug","text":"本路线共：28门课程 学习人数：179216人在学 章节预览：前端开发工具技巧介绍—DW篇前端开发工具技巧介绍—Sublime篇HTML+CSS基础课程如何用CSS进行网页布局网页布局基础网页简单布局之结构与表现原则导航条菜单的制作JavaScript入门篇JavaScript进阶篇DOM事件探秘JS动画效果倒计时效果信息滚动效果制作商城分类导航效果jQuery基础(一)—样式篇jQuery基础(二)—DOM篇jQuery基础(三)—事件篇jQuery基础(四)—动画篇jQuery插件——ValidationPluginAjax全接触网页定位导航特效瀑布流布局搜索框制作企业网站综合布局实战手把手教你实现电商网站开发SEO在网页制作中的应用Yahoo军规WEB调试工具—Firebug 实践前端开发工具技巧介绍—DW篇 “工欲善其事，必先利其器”。本课主要以DreamweaverCS6为例，讲授Dreamweaver的使用技巧和重要实用模块，将会覆盖实际开发过程中90%以上的功能，新手入门必备！初级·182191人在学 前端开发工具技巧介绍—Sublime篇 本课程主要对SublimeText这款前端开发工具中的非常优秀的特性进行介绍，命令模式、Gotoanything、多行游标等这些能极大提高你的生产力，不愧是码农进阶必备神器。初级·144768人在学 HTML+CSS基础课程 本课程从最基本的概念开始讲起，步步深入，带领大家学习HTML、CSS样式基础知识，了解各种常用标签的意义以及基本用法，后半部分讲解CSS样式代码添加，为后面的案例课程打下基础。初级·676735人在学 如何用CSS进行网页布局 如何用CSS进行网页布局？这可是前端工程师最最基本的技能，本课程教你怎么制作一列布局、二列布局、三列布局当然还有最通用的混合布局，而且你还可以选择让它固定还是自适应。用CSS重新规划你的网页，让你的网页从此更美观、更友好。中级·140655人在学 网页布局基础 网页布局是进行网页制作的基础。本课程将讲解CSS中三种定位机制——标准文档流、浮动和绝对定位，并对标准文档流、盒子模型、float属性以及position属性等进行详细分析。从晦涩的理论讲解到编辑器环境的逐步验证，让你彻底掌握网页布局的相关知识。初级·189618人在学 网页简单布局之结构与表现原则 在网页制作当中，结构与表现分离的思想，不仅仅是将html、css分别写在不同文件当中这么简单，要从更深层次上去进行理解。本课程通过3个案例，分别从不同角度，对结构和表现分离的思想进行了展示和分析。中级·80169人在学 导航条菜单的制作 每个网站都包含导航菜单，它们形式多样。本课程将由浅到深的介绍各种常见的导航条菜单的制作方法，从垂直方向的到水平方向的，再到用CSS样式的圆角导航条，最后讲解动态交互功能且具有拉伸效果的导航条菜单，对比着学习以上内容让您的技术探索之路更高效！中级·93426人在学 JS实践JavaScript入门篇 本视频教程让您快速认识JavaScript，熟悉JavaScript基本语法、窗口交互方法和通过DOM进行网页元素的操作，学会如何编写JS代码，如何运用JavaScript去操作HTML元素和CSS样式，本JavaScript教程分为四个章节，能够让您快速入门，为JavaScript深入学习打下基础。初级·444787人在学 JavaScript进阶篇 做为WEB攻城师必备技术JavaScript，本课程从如何插入JS代码开始，学习JS基础语法、语法、函数、方法等，让你掌握JS编程思路、知识的使用等，实现运用JS语言为网页增加动态效果，达到与用户交互的目的。中级·283624人在学 DOM事件探秘 DOM事件是小伙伴们学习JS中较重要的一部分知识，所以学好JS事件可以为小伙伴们在JS的学习道路中更近一步。在此课程中Amy老师会通过通俗易懂的授课方式给大家进行讲解JS事件。最后Amy老师通过一个QQ面板实例来给小伙伴们讲解如何使用这些事件。高级·80020人在学 JS动画效果 通过本课程JS动画的学习，从简单动画开始，逐步深入缓冲动画、多物体动画、链式动画、多动画同时运动到完美运动框架的过程，每一个效果封装成一个小运动框架，逐渐培养和锻炼封装运动框架和编程的思想，让您的逻辑思维不断增强。高级·78965人在学 倒计时效果 现今团购网、电商网、门户网等，常使用时间记录重要的时刻，如时间显示、倒计时差、限时抢购等，本课程分析不同倒计时效果的计算思路及方法，掌握日期对象Date，获取时间的方法,计算时差的方法，实现不同的倒时计效果。中级·44619人在学 信息滚动效果制作 本课程简单介绍marquee标签制作简单滚动的方法，通过分析滚动原理，让您知道效果实现的思路，详细讲解如何复制元素、定时等知识的使用，运用JavaScript技术，让您掌握无缝滚动和歇间性滚动的制作方法。中级·39190人在学 商城分类导航效果 亲爱的朋友们，你知道分类导航效果作为各大商城类网站常见的导航效果之一，是如何制作出来的吗？本课仿京东商城分类导航，详细分析并讲解制作过程，掌握运用CSS技巧及JavaScript动态改变CSS样式的两种实现方法，同时扩展讲解其它商城分类导航的不同及制作方法。中级·48766人在学 jQuery实践jQuery基础(一)—样式篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第一个部分—样式篇，本课程主要介绍jQuery的基础语法，选择器以及jQuery的一些属性和样式，通过本课程的学习，我们可以用最少的代码做更多的事，让我们一起出发学习吧！初级·108678人在学 jQuery基础(二)—DOM篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第二个部分—DOM篇。本课程主要讲解jQuery中节点的创建、插入、删除与替换，除此之外我们还可以了解到jQuery中丰富的遍历节点的方法。初级·65840人在学 jQuery基础(三)—事件篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第三个部分—事件篇。此部分当中包含了，鼠标事件，表单事件，键盘事件，事件的绑定和解绑以及自定义事件。通过本课程的事件，我们能更快速的对页面进行交互的操作。初级·48560人在学 jQuery基础(四)—动画篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为最后一个部分—动画篇。通过本课程的学习，我们可以制作出以下效果：隐藏和显示、上卷下来、淡入淡出。我们也可以通过自定义动画去完成一些我们想要的效果。初级·49275人在学 jQuery插件——ValidationPlugin jQuery有很多有用的插件，其中Validation插件是最常用的插件之一。客户端表单验证是现代网站经常采用的方式，可以减少服务器压力，缩短用户等待时间和提升用户体验。jQueryValidation插件提供了很多的配置项目，还附带了很多验证方法及多语言提示。中级·53908人在学 Ajax全接触 本课程通过一个简单的例子，由浅入深，循序渐进的介绍了Ajax的相关概念、原理、实现方式和应用方法，包含HTTP请求的概念、PHP的简单语法、JSON数据格式、Ajax的原生和jQuery实现、跨域等知识点。高级·142122人在学 网页定位导航特效 本课程我们将为大家介绍从静态布局到动态效果实现，从浅到深，循循渐进，讲解如何定位到所需位置，运用jQuery、JavaScript两种方式实现网页定位导航。赶快行动吧！中级·56170人在学 瀑布流布局 瀑布流布局是网站比较流行的一种布局方式。本案例将深入讲解实现瀑布流布局的三大方式：JavaScript、jQurey和CSS3，你将学习到如何用JavaScript方法实现图片的定位及排序、两种不同的方式对图片进行持续加载，以及CSS3中多栏布局怎么实现瀑布流布局。中级·69251人在学 搜索框制作 本课程中，我们将使用jQuery和JavaScript两种技术来实现搜索框效果功能,并对jQuery和JavaScript两种技术进行了对比，你将可以了解到JQ与JS实现Ajax技术的不同点。赶快行动吧！中级·50771人在学 电商网站企业网站综合布局实战 本课程重点介绍HTML/CSS实现常见企业网站布局的方法、布局中常用的基本盒子模型、三列布局、两列自适应高度及基于jQ的开源图片幻灯片切换效果插件的使用。让您快速掌握企业网站的基本布局方法，同时对HTML、CSS、JS、jQ等知识的综合运用和提升。中级·107821人在学 手把手教你实现电商网站开发 本课程主要介绍电商网站基本制作流程，通过电商网站分步的教学让大家了解和掌握电商网站制作的流程和注意事项。并且运用网站内学习过的知识点，更加快速的掌握整站的开发过程，增加开发经验。中级·119511人在学 Web调试工具SEO在网页制作中的应用 本课程将通过对网页结构以及前端代码两个方面介绍前端SEO知识。作为前端工程师，可能你每天只关注怎样实现一个又一个的网页特效，怎样让自己的网站更酷更炫，但是本课程能教你怎样让更多的人来访问你的网站！初级·69689人在学 Yahoo军规 互联网高速发展当今,用户对快速访问网页需求越来越高，做为网站建设者，如何提高网站性能，成为炙手可热的问题，本课程让你清楚影响网站性能的原因，从而避免不利于网站性能的因素，借助Yslow工具快速找到问题所在，提高网站性能，让提高网站性能、快速访问网站不在是梦想。高级·29204人在学 WEB调试工具—Firebug Firebug是WEB调试工具之一，是网页浏览器Firefox下的一款开发类插件。它集HTML查看和编辑、JS控制台、网络状况监视器于一体，是开发JavaScript、CSS、HTML和Ajax的得力助手。掌握Firebug的使用，可从各个不同的角度剖析Web页面内部的细节，给Web开发带来极大的便利。初级·63994人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"求职","slug":"求职","permalink":"http://www.cheshen.wiki/tags/求职/"},{"name":"实战","slug":"实战","permalink":"http://www.cheshen.wiki/tags/实战/"},{"name":"前端","slug":"前端","permalink":"http://www.cheshen.wiki/tags/前端/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Web前端工程师成长第一阶段(基础篇)","slug":"Web前端工程师成长第一阶段(基础篇)","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.312Z","comments":true,"path":"2017/04/15/Web前端工程师成长第一阶段(基础篇)/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Web前端工程师成长第一阶段(基础篇)/","excerpt":"本路线共：13门课程 学习人数：58621人在学 章节预览：HTML+CSS基础课程前端开发工具技巧介绍—DW篇JavaScript入门篇JavaScript进阶篇jQuery基础(一)—样式篇jQuery基础(二)—DOM篇jQuery基础(三)—事件篇jQuery基础(四)—动画篇网页定位导航特效网页布局基础信息排列效果Tab选项卡切换效果企业网站综合布局实战","text":"本路线共：13门课程 学习人数：58621人在学 章节预览：HTML+CSS基础课程前端开发工具技巧介绍—DW篇JavaScript入门篇JavaScript进阶篇jQuery基础(一)—样式篇jQuery基础(二)—DOM篇jQuery基础(三)—事件篇jQuery基础(四)—动画篇网页定位导航特效网页布局基础信息排列效果Tab选项卡切换效果企业网站综合布局实战 第一步了解HTML和CSSHTML+CSS基础课程 本课程从最基本的概念开始讲起，步步深入，带领大家学习HTML、CSS样式基础知识，了解各种常用标签的意义以及基本用法，后半部分讲解CSS样式代码添加，为后面的案例课程打下基础。初级·676735人在学 前端开发工具技巧介绍—DW篇 “工欲善其事，必先利其器”。本课主要以DreamweaverCS6为例，讲授Dreamweaver的使用技巧和重要实用模块，将会覆盖实际开发过程中90%以上的功能，新手入门必备！初级·182191人在学 第二步学习JavaScriptJavaScript入门篇 本视频教程让您快速认识JavaScript，熟悉JavaScript基本语法、窗口交互方法和通过DOM进行网页元素的操作，学会如何编写JS代码，如何运用JavaScript去操作HTML元素和CSS样式，本JavaScript教程分为四个章节，能够让您快速入门，为JavaScript深入学习打下基础。初级·444787人在学 JavaScript进阶篇 做为WEB攻城师必备技术JavaScript，本课程从如何插入JS代码开始，学习JS基础语法、语法、函数、方法等，让你掌握JS编程思路、知识的使用等，实现运用JS语言为网页增加动态效果，达到与用户交互的目的。中级·283624人在学 第三步学习jQueryjQuery基础(一)—样式篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第一个部分—样式篇，本课程主要介绍jQuery的基础语法，选择器以及jQuery的一些属性和样式，通过本课程的学习，我们可以用最少的代码做更多的事，让我们一起出发学习吧！初级·108678人在学 jQuery基础(二)—DOM篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第二个部分—DOM篇。本课程主要讲解jQuery中节点的创建、插入、删除与替换，除此之外我们还可以了解到jQuery中丰富的遍历节点的方法。初级·65840人在学 jQuery基础(三)—事件篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为第三个部分—事件篇。此部分当中包含了，鼠标事件，表单事件，键盘事件，事件的绑定和解绑以及自定义事件。通过本课程的事件，我们能更快速的对页面进行交互的操作。初级·48560人在学 jQuery基础(四)—动画篇 jQuery基础课程总共分为4个部分，分别是样式篇、事件篇、动画篇、DOM篇。此为最后一个部分—动画篇。通过本课程的学习，我们可以制作出以下效果：隐藏和显示、上卷下来、淡入淡出。我们也可以通过自定义动画去完成一些我们想要的效果。初级·49275人在学 网页定位导航特效 本课程我们将为大家介绍从静态布局到动态效果实现，从浅到深，循循渐进，讲解如何定位到所需位置，运用jQuery、JavaScript两种方式实现网页定位导航。赶快行动吧！中级·56170人在学 第四步上手实践网页布局基础 网页布局是进行网页制作的基础。本课程将讲解CSS中三种定位机制——标准文档流、浮动和绝对定位，并对标准文档流、盒子模型、float属性以及position属性等进行详细分析。从晦涩的理论讲解到编辑器环境的逐步验证，让你彻底掌握网页布局的相关知识。初级·189618人在学 信息排列效果 如何变换网页内容的展现形式，实现从静态网页布局到JS的动态效果？本课程为您讲解运用HTML/CSS实现网页的静态布局，以及运用JS实现网页展现形式之间的切换，节约网页空间。从制作思路分析到效果实现，让你快速学会信息排列效果的制作。中级·26505人在学 Tab选项卡切换效果 本课程详细介绍网页页面中最流行常用的tab切换效果，包括滑动、点击切换，延迟切换及自动切换等多种效果。其中重点讲解settimeout和setinterval的区别，以及使用JavaScript、jQuery等技术实现tab切换特效。中级·48960人在学 企业网站综合布局实战 本课程重点介绍HTML/CSS实现常见企业网站布局的方法、布局中常用的基本盒子模型、三列布局、两列自适应高度及基于jQ的开源图片幻灯片切换效果插件的使用。让您快速掌握企业网站的基本布局方法，同时对HTML、CSS、JS、jQ等知识的综合运用和提升。中级·107821人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"求职必备","slug":"求职必备","permalink":"http://www.cheshen.wiki/tags/求职必备/"},{"name":"前端基础","slug":"前端基础","permalink":"http://www.cheshen.wiki/tags/前端基础/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"Android加薪利器--自定义View","slug":"Android加薪利器--自定义View","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.245Z","comments":true,"path":"2017/04/15/Android加薪利器--自定义View/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/Android加薪利器--自定义View/","excerpt":"本路线共：7门课程 学习人数：8942人在学 章节预览：超快的Android模拟器GenymotionAndroidUI模板设计Android图像处理-打造美图秀秀从它开始Android图像处理-变“换”莫测的图像Android属性动画赏析Android实现卫星菜单Android自定义任意层级树形控件","text":"本路线共：7门课程 学习人数：8942人在学 章节预览：超快的Android模拟器GenymotionAndroidUI模板设计Android图像处理-打造美图秀秀从它开始Android图像处理-变“换”莫测的图像Android属性动画赏析Android实现卫星菜单Android自定义任意层级树形控件 出发之前，准备行囊！超快的Android模拟器Genymotion 本课程将介绍Android平台下的一款最快的、最流行的Android模拟器，以及如何安装Genymotion模拟器，并对eclipse和Intellij等开发工具进行配置初级·45876人在学 稳扎稳打，为成功铺路！AndroidUI模板设计 UI设计一直是程序设计中非常重要的一环，也是最让人抓狂的一环，好的设计需要不断修改、不断完善，那么我们如何才能减少UI设计中的重复劳动呢、如何在修改设计时减少工作量呢、如何一次开发，重复使用呢？如果你也有这样的疑问，那么本次课程一定会让你获益匪浅。中级·58834人在学 多学一点，以备不时之需！Android图像处理-打造美图秀秀从它开始 本次课程将带领大家了解Android中对图像色彩的处理和分析方法，并通过实例向大家演示市面上常见的图像处理特效的实现方法。中级·23599人在学 Android图像处理-变“换”莫测的图像 本次课程将带领大家了解Android中对图像变形特效的处理和分析方法，并通过各种实例向大家演示市面上常见的图像处理特效的实现方法。中级·17290人在学 Android属性动画赏析 动画几乎是一个好的App所不可缺少的一部分，它体现了一种更友好的交互方式，在iOS、AndroidL中动画的使用越来越多，特别是后者更是着重强调设计更好的动画。从3.0开始，Android就提供了一种更为强大的属性动画框架。本次课程，将向你介绍如何使用属性动画做出更好的动画中级·32288人在学 最后一搏！Android实现卫星菜单 本课程将带领大家通过自定义ViewGroup结合动画实现一个卫星式菜单，课程涵盖了自定义控件的整个过程，包括自定义属性的定义与获取、控件的测量、布局等相关知识。该菜单效果也包含相当多的传统View动画效果，大家可以对其进行深入理解中级·23029人在学 Android自定义任意层级树形控件 本课程将带领大家通过ListView打造一个任意层级的树形控件，大家可以学到巧妙的设计思想以及数据结构的知识。课程中也包含如何巧妙的利用反射加注解将设计通用化，同时可以进一步加深对ListView适配器的理解高级·22316人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Android自定义View","slug":"Android自定义View","permalink":"http://www.cheshen.wiki/tags/Android自定义View/"},{"name":"升职加薪","slug":"升职加薪","permalink":"http://www.cheshen.wiki/tags/升职加薪/"},{"name":"热门效果","slug":"热门效果","permalink":"http://www.cheshen.wiki/tags/热门效果/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"搞定Java加解密","slug":"搞定Java加解密","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.342Z","comments":true,"path":"2017/04/15/搞定Java加解密/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/搞定Java加解密/","excerpt":"本路线共：5门课程 学习人数：9046人在学 章节预览：Java实现Base64加密Java实现消息摘要算法加密JAVA实现对称加密JAVA实现非对称加密Java实现数字签名","text":"本路线共：5门课程 学习人数：9046人在学 章节预览：Java实现Base64加密Java实现消息摘要算法加密JAVA实现对称加密JAVA实现非对称加密Java实现数字签名 基础与单向加密Java实现Base64加密 本门课程是Java加解密系列的第一门课，旨在为大家介绍Java加密解密的基础知识，并使用Base64算法实现加解密。本门课程在整个加解密系列中十分重要，是Java加解密必备的入门基础。中级·24444人在学 Java实现消息摘要算法加密 本课程是《Java实现Base64加密》课程的延续，是Java加解密系列课程的第二门课。本课程主要介绍如何在Java中使用MD、SHA、MAC三种消息摘要算法实现加解密，以及他们的应用场景。中级·16497人在学 复杂的对称、非对称加密JAVA实现对称加密 本门课程是Java加解密系列课程的第三门课，学习前需要学习《Java实现Base64加密》。对称加密指加密和解密使用相同密钥的加密算法。本课程中将介绍DES、3重DES、AES和PBE几种常见的对称加密算法在Java中的实现，以及他们的应用范围。中级·19680人在学 JAVA实现非对称加密 非对称加密算法是一种基于密钥的保密方法，需要公开密钥和私有密钥，在文件加密、尤其是网银中应用广泛。本课程主要介绍非对称加密算法的实现过程，DH、RSA和ELGamal等几种常见的非对称加密算法的在Java中的应用。中级·16691人在学 “高大上”的数字签名Java实现数字签名 数字签名算法在金融领域得到广泛的应用，如网银中常用的U盾。本课程主要介绍数字签名的实现过程，以及RSA、DSA、ECDSA等几种常见的数字签名在JAVA中的实现。中级·27344人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Java开发","slug":"Java开发","permalink":"http://www.cheshen.wiki/tags/Java开发/"},{"name":"加密解密","slug":"加密解密","permalink":"http://www.cheshen.wiki/tags/加密解密/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"iOS苹果表开发攻略","slug":"iOS苹果表开发攻略","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.273Z","comments":true,"path":"2017/04/15/iOS苹果表开发攻略/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/iOS苹果表开发攻略/","excerpt":"本路线共：10门课程 学习人数：5455人在学 章节预览：征战Objective-CObjective-C面向对象初体验iOS基础入门之Foundation框架初体验iOS基础教程之界面初体验iOS-动画入门iOS-动画进阶一起来做价值百万的AppleWatchApp：分歧终端机iOS-健康App系列之迈出你的第一步iOS-健康App系列之脂肪你去哪儿iOS-健康App系列之我走了多远","text":"本路线共：10门课程 学习人数：5455人在学 章节预览：征战Objective-CObjective-C面向对象初体验iOS基础入门之Foundation框架初体验iOS基础教程之界面初体验iOS-动画入门iOS-动画进阶一起来做价值百万的AppleWatchApp：分歧终端机iOS-健康App系列之迈出你的第一步iOS-健康App系列之脂肪你去哪儿iOS-健康App系列之我走了多远 初出茅庐征战Objective-C 本课程作为零基础学习Objective－c语言的优秀教程，教学核心在于教会学生像计算机一样思考，并且使用符合OC编程哲学的方式写出如其他苹果产品一般优雅的程序，最终为作出优秀的IOS与MacOS应用程序打好基础初级·54051人在学 Objective-C面向对象初体验 本课程将带大家学习Objective-C中的面向对象编程，其中会涉及到OC语言中的类，对象，属性以及一些方法和类的函数的应用，为后面的课程打下一个良好的基础初级·26921人在学 iOS基础入门之Foundation框架初体验 在iOS里，你可以找到很多能在应用程序里调用的框架，例如Foundation、UIKit和CoreGraphics等等。如果你需要使用一个框架，你就要将它添加到你的项目中。而当你开发程序，你主要会用到的框架就是Foundation和UIKit了，因为它们能满足你所需要的大部分东西。初级·47992人在学 小有所成iOS基础教程之界面初体验 本课程为ios的基础课程，将为大家介绍如何在ios上进行界面的开发，在这里可以学会怎样在界面上显示自己喜欢的图片，展示自己喜欢的文字，让你体会到界面的神奇所在。初级·37799人在学 iOS-动画入门 自从iOS7.0更新以来，苹果官方全面采用扁平化来设计UI。作为iOS开发者，如何在功能完成的情况下使得自己的UI更漂亮，用户体验更高，就成了现在iOS开发者们着重考虑的问题。本课程将从动画基础开始为大家讲解在扁平化设计中如何嵌入柔和的动画来提高用户体验初级·31966人在学 iOS-动画进阶 本课程将继续为大家带来iOS的常用特效处理。本课程为iOS-动画入门的进阶篇，在这里能够学习到更加高级的动画效果实现，丰富界面的动画效果设计中级·16700人在学 一起来做价值百万的AppleWatchApp：分歧终端机 展示了如何使用WatchKit，如何通过MVC的绑定来处理用户事件，如何制作动画的功能。高级·20389人在学 大显身手iOS-健康App系列之迈出你的第一步 本课程为AppleWatch健康App的第一节课程，将为大家介绍如何搭建walker环境以及使用HealthKit获取用户的运动数据，将健康app中的数据同步到手表中级·11177人在学 iOS-健康App系列之脂肪你去哪儿 学习掌握如何通过苹果HealthKit框架读取、处理卡路里数据，并且将我们解析获取到的数据关联到界面，让用户可以实时的了解自己卡路里消耗的是数据中级·8758人在学 iOS-健康App系列之我走了多远 想知道自己每天走了多远吗？现在可以从健康应用统计的数据中获取运动的里程数，知道我们究竟走了多远，如果想每天达到多少里程，现在就可以通过我们的应用来了解，离我们的任务目标还有多少中级·11035人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"AppleWatch开发","slug":"AppleWatch开发","permalink":"http://www.cheshen.wiki/tags/AppleWatch开发/"},{"name":"运动app","slug":"运动app","permalink":"http://www.cheshen.wiki/tags/运动app/"},{"name":"从0开始学苹果手表开发","slug":"从0开始学苹果手表开发","permalink":"http://www.cheshen.wiki/tags/从0开始学苹果手表开发/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"搞定python基础","slug":"搞定python基础","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.343Z","comments":true,"path":"2017/04/15/搞定python基础/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/搞定python基础/","excerpt":"本路线共：4门课程 学习人数：11516人在学 章节预览：Python开发环境搭建Python入门python进阶python装饰器","text":"本路线共：4门课程 学习人数：11516人在学 章节预览：Python开发环境搭建Python入门python进阶python装饰器 开发环境搭建Python开发环境搭建 学习一门语言，首先要把环境准备好，本课程主要讲解在不同系统（Window、Linux）中搭建Python开发环境，及Eclipse配置和Python文件类型，让您快速了解和应用Python开发环境及工具，为后续Python学习打好基础。初级·71032人在学 基础知识Python入门 Python教程基础分《Python入门》和《Python进阶》两门课程，本视频教程是Python第一门课程，是Python开发的入门教程，将介绍Python语言的特点和适用范围，Python基本的数据类型，条件判断和循环，函数，以及Python特有的切片和列表生成式。希望本python教程能够让您快速入门并编写简单的Python程序。初级·251088人在学 python进阶 Python基础分《Python入门》和《Python进阶》两门课程，《Python进阶》是第二门课程，学习该课程前，请先学习《Python入门》,效果会更好。《Python进阶》课程详细介绍Python强大的函数式编程和面向对象编程，掌握Python高级程序设计的方法。中级·107011人在学 python装饰器 Python装饰器可帮助我们抽离出大量函数中与函数功能本身无关的雷同代码，并继续重用,本课程从函数作用域到闭包到装饰器讲解，让您掌相应概念，及闭包和装饰器的运用。中级·30219人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"加薪利器","slug":"加薪利器","permalink":"http://www.cheshen.wiki/tags/加薪利器/"},{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"基础","slug":"基础","permalink":"http://www.cheshen.wiki/tags/基础/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"从零开始学习ThinkPHP框架","slug":"从零开始学习ThinkPHP框架","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.318Z","comments":true,"path":"2017/04/15/从零开始学习ThinkPHP框架/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/从零开始学习ThinkPHP框架/","excerpt":"本路线共：9门课程 学习人数：14278人在学 章节预览：HTML+CSS基础课程PHP入门篇与MySQL的零距离接触PHP进阶篇PHP面向对象编程PHP与MySQL关系大揭秘MVC架构模式分析与设计PHP实现页面静态化快速入门ThinkPHP框架—理论篇","text":"本路线共：9门课程 学习人数：14278人在学 章节预览：HTML+CSS基础课程PHP入门篇与MySQL的零距离接触PHP进阶篇PHP面向对象编程PHP与MySQL关系大揭秘MVC架构模式分析与设计PHP实现页面静态化快速入门ThinkPHP框架—理论篇 夯实基础HTML+CSS基础课程 本课程从最基本的概念开始讲起，步步深入，带领大家学习HTML、CSS样式基础知识，了解各种常用标签的意义以及基本用法，后半部分讲解CSS样式代码添加，为后面的案例课程打下基础。初级·676735人在学 PHP入门篇 轻松学习PHP基础知识，了解PHP中的变量、变量的类型、常量等概念，认识PHP中的运算符，掌握PHP中顺序结构、条件结构、循环结构三种语言结构语句。初级·306364人在学 与MySQL的零距离接触 本课程涵盖全部MySQL数据库的基础，主要学习MySQL数据库的基础知识、数据表的常用操作及各种约束的使用，以及综合的运用各种命令实现记录进行CURD等操作，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。初级·219607人在学 开发进阶PHP进阶篇 通过PHP学习的进阶篇的学习，你可以对PHP的理论知识由浅入深有更深一步的掌握，这些知识能够使您更加全面的掌握PHP，从而助您在实际工作中使用PHP快速开发网站程序。中级·124711人在学 PHP面向对象编程 本课程通过讲述面向对象的基本概念以及相关的案例实践，让小伙伴们对面向对象有一个基本的认识，能够掌握把实际问题抽象成为类对象用以解决实际问题的方法，掌握面向对象的最重要的核心能力。中级·51131人在学 PHP与MySQL关系大揭秘 你听说过php吗？你听说过mysql吗？他俩结合几十年了你知道了吗？让我们一起走上探秘之旅，找寻php和mysql恋爱的真谛。GO！GO！GO！中级·57023人在学 初识模板引擎MVC架构模式分析与设计 本课程前部分通过学习MVC理论知识，引入MVC设计简单的框架的方法，并带领学生掌握对框架MVC三层框架简化的方法。后半部分通过视图层的介绍引入smarty的概念，详细介绍smarty的语法，通过实例再次加深对smarty的理解，并演示smarty各个内置函数与php、自定义函数的用法。中级·59874人在学 PHP实现页面静态化 众所周知，页面静态化是门户网站研发中必备的一项技能，本课程从纯静态化和伪静态化两个角度进行分析，带领大家掌握在PHP中如何生成纯静态化页面，在WEB服务器中如何配置伪静态，帮助大家掌握又一项加薪利器。中级·43741人在学 框架全接触快速入门ThinkPHP框架—理论篇 通过对ThinkPHP框架基础知识的讲解，带领大家由浅入深轻松掌握ThinkPHP的理论基础，更加全面的掌握ThinkPHP框架运行机制，帮助大家在实际工作中使用ThinkPHP框架实现快速开发。高级·66695人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"职场必备","slug":"职场必备","permalink":"http://www.cheshen.wiki/tags/职场必备/"},{"name":"热门框架","slug":"热门框架","permalink":"http://www.cheshen.wiki/tags/热门框架/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"从0开始学习制作QQ侧滑菜单","slug":"从0开始学习制作QQ侧滑菜单","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.314Z","comments":true,"path":"2017/04/15/从0开始学习制作QQ侧滑菜单/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/从0开始学习制作QQ侧滑菜单/","excerpt":"本路线共：4门课程 学习人数：8261人在学 章节预览：Android攻城狮的第一门课（入门篇）AndroidUI模板设计Android属性动画赏析QQ5.0侧滑菜单","text":"本路线共：4门课程 学习人数：8261人在学 章节预览：Android攻城狮的第一门课（入门篇）AndroidUI模板设计Android属性动画赏析QQ5.0侧滑菜单 先入门！再说其它Android攻城狮的第一门课（入门篇） 本课程涵盖全部Android应用开发的基础，根据技能点的作用分为5个篇章，包括环境篇、控件篇、布局篇、组件篇和通用篇，本课程的目标就是“看得懂、学得会、做得出”，为后续的学习打下夯实的基础。初级·241158人在学 制作菜单技能准备AndroidUI模板设计 UI设计一直是程序设计中非常重要的一环，也是最让人抓狂的一环，好的设计需要不断修改、不断完善，那么我们如何才能减少UI设计中的重复劳动呢、如何在修改设计时减少工作量呢、如何一次开发，重复使用呢？如果你也有这样的疑问，那么本次课程一定会让你获益匪浅。中级·58834人在学 Android属性动画赏析 动画几乎是一个好的App所不可缺少的一部分，它体现了一种更友好的交互方式，在iOS、AndroidL中动画的使用越来越多，特别是后者更是着重强调设计更好的动画。从3.0开始，Android就提供了一种更为强大的属性动画框架。本次课程，将向你介绍如何使用属性动画做出更好的动画中级·32288人在学 万事俱备只欠东风QQ5.0侧滑菜单 本课程将带领大家通过自定义控件实现QQ5.0侧滑菜单，课程将循序渐进，首先实现最普通的侧滑菜单，然后引入属性动画与拖动菜单效果相结合，最终实现QQ5.0侧滑菜单效果。通过本课程大家会对侧滑菜单有更深层次的了解，通过自定义控件和属性动画打造千变万化的侧滑菜单效果高级·56729人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.cheshen.wiki/tags/Android/"},{"name":"侧滑菜单","slug":"侧滑菜单","permalink":"http://www.cheshen.wiki/tags/侧滑菜单/"},{"name":"热门应用","slug":"热门应用","permalink":"http://www.cheshen.wiki/tags/热门应用/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"搞定JavaSSM框架开发","slug":"搞定Java SSM框架开发","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.340Z","comments":true,"path":"2017/04/15/搞定Java SSM框架开发/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/搞定Java SSM框架开发/","excerpt":"本路线共：10门课程 学习人数：13741人在学 章节预览：Spring入门篇Spring事务管理SpringMVC起步SpringMVC拦截器通过自动回复机器人学Mybatis—基础版通过自动回复机器人学Mybatis—加强版Java高并发秒杀API之业务分析与DAO层Java高并发秒杀API之Service层Java高并发秒杀API之web层Java高并发秒杀API之高并发优化","text":"本路线共：10门课程 学习人数：13741人在学 章节预览：Spring入门篇Spring事务管理SpringMVC起步SpringMVC拦截器通过自动回复机器人学Mybatis—基础版通过自动回复机器人学Mybatis—加强版Java高并发秒杀API之业务分析与DAO层Java高并发秒杀API之Service层Java高并发秒杀API之web层Java高并发秒杀API之高并发优化 战斗伊始——SpringSpring入门篇 Spring是为解决企业应用程序开发复杂性而创建的一个Java开源框架，应用非常广泛。业内非常流行的SSH架构中的其中一个“S”指的就是Spring。本门课程作为Spring的入门级课程，将结合实例为您带来依赖注入、IOC和AOP的基本概念及用法，为后续高级课程的学习打下基础。高级·120237人在学 Spring事务管理 事务管理是Spring中的一个非常重要的知识。本门课程首先介绍Spring的基本概念，然后以银行转账为例，介绍Spring的编程式事务管理和声明式事务管理的应用场景和实现方式！希望通过本门课程的学习，使得小伙伴们可以在开发中灵活地应用事务。高级·45699人在学 转战阵地——SpringMVCSpringMVC起步 SpringMVC为我们提供了一个基于组件和松耦合的MVC实现框架。在使用Java中其它MVC框架多年之后，面对SpringMVC有一种相见恨晚的感觉。SpringMVC是如此的优雅，轻盈与简洁，让人从其它框架的桎梏解脱出来。本课程将带你步入SpringMVC。高级·99701人在学 SpringMVC拦截器 拦截器是SpringMVC中一个十分重要且应用广泛的内容。本课程通过乱码问题的解决引入SpringMVC拦截器的使用，介绍了拦截器的工作原理、实现方法和使用场景，最后介绍了拦截器与过滤器的区别。高级·42065人在学 再下一城——MyBatis通过自动回复机器人学Mybatis—基础版 各位小伙伴们，你是否还在为使用Java中原始JDBC的开发方式的繁琐而苦恼呢？Mybatis可以帮你解决这个难题，在本次课程中，让我们通过基础教程加案例实战开发的学习方式，逐步学习Mybatis的下载与配置以及基本功能应用。高级·60267人在学 通过自动回复机器人学Mybatis—加强版 你是愿意停留在仅仅会使用Mybatis的层次上，还是愿意与我一起揭开Mybatis面纱，看看背后的故事？本课程将继续上一课程中的案例来介绍Java中Mybatis的功能，与上一课程不同的是：本课程在介绍功能的同时，尽可能多的介绍Mybatis源码。高级·32986人在学 终极目标——整合案例Java高并发秒杀API之业务分析与DAO层 高并发和秒杀都是当今的热门词汇，如何使用Java框架实现高并发秒杀API是该系列课程要研究的内容。秒杀系列课程分为四门，本门课程是第一门，主要对秒杀业务进行分析设计，以及DAO层的实现。课程中使用了流行的框架组合SpringMVC+Spring+MyBatis，还等什么，赶快来加入吧！高级·34697人在学 Java高并发秒杀API之Service层 本门课程是《Java实现高并发秒杀API》系列课程的第二门课，主要介绍秒杀业务Service层的设计和实现，基于Spring托管Service实现类，并使用了Spring声明式事务。秒杀项目使用流行的SpringMVC+Spring+MyBatis整合框架进行开发。非常值得学习呦！高级·25872人在学 Java高并发秒杀API之web层 本门课程是《Java实现高并发秒杀API》系列课程的第三门课，主要介绍秒杀业务Web层的设计和实现，使⽤用SpringMVC整合spring,实现秒杀restful接⼝。秒杀项目使用流行的SpringMVC+Spring+MyBatis整合框架进行开发。非常值得学习呦！高级·28037人在学 Java高并发秒杀API之高并发优化 本门课程是《Java实现高并发秒杀API》系列课程的第四门课，主要介绍秒杀的高并发优化，老师首先带大家分析了秒杀的瓶颈所在，然后针对瓶颈进行了优化。相信通过老师的详细介绍，小伙伴们一定可以从中受益！高级·32423人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.cheshen.wiki/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://www.cheshen.wiki/tags/SpringMVC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://www.cheshen.wiki/tags/MyBatis/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"前端经典案例集萃之“图片、信息展示”","slug":"前端经典案例集萃之“图片、信息展示”","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.324Z","comments":true,"path":"2017/04/15/前端经典案例集萃之“图片、信息展示”/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/前端经典案例集萃之“图片、信息展示”/","excerpt":"本路线共：8门课程 学习人数：9288人在学 章节预览：CSS3绚丽照片墙Tab选项卡切换效果图片展示特效焦点图轮播特效瀑布流布局信息排列效果信息列表制作信息滚动效果制作","text":"本路线共：8门课程 学习人数：9288人在学 章节预览：CSS3绚丽照片墙Tab选项卡切换效果图片展示特效焦点图轮播特效瀑布流布局信息排列效果信息列表制作信息滚动效果制作 图片展示CSS3绚丽照片墙 通过纯CSS实现绚丽的照片墙效果，展示不同位置不同角度摆放的多张照片，鼠标移动上去照片会旋转放大并且显示在最上面。主要通过CSS3中transform中的rotate属性设置照片角度，scale设置照片的缩放，最后通过transition属性设置动画时间等。中级·44392人在学 Tab选项卡切换效果 本课程详细介绍网页页面中最流行常用的tab切换效果，包括滑动、点击切换，延迟切换及自动切换等多种效果。其中重点讲解settimeout和setinterval的区别，以及使用JavaScript、jQuery等技术实现tab切换特效。中级·48960人在学 图片展示特效 在电商时代，为了吸引用户，图片展示是各大网站必不可少的特效，本课程带领我们从分析展示特效原理，掌握如何进行图片定位，使用JS技术实现图片展示效果效果，并对代码进行深度优化，让你不再为图片展示特效而发愁。中级·21639人在学 焦点图轮播特效 通过学习您可以理解图片轮播原理，还将讲解setTimeout()、setInterval()函数设置定时器与清除定时器clearInterval()函数，使用函数递归实现图片滑动切换，采用辅助图片实现图片无限滚动等编程技巧。中级·40603人在学 瀑布流布局 瀑布流布局是网站比较流行的一种布局方式。本案例将深入讲解实现瀑布流布局的三大方式：JavaScript、jQurey和CSS3，你将学习到如何用JavaScript方法实现图片的定位及排序、两种不同的方式对图片进行持续加载，以及CSS3中多栏布局怎么实现瀑布流布局。中级·69251人在学 信息展示信息排列效果 如何变换网页内容的展现形式，实现从静态网页布局到JS的动态效果？本课程为您讲解运用HTML/CSS实现网页的静态布局，以及运用JS实现网页展现形式之间的切换，节约网页空间。从制作思路分析到效果实现，让你快速学会信息排列效果的制作。中级·26505人在学 信息列表制作 详细讲解信息列表的制作方法和技巧，以真实实例为主线，贯穿诙谐轻松的教学方法，从易到难，循序渐进，掌握相应知识点、开发标准，以最快的速度掌握不同技术的实现方法，提高Web开发经验与技巧。中级·16954人在学 信息滚动效果制作 本课程简单介绍marquee标签制作简单滚动的方法，通过分析滚动原理，让您知道效果实现的思路，详细讲解如何复制元素、定时等知识的使用，运用JavaScript技术，让您掌握无缝滚动和歇间性滚动的制作方法。中级·39190人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"经典案例","slug":"经典案例","permalink":"http://www.cheshen.wiki/tags/经典案例/"},{"name":"职业必备","slug":"职业必备","permalink":"http://www.cheshen.wiki/tags/职业必备/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"前端经典案例集萃之“网页常用特效”","slug":"前端经典案例集萃之 网页常用特效","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.322Z","comments":true,"path":"2017/04/15/前端经典案例集萃之 网页常用特效/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/前端经典案例集萃之 网页常用特效/","excerpt":"本路线共：7门课程 学习人数：18660人在学 章节预览：形形色色的下拉菜单侧边栏信息展示效果回到顶部效果弹出层效果网页广告特效展开与收起效果Tooltip浮动提示框效果","text":"本路线共：7门课程 学习人数：18660人在学 章节预览：形形色色的下拉菜单侧边栏信息展示效果回到顶部效果弹出层效果网页广告特效展开与收起效果Tooltip浮动提示框效果 导航类形形色色的下拉菜单 本课程从易到难，循循渐进，从静态网页布局，到运用HTML/CSS、JavaScript、jQuery不同技术实现动态下拉菜单，让您掌握下拉菜单的制作及在不同浏览器间进行代码调试，解决浏览器兼容问题。中级·81986人在学 侧边栏信息展示效果 学会实现侧边栏内容效果展示，能够让你迅速进阶。三个步骤:通过HTML、CSS实现侧边栏内容布局；实现JavaScript代码效果，使用面向对象的方式；在JavaScript代码预留位置，添加动画效果。学会这些，跻身大网站程序员行列，身价倍增，赶快学习！高级·23665人在学 网页特效回到顶部效果 回到顶部效果是目前大型网站不可缺少的一部分，也许你已经会用锚链接的方式来实现，是不是不满意呢？这里将重点分享用JavaScript技术来实现，不仅可以设定按钮出现的时机，还能实现对滚动条速度的控制，是不是很炫酷呀！中级·32372人在学 弹出层效果 在各大网站中，我们常运用弹出层效果实现登陆和图片展示效果。本课程主要讲解如何定位、如何创建，插入，删除网页元素，并从静态网页布局到JS代码实现，详细分析每个环节，让您能灵活运用知识，制作出超炫、超实用的弹出层效果。中级·29613人在学 网页广告特效 网页广告特效是大部分网站中都出现的内容，那么我们这门课程能帮您深度分析广告特效原理，分步剖析制作过程，从浅到深，逐步优化代码，让你深入理解，并灵活运用知识，举一反三，制作出绚丽的广告特效。中级·32815人在学 展开与收起效果 门户网站顶部广告、阅读类网站“查看全文”，电商网站分类导航，都会应用到展开与收起效果。本课程讲解使用JavaScript、jQuery实现动态效果、动画效果原理以及节点式查找控件的方法。通过效果展示与案例分析，让你掌握不同类型展开与收起效果的实现。中级·25212人在学 Tooltip浮动提示框效果 本课程详细讲述使用原生JavaScript如何设计和实现Tooltip浮动提示框特效。并通过一步一步的代码实现和代码优化过程，不仅让您掌握特效的实现，还掌握解决问题的思路，了解诸如代码简化、事件绑定、事件冒泡等更多的JavaScript技巧和知识，提升编程兴趣和水平。中级·20289人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"职业必备","slug":"职业必备","permalink":"http://www.cheshen.wiki/tags/职业必备/"},{"name":"必备技能","slug":"必备技能","permalink":"http://www.cheshen.wiki/tags/必备技能/"},{"name":"实践","slug":"实践","permalink":"http://www.cheshen.wiki/tags/实践/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"探索Python世界","slug":"探索Python世界","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.336Z","comments":true,"path":"2017/04/15/探索Python世界/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/探索Python世界/","excerpt":"本路线共：3门课程 学习人数：6915人在学 章节预览：Python操作MySQL数据库django初体检Python开发简单爬虫","text":"本路线共：3门课程 学习人数：6915人在学 章节预览：Python操作MySQL数据库django初体检Python开发简单爬虫 数据库操作Python操作MySQL数据库 本课程讲解Python如何开发MySQL数据库程序。首先介绍Python开发数据库程序的通用接口规范，然后搭建Python开发数据库程序的开发环境，接着了解了通用接口规范中的connection、cursor两大对象之后，介绍如何增删改查数据库，最后以实例代码演示数据库程序的开发流程。中级·45434人在学 了解Django框架django初体检 Django是PythonWeb网页开发的一个高级的框架，通过Django框架你可以建立一个高性能的web应用而只花费最小的消耗。这种轻盈、强大、灵活的框架让您在设计方案时无需太多考量。本课程主要讲解Django基础内容，让您快速对它有所了解。高级·33169人在学 爬虫技术Python开发简单爬虫 爬虫技术用来从互联网上自动获取需要的数据。课程从对爬虫的介绍出发，引入一个简单爬虫的技术架构，然后通过是什么、怎么做、现场演示三步骤，解释爬虫技术架构中的三个模块。最后，一套优雅精美的爬虫代码实战编写，向大家演示了实战抓取百度百科1000个页面的数据全过程高级·90477人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Python_WEB","slug":"Python-WEB","permalink":"http://www.cheshen.wiki/tags/Python-WEB/"},{"name":"Python爬虫","slug":"Python爬虫","permalink":"http://www.cheshen.wiki/tags/Python爬虫/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"安卓特效合集豪华套餐","slug":"安卓特效合集豪华套餐","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.328Z","comments":true,"path":"2017/04/15/安卓特效合集豪华套餐/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/安卓特效合集豪华套餐/","excerpt":"本路线共：12门课程 学习人数：3438人在学 章节预览：浅谈Android动画Android属性动画赏析Android面试解密-自定义ViewAndroid-Widget桌面小组件Android-打造炫酷进度条Android实现抽奖转盘Android实现卫星菜单千变万化的ViewPager切换动画Android高级特效-索引Android高级特效-3D画廊打造个性的图片预览与多点触控QQ5.0侧滑菜单","text":"本路线共：12门课程 学习人数：3438人在学 章节预览：浅谈Android动画Android属性动画赏析Android面试解密-自定义ViewAndroid-Widget桌面小组件Android-打造炫酷进度条Android实现抽奖转盘Android实现卫星菜单千变万化的ViewPager切换动画Android高级特效-索引Android高级特效-3D画廊打造个性的图片预览与多点触控QQ5.0侧滑菜单 动画和自定义view的那些事浅谈Android动画 通过各式各样的案例，实现各种Android各种炫酷的动画效果，增加用户对Android系统的喜爱，同时也可以培养同学们的学习兴趣。初级·44645人在学 Android属性动画赏析 动画几乎是一个好的App所不可缺少的一部分，它体现了一种更友好的交互方式，在iOS、AndroidL中动画的使用越来越多，特别是后者更是着重强调设计更好的动画。从3.0开始，Android就提供了一种更为强大的属性动画框架。本次课程，将向你介绍如何使用属性动画做出更好的动画中级·32288人在学 Android面试解密-自定义View 课程简介：本课程为Android面试系列课程，短小精悍，切入要害。由Android大神为你详细解答面试最常见的问题，还等什么？快来学吧！可以学到当前各大公司面试中最常见的问题的最完美解答！初级·36885人在学 Android-Widget桌面小组件 AndroidAPP中，常有类似于天气预报、时钟、电量、流量检测等桌面小组件等看着高大上的功能。如何实现的呢？本节课由老师带领大家先引导再基础认知最后综合应用，一步步实现天气预报小例子。初级·24421人在学 实现出来的那些神奇特效Android-打造炫酷进度条 进度条即在应用程序处理任务时，实时的，以图形显示处理任务的速度，完成度，剩余未完成任务量的大小，和可能需要处理时间，一般以长方形条状显示。本门课程将为大家带来各种各样的自定义进度条！为你的APP锦上添花！中级·24872人在学 Android实现抽奖转盘 本课程将教大家通过SurfaceView实现一个Android抽奖转盘，剖析抽奖转盘背后的概率机制。课程涵盖了SurfaceView使用的场景和注意事项以及与View的区别等知识。实现过程中也使用了大量的Canvas绘制相关API，可以帮助大家深入了解和学会使用这些API。中级·22974人在学 Android实现卫星菜单 本课程将带领大家通过自定义ViewGroup结合动画实现一个卫星式菜单，课程涵盖了自定义控件的整个过程，包括自定义属性的定义与获取、控件的测量、布局等相关知识。该菜单效果也包含相当多的传统View动画效果，大家可以对其进行深入理解中级·23029人在学 千变万化的ViewPager切换动画 本课程将带领大家实现个性的ViewPager切换动画，首先介绍通过PageTransformer结合ViewPager.setPageTransformer来实现动画效果，然后教大家如何让其兼容到3.0以后，其中会涉及到属性动画等知识点；最后将介绍通过自定义ViewPager的方式来实现动画切换效果中级·40377人在学 高大上的高级特效Android高级特效-索引 本门课程为小伙伴们带来了一个APP中的熟面孔，索引功能。索引可以在通讯录的右侧实现字母搜索，有效增加了查找的便捷度。是应用中不可缺少的功能，放眼望去，微信，QQ等各大APP中都缺少不了他，还等什么？跟着李宁老师一起学习吧！高级·26984人在学 Android高级特效-3D画廊 本课程将带领大家实现Android画廊特效，常用于各种电影APP展示页。高级·24083人在学 打造个性的图片预览与多点触控 本课程将带领大家通过自定义控件，使用MatrixAPI结合手势检测实现Android自由缩放的图片预览效果。课程采用循序渐进的方式，首先实现图片的自由缩放，然后引入自由移动，最后实现双击放大与缩小的功能。通过该课程，大家可以对Matrix以及手势检测相关API进行深入的学习。高级·19964人在学 QQ5.0侧滑菜单 本课程将带领大家通过自定义控件实现QQ5.0侧滑菜单，课程将循序渐进，首先实现最普通的侧滑菜单，然后引入属性动画与拖动菜单效果相结合，最终实现QQ5.0侧滑菜单效果。通过本课程大家会对侧滑菜单有更深层次的了解，通过自定义控件和属性动画打造千变万化的侧滑菜单效果高级·56729人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://www.cheshen.wiki/tags/Android/"},{"name":"特效","slug":"特效","permalink":"http://www.cheshen.wiki/tags/特效/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"响应式布局那些事","slug":"响应式布局那些事","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.325Z","comments":true,"path":"2017/04/15/响应式布局那些事/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/响应式布局那些事/","excerpt":"本路线共：4门课程 学习人数：15845人在学 章节预览：玩转Bootstrap（基础）玩转Bootstrap（JS插件篇）基于bootstrap的网页开发响应式布局","text":"本路线共：4门课程 学习人数：15845人在学 章节预览：玩转Bootstrap（基础）玩转Bootstrap（JS插件篇）基于bootstrap的网页开发响应式布局 奠定基础玩转Bootstrap（基础） 本Bootstrap教程能够让您了解到，Bootstrap框架是一个非常受欢迎的前端开发框架，他能让后端程序员和不懂设计的前端人员制作出优美的Web页面或Web应用程序。在这个Bootstrap教程中，将带领大家了解Bootstrap框架以及如何使用Bootstrap框架，并且能够独立定制出适合自己的Bootstrap。中级·201323人在学 玩转Bootstrap（JS插件篇） 你可以把这门课程看成是《玩转Bootstrap》的补充篇，带领大家学习怎么使用JS自由控制Bootstrap中提供的组件（插件）。中级·90627人在学 动手实践基于bootstrap的网页开发 Bootstrap是用于前端开发的工具包，提供了优雅的HTML和CSS规范，并基于jQuery开发了丰富的Web组件。课程介绍了Bootstrap框架的基本知识，并基于Bootstrap框架，实现了一个浏览器介绍的单页面网页，同时网页支持移动设备，通过案例的实现让您对Bootstrap有更深入的了解。中级·123881人在学 响应式开发响应式布局 随着移动设备的普及，如何让用户通过移动设备浏览您的网站获得良好的视觉效果，已经是一个不可避免的问题了。本课程介绍了响应式布局，并通过使用Bootstrap前端框架讲解如何进行响应式布局的设计，理论联系实际，有例有据有节操有内涵。高级·87797人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"升职利器","slug":"升职利器","permalink":"http://www.cheshen.wiki/tags/升职利器/"},{"name":"bootstrap","slug":"bootstrap","permalink":"http://www.cheshen.wiki/tags/bootstrap/"},{"name":"前端趋势","slug":"前端趋势","permalink":"http://www.cheshen.wiki/tags/前端趋势/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"小慕感恩计划-实战Hot!!!","slug":"小慕感恩计划-实战Hot!!!","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.329Z","comments":true,"path":"2017/04/15/小慕感恩计划-实战Hot!!!/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/小慕感恩计划-实战Hot!!!/","excerpt":"本路线共：8门课程 学习人数：5581人在学 章节预览：Android-重识ActivityAndroid-深入ActivityAndroid-精通ActivityAndroid-打造万能适配器多种多样的App主界面Tab实现方法AndroidUI模板设计Android5.0新特性-MaterialDesignAndroid-节日短信送祝福(UI篇)Android-节日短信送祝福（功能篇）","text":"本路线共：8门课程 学习人数：5581人在学 章节预览：Android-重识ActivityAndroid-深入ActivityAndroid-精通ActivityAndroid-打造万能适配器多种多样的App主界面Tab实现方法AndroidUI模板设计Android5.0新特性-MaterialDesignAndroid-节日短信送祝福(UI篇)Android-节日短信送祝福（功能篇） 组件？天天见！Android-重识Activity Activity作为Android开发实在是太常见了,但是你真的会用Activity吗？本课程为Activity的系列课程的第一讲，将带大家学习Android中最常用的Activity组件的那些事初级·37470人在学 Android-深入Activity Activity作为Android开发实在是太常见了,但是你真的会用Activity吗？本课程是Activity系列的第2部分，将继续为大家讲解Activity的相关知识中级·26836人在学 Android-精通Activity 带领大家学习Android体系中最常见的Acvitiy组件，深入Activity内部，剖析Activity的生命周期分析以及Framew层的相关介绍高级·37538人在学 UI-一个应用的颜值Android-打造万能适配器 本课程通过对传统的ListView的数据绑定的写法，进行一步一步的抽取与封装，首先设计出一个万能的ViewHolder，再抽取一个CommonAdapter复用多数重复的代码，最后为ViewHolder添加操作控件的能力。最终成功的将原本一堆代码浓缩至几行。中级·30842人在学 多种多样的App主界面Tab实现方法 Tab选项卡几乎成为了App必备的一个功能，它的实现方法也是多种多样，本课程就将讲解迄今为止最主流的4种实现Tab的方法，包括ViewPager、Fragment、FragmentPagerAdapter和ViewPagerIndicator中级·42493人在学 AndroidUI模板设计 UI设计一直是程序设计中非常重要的一环，也是最让人抓狂的一环，好的设计需要不断修改、不断完善，那么我们如何才能减少UI设计中的重复劳动呢、如何在修改设计时减少工作量呢、如何一次开发，重复使用呢？如果你也有这样的疑问，那么本次课程一定会让你获益匪浅。中级·58834人在学 Android5.0新特性-MaterialDesign 2014年10月16日Google正式将Android从KitKat升级为Lollipop，成为Android有史以来最大的一次变革，新增多达5000+个API，在众多的新特性中，其中全新的设计语言MaterialDesign，全新的通知中心设计，以及全新的ART模式最是吸引开发者的眼球，让我们来细细品味其魅力吧高级·33402人在学 实践是检验真理的唯一方法Android-节日短信送祝福(UI篇) 本课程将带领大家实现一个节日短信的应用，课程中包含了TabLayout、FloatingActionButton等design库控件的使用以及如何如何发送短信，监听短信的发送状态等。最后在短信列表部分展示了如何使用LoaderManager及其相关的机制优雅的异步加载数据。中级·18461人在学 Android-节日短信送祝福（功能篇） 本课程将带领大家实现一个节日短信的应用，课程中包含了TabLayout、FloatingActionButton等design库控件的使用以及如何如何发送短信，监听短信的发送状态等。最后在短信列表部分展示了如何使用LoaderManager及其相关的机制优雅的异步加载数据。中级·15170人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"Android面试","slug":"Android面试","permalink":"http://www.cheshen.wiki/tags/Android面试/"},{"name":"Android热门","slug":"Android热门","permalink":"http://www.cheshen.wiki/tags/Android热门/"},{"name":"自定义UI","slug":"自定义UI","permalink":"http://www.cheshen.wiki/tags/自定义UI/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"带你玩转Yii框架","slug":"带你玩转Yii框架","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.330Z","comments":true,"path":"2017/04/15/带你玩转Yii框架/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/带你玩转Yii框架/","excerpt":"本路线共：5门课程 学习人数：3760人在学 章节预览：与《Yii框架》不得不说的故事—基础篇与《Yii框架》不得不说的故事—高效篇与《Yii框架》不得不说的故事—安全篇与《Yii框架》不得不说的故事—扩展篇与《Yii框架》不得不说的故事—工具篇","text":"本路线共：5门课程 学习人数：3760人在学 章节预览：与《Yii框架》不得不说的故事—基础篇与《Yii框架》不得不说的故事—高效篇与《Yii框架》不得不说的故事—安全篇与《Yii框架》不得不说的故事—扩展篇与《Yii框架》不得不说的故事—工具篇 初探YII框架与《Yii框架》不得不说的故事—基础篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习YII的安装和mvc的基本使用方式，为后面学习YII的快速、安全、专业的特性打下基础。高级·29705人在学 深入YII的三大特性与《Yii框架》不得不说的故事—高效篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习YII如何提升程序运行效率以及开发效率。高级·16940人在学 与《Yii框架》不得不说的故事—安全篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习XSS、CSRF、SQL注入、文件上传漏洞等攻击方式，以及YII框架对它们的防范和处理方式。高级·13109人在学 与《Yii框架》不得不说的故事—扩展篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习模块、事件机制、mixin以及依赖注入技术，可以让程序拥有更好的扩展性，更能够适应需求的变化。高级·12010人在学 提升逼格来看看YII开发工具与《Yii框架》不得不说的故事—工具篇 YII是目前比较火的框架，框架里面使用了最新的技术和设计，可以说学习了YII就学习了最新的php技术，本课程主要学习在开发项目中常用的一些工具，主要包括Composer、Debug和GII等，使用这些工具可以大大提高了我们的开发效率。高级·15849人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"php","slug":"php","permalink":"http://www.cheshen.wiki/tags/php/"},{"name":"Yii","slug":"Yii","permalink":"http://www.cheshen.wiki/tags/Yii/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"快速搞定PHP第三方登录","slug":"快速搞定PHP第三方登录","date":"2017-04-14T17:29:43.000Z","updated":"2017-04-14T17:29:43.332Z","comments":true,"path":"2017/04/15/快速搞定PHP第三方登录/","link":"","permalink":"http://www.cheshen.wiki/2017/04/15/快速搞定PHP第三方登录/","excerpt":"本路线共：3门课程 学习人数：2992人在学 章节预览：PHP第三方登录—OAuth2.0协议PHP第三方登录—微博登录PHP第三方登录—QQ登录","text":"本路线共：3门课程 学习人数：2992人在学 章节预览：PHP第三方登录—OAuth2.0协议PHP第三方登录—微博登录PHP第三方登录—QQ登录 认识Oauth协议PHP第三方登录—OAuth2.0协议 本课程主要介绍第三方登录相关协议—OAuth2.0协议。主要介绍了OAuth的使用场景和实现原理，并结合实际讲解了OAuth2.0协议使用的注意事项，非常有实用价值。高级·25858人在学 实战演练PHP第三方登录—微博登录 想使用最简单的方法为我们的Web应用获取新用户，你绝对不应该错过本门课程。本课程带领大家掌握使用微博开放平台提供的SDK快速接入微博开放平台，迅速获取海量用户。高级·16534人在学 PHP第三方登录—QQ登录 想使用最简单的方法为我们的Web应用获取新用户，你绝对不应该错过。使用QQ互联官方提供的SDK快速接入QQ互联开放平台，迅速获取海量用户。高级·32844人在学 本路径来自慕课网，由程序员的梦工厂整理及发布。 官方唯一QQ群：300421872 未来的你会感谢现在拼命努力的自己。","categories":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www.cheshen.wiki/tags/PHP/"},{"name":"OAUTH","slug":"OAUTH","permalink":"http://www.cheshen.wiki/tags/OAUTH/"}],"keywords":[{"name":"学习路线","slug":"学习路线","permalink":"http://www.cheshen.wiki/categories/学习路线/"}]},{"title":"RabbitMQ教程之一：安装及简介","slug":"RabbitMQ教程之一：安装及简介","date":"2017-04-01T18:03:11.000Z","updated":"2017-04-15T06:10:04.755Z","comments":true,"path":"2017/04/02/RabbitMQ教程之一：安装及简介/","link":"","permalink":"http://www.cheshen.wiki/2017/04/02/RabbitMQ教程之一：安装及简介/","excerpt":"RabbitMQ到底是什么？RabbitMQ是一个程序与程序之间通信的方法，或者可以理解为一种专用的通道，专门用来负责消息的读取和写入。应用程序通过在RabbitMQ中读写消息来通信，程序与程序之间无需专门的链接，而是直接通过RabbitMQ来进行数据的读写。RabbitMQ将会采用异步的方式来分发消息，是一种经典的生产者与消费者的模式，多个消费者由RabbitMQ来负责协调，并且保证每一条消息都能得到可靠的执行。假如一条消息在执行过程中出现了错误，RabbitMQ并不会放弃这条消息，而是专由其他的消费者来处理这条消息。","text":"RabbitMQ到底是什么？RabbitMQ是一个程序与程序之间通信的方法，或者可以理解为一种专用的通道，专门用来负责消息的读取和写入。应用程序通过在RabbitMQ中读写消息来通信，程序与程序之间无需专门的链接，而是直接通过RabbitMQ来进行数据的读写。RabbitMQ将会采用异步的方式来分发消息，是一种经典的生产者与消费者的模式，多个消费者由RabbitMQ来负责协调，并且保证每一条消息都能得到可靠的执行。假如一条消息在执行过程中出现了错误，RabbitMQ并不会放弃这条消息，而是专由其他的消费者来处理这条消息。 RabbitMQ和Celery到底有什么区别？上面我们已经提到过，RabbitMQ是负责消息的生产和消费，我们可以理解为，RabbitMQ是一个仓库的中转站，所有的程序消息都发送给RabbitMQ，然后由RabbitMQ来负责把这些消息来运输给消费者。但是RabbitMQ的侧重点在于，消息的读写。比如说我们有一个仓库A，我想把仓库A里面的全部货物，经过不同的路线，最终运输到仓库B里面。如果我们使用RabbitMQ，是可以完成这种操作，但是这其中包含了大量复杂的逻辑，我们需要自己去写。于是有人就提供了一种现成的方案，那就是Celery。 Celery主要负责的就是异步的任务队列，它本身不提供任何数据的存取，只关注如何把数据，异步，安全，高效，可靠的运输到另一个地点，并且在对方处理完成以后，再把响应数据通知给对应的方法。 我们拿爬虫来讲，假如我要爬一个网站A，如果按照正常的逻辑。发送一个请求到网站A，然后网站A收到了我的请求，把响应的页面传给我，我再负责解析。这其中就包含了一个问题，比如说A网站的服务器很卡，在我发送数据以后，到他处理完成，这段过程用了三四秒的时间。那么这段时间我的程序一直是处于一种等待状态，等待响应的完成，这样就造成了大量的资源浪费。 使用Celery的好处就是，在我们请求发送出去以后，Celery就立刻开始去发送下一个任务，它会把所有的任务都快速的发送出去，并不等待任务响应完成。当某一个任务响应回来时，Celery再去通知具体的人来处理响应的数据，然后继续分发任务。 所以RabbitMQ和Celery最大区别就是，RabbitMQ提供了一种可靠的消息存取的服务，而Celery负责高效的分发这些消息。 在Ubuntu安装RabbitMQ这里我使用的是vultr的云主机，在之前的文章中有介绍如何注册创建vultr云主机，不会的请戳链接，这里将不再介绍任何关于创建和连接的问题，当然也可以使用自己本地的虚拟机或者是其他的云服务器，如阿里云，谷歌云。 这里我们使用的是Ubuntu 14.04 x64版本的 首先为了避免各种签名错误，我们把公钥加入可信任的列表： 12wget http://www.rabbitmq.com/rabbitmq-signing-key-public.ascsudo apt-key add rabbitmq-signing-key-public.asc 当我们看到控制台显示： OK 说明我们导入公钥成功。 然后我们开始更新和安装RabbitMQ： 12sudo apt-get updatesudo apt-get install rabbitmq-server 当控制台询问我们是否安装的时候，输入y然后回车。 当看到结尾出现如下信息说明安装成功： Adding group rabbitmq&#39; (GID 110) ... Done. Adding system userrabbitmq’ (UID 105) …Adding new user rabbitmq&#39; (UID 105) with grouprabbitmq’ …Not creating home directory `/var/lib/rabbitmq’. Starting message broker rabbitmq-server [ OK ]Processing triggers for libc-bin (2.19-0ubuntu6.11) …Processing triggers for ureadahead (0.100.0-16) … RabbitMQ安装成功以后，会建立一个默认的guest账户，用户名和密码都是guest。我们在shell里面输入rabbitmqctl status可以查看RabbitMQ的运行情况。 看到如下输出，说明我们RabbitMQ已经成功运行： 输入rabbitmqctl stop将关闭RabbitMQ服务器，看到如下信息说明关闭成功： Stopping and halting node rabbit@chenshen ……done. 此时再次输入rabbitmqctl status，将会看到如下错误信息提示我们没有运行RabbitMQ： 那么我们如何启动RabbitMQ呢，有些同学可能会想，肯定是输入rabbitmqctl start。不过很可惜，RabbitMQ并不是依靠这种方式来启动的，而是使用另一个命令：rabbitmq-server -detached，参数-detached是使用守护进程在后台运行，如果不加此参数，则关闭命令行后RabbitMQ会自动退出。 运行以后我们会得到一个警告： Warning: PID file not written; -detached was passed. 需要注意的是，这个警告是正常的警告，并非是异常信息，如果不放心可以查看RabbitMQ的运行日志和错误日志： 12cat /var/log/rabbitmq/startup_logcat /var/log/rabbitmq/startup_err 看到这种如下信息，说明我们启动正常： 需要注意的是，上面的警告信息是正常的，并非是我说的，而是官方文档说的： Options -detached Start the server process in the background. Note that this will cause the pid not to be written to the pid file.For example:rabbitmq-server -detachedRuns RabbitMQ AMQP server in the background. 大概的意思就是，如果我们加了-detached参数在后台运行的话，这会让pid不能被写入pid文件。 Hello World程序员惯例，什么都先来一个Hello World。 安装pika我们只是安装了RabbitMQ，但是我们如果想要在Python中使用，就需要安装具体的库： RabbitMQ使用的是AMQP协议。要使用它，你就必须需要一个使用同样协议的库。 py-amqplibtxAMQPpika 官方文档中，使用的pika，所以我们也使用pika。 警告：需要注意的是，此时我们是在另一台电脑安装，并非在服务器安装！ 我使用的是Windows10操作系统，Python版本为3.5，请大家保持同步。 使用下面的命令安装： 1pip install pika -i http://pypi.douban.com/simple/ 看到如下信息说明安装成功： Successfully installed pika-0.10.0 注意：我这里默认安装最新的，是0.10.0版本，随着时间的推移，可能会有较大的变化，如果大家哪天发现按照本文无法正常操作，有可能是版本升级的问题。此时，大家可以这么做： 12pip uninstall pikapip install pika==0.10.0 -i http://pypi.douban.com/simple/ 卸载后，指定安装版本。 终于要开始了我们在远程连接RabbitMQ之前，需要新建一个用于远程连接的用户，默认的guest用户只接受127.0.0.1的本地连接。 警告：此时我们的操作又是在服务器了！ 12* 查看用户列表sudo rabbitmqctl list_users 可以看到，我们只有一个默认的guest用户，它的权限是administrator。 警告兼友情提示：下面的命令不要直接复制，因为中文编码和shell的编码不一样，你直接在上面改会造成，看似没有字符，实际上还有一些中文字符编码在里面，导致你到时候用户名不是你建的用户名，而是有一些你看不到的编码在里面。当然，这种可能性非常小，但是直接复制报错的几率是很大的，因为你没把字符编码删干净，聪明的人都知道在本地的文本文档改好，然后再复制运行。 12345678910* 创建用户，如果你连用户名和密码改成自己想设置的都不知道，我不建议你学编程了sudo rabbitmqctl add_user 用户名 密码* 查看一下有没有创建成功，可以看到新建了一个用户cheshen[]，他的权限为空sudo rabbitmqctl list_users* 赋予超级管理员权限，这个用户名一看就是你上面建的好伐sudo rabbitmqctl set_user_tags 用户名 administrator* 再次查看sudo rabbitmqctl list_users* 最重要的一步，设置监听请求的地址rabbitmqctl set_permissions -p &quot;/&quot; 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot; Listing users …cheshen [administrator]guest [administrator]…done. 终于可以写代码了！！！ 开始写代码本地Windows环境了 新建文件send.py 123456789101112131415161718192021222324252627282930#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2017-04-02 01:20:41# @Author : 车神 (meteorshield@gmail.com)# @Link : http://www.cheshen.wiki# @Version : $Id$import pika# 就是我们刚才创建的那个credentials = pika.PlainCredentials('用户名', '密码')parameters = pika.ConnectionParameters(credentials=credentials)parameters = pika.ConnectionParameters('服务器IP',5672,'/',credentials) connection = pika.BlockingConnection(parameters)channel = connection.channel()channel.queue_declare(queue='hello')print(' [*] Waiting for messages. To exit press CTRL+C')def callback(ch, method, properties, body): print(\" [x] Received %r\" % (body,))channel.basic_consume(callback, queue='hello', no_ack=True)channel.start_consuming() 新建receive.py 12345678910111213141516171819202122232425262728#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2017-04-02 01:20:41# @Author : 车神 (meteorshield@gmail.com)# @Link : http://www.cheshen.wiki# @Version : $Id$import pikacredentials = pika.PlainCredentials('用户名', '密码')parameters = pika.ConnectionParameters(credentials=credentials)parameters = pika.ConnectionParameters('服务器IP',5672,'/',credentials) connection = pika.BlockingConnection(parameters)channel = connection.channel()channel.queue_declare(queue='hello')print(' [*] Waiting for messages. To exit press CTRL+C')def callback(ch, method, properties, body): print(\" [x] Received %r\" % (body,))channel.basic_consume(callback, queue='hello', no_ack=True)channel.start_consuming() 在本地的控制台输入： python send.py 然后会看到： [x] Sent ‘Hello World.’ 启动另一个命令行再输入： python receive.py 然后会看到： [*] Waiting for messages. To exit press CTRL+C [x] Received b’Hello World.’ 这个进程并不会退出，而是等待我们发送新的信息，再次运行python send.py可以看到receive的窗口再次输出信息。 运行可能会报错：pika.exceptions.ConnectionClosed 这是因为我们的服务器在美国，连接超时了，多次连接，或者开启系统代理就可以了。 多来几次就可以了 下章我们详细解释这些方法都是干啥的。 后记感谢大家的支持，本文原创作者：秋名山车神 转载请注明出处，大家有任何的问题，都可以通过我博客上的联系方式与我取得联系。 大家如果觉得本文对你有帮助，觉得车神熬夜写博客令你感动的话~可以点击下方的赞来小额打赏一下~ END","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"Celery","slug":"Celery","permalink":"http://www.cheshen.wiki/tags/Celery/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"http://www.cheshen.wiki/tags/RabbitMQ/"},{"name":"异步","slug":"异步","permalink":"http://www.cheshen.wiki/tags/异步/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"使用vultr+bbr搭建高速科学上网ss","slug":"使用vultr+bbr搭建高速科学上网ss","date":"2017-03-30T16:30:46.000Z","updated":"2017-04-15T06:09:58.588Z","comments":true,"path":"2017/03/31/使用vultr+bbr搭建高速科学上网ss/","link":"","permalink":"http://www.cheshen.wiki/2017/03/31/使用vultr+bbr搭建高速科学上网ss/","excerpt":"vultr的优势便宜这可能是它最大的特点，最便宜的主机只需要2.5美元一个月，而且提供多国节点。值得一提的是，并非是一次性扣费，而是按小时来收费，一个月收够2.5美元的价格。如果这句理解不动请多看几遍~ 使用方便本人亲测，从注册，到付款，到创建实例，到登录，到配置一切，全程无任何坑，方便快捷，任何一个新手都能自己部署好。 速度快本人平时采用多种翻墙方式，但都不给力，不过按照此步骤配置完以后，访问Google商店安装应用速度在2M一秒。值得一提的是，我住的地方平时迅雷下载国内才1M多。 前提是配置了Google的bbr，这个是完全免费的，bbr是拥塞算法加速TCP。 废话不多说，往下看。","text":"vultr的优势便宜这可能是它最大的特点，最便宜的主机只需要2.5美元一个月，而且提供多国节点。值得一提的是，并非是一次性扣费，而是按小时来收费，一个月收够2.5美元的价格。如果这句理解不动请多看几遍~ 使用方便本人亲测，从注册，到付款，到创建实例，到登录，到配置一切，全程无任何坑，方便快捷，任何一个新手都能自己部署好。 速度快本人平时采用多种翻墙方式，但都不给力，不过按照此步骤配置完以后，访问Google商店安装应用速度在2M一秒。值得一提的是，我住的地方平时迅雷下载国内才1M多。 前提是配置了Google的bbr，这个是完全免费的，bbr是拥塞算法加速TCP。 废话不多说，往下看。 注册vultr首先点击连接进入vultr官网，看到的界面是这样的(大家如果看车神写作辛苦，就可以使用本文的连接来进行注册，车神会得到来自于网站推广的分成用来续费服务器，这是网站单独给的，大家并不会有任何的损失~)： 然后我们输入邮箱和密码，需要注意的是，密码必须是字母大小写，数字，特殊符号混合的才可以，不然会提示密码安全级别不够。 当这个网站抽风的时候，你还可能会跳转到此页面，并且看到如下错误提示，不要担心，再输入一次邮箱和你的密码，当所有的提示都变成绿色对号，就可以创建了： 然后会跳转到登录界面，输入你的账号密码和验证码，然后点击Login： 如果你一直被提示登录失败，你可能需要手动点一下页面上的login连接跳转到一个新的login界面，再次登录就可以了。 稍等一会邮箱会收到一封激活邮件，直接点击链接验证邮箱就可以了(如果你连点击Verify Your E-mail这个按钮都不会，就可以不用往下看了)： 至此，我们成功创建并激活了账户： 然后就是选择付款方式了，这个网站需要先充值，然后再开通实例。你可以选择信用卡或者是PayPal支付，我使用的是PayPal，信用卡按照上面的提示输入自己的卡号，信用卡背面的三位数字和有效期就可以完成付款。 最低充值5美元，PayPal也是如此，我相信既然想看看外面的世界，付款这一步应该难不倒你…跟支付宝微信添加信用卡没啥区别。 Paypal就简单了，选择充值金额，然后点击按钮就可以了，注意需要勾选那个同意协议： 付款成功以后，可能会得到一个提示，说账户需要验证，等待24个小时之类的话，因为我们在China，所以你懂得。 我当时等了大概12个小时，账号才能使用。 ps: 验证过程点哪里都只能看到它页面上的一段英文，然后别的什么都不会显示，所以一次最好充个10美金，不然每次都麻烦~ 创建实例经过漫长的等待，你的账号可能终于正常登陆了，当然也可能你比较幸运，没有经过验证的环节： 我建议大家按照我的选择，2.5美元的我没试过，听别人说速度很慢，不知道真假。还有系统，吸顶要选择Ubuntu 14.04 x64版本的。 然后往下拉滚动条，别的都不用填，就填个主机名就行了，随便填Enter server hostname，就是方便以后你创建的服务器多了，自己能区分哪个是哪个的标识符： 然后我们点击Deploy New，等待一会，创建需要几十秒，当看到Status为Running说明创建成功了： 然后我们点后面的三个点，就可以进入详情界面，然后查看密码，就可以使用远程登录工具，或者ssh命令来登录了，这里我使用的是Windows环境，用的是xshell5来连接： 主机就是刚刚创建的服务器的IP，详情页里有显示，点击确定就可以了，然后输入用户名是root，密码页面也有，复制就好了，继续点确定就登录成功了。 如果你是Mac系统或者是Linux系统就可以直接使用：ssh root@创建服务器的IP地址 然后输入密码就可以成功连接了。 安装配置Shadowsocks不知道这是个啥的，可以自行百度一下~ 它分为客户端和服务端，主要是用来建立一个安全可靠的专用通道的，这里我们在服务器搭建服务端： 1234567891011121314* 更新sudo apt-get update * 安装python的pipsudo apt-get install python-pip* 安装Shadowsocks的加密混淆库sudo apt-get install python-setuptools m2crypto* 安装vim编辑器sudo apt-get install vim-gtk * 安装gitsudo apt-get install git* 安装Shadowsocks 我们这里从原作者的Github库直接安装pip install git+https://github.com/shadowsocks/shadowsocks.git@master* 再次更新sudo apt-get update 全部安装完成以后，我们就可以在任意一个目录，我选择在当前目录创建一个Shadowsocks配置文件： 1vim shadowsocks.json 内容如下： 1234567&#123; &quot;server&quot;:&quot;服务器的ip地址&quot;, &quot;server_port&quot;:443, &quot;password&quot;:&quot;最好设置个数字密码&quot;, &quot;timeout&quot;:600, &quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 然后使用命令运行： 1234* 启动ssserver -c shadowsocks.json -d start* 如果你想停止ssserver -c shadowsocks.json -d stop 看到这种输出信息，代表运行成功： INFO: loading config from shadowsocks.json2017-03-30 16:06:16 INFO loading libcrypto from libcrypto.so.1.0.0started 客户端连接Windows客户端：https://github.com/shadowsocks/shadowsocks-windows/releases 这里可以找到Windows最新的客户端，往下看，找到Downloads，然后找到一个Shadowsocks-3.4.3.zip压缩包，也可以直接点击本博客的地址下载。 Mac客户端：https://github.com/shadowsocks/shadowsocks-iOS/releases 也可以点击ShadowsocksX-2.6.3.dmg下载 然后我们直接打开文件运行： 右键选择任务栏小飞机的图标，选择服务器，选择编辑服务器，然后填写： 服务器地址，端口，密码，加密方式都要使用我们刚才配置文件里设置的。 然后右键任务栏的小图标，选择启动系统代理就可以了。 访问：谷歌看看能不能正常打开。 在开始bbr加速之前，先打开YouTube看看视频，或者下载几个东西，看看网速，方便一会对比天和地的差距。 开启TCP BBR加速 下载安装包: wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.9.10/linux-image-4.9.10-040910-generic_4.9.10-040910.201702141931_amd64.deb 安装: dpkg -i linux-image-4.9.10-040910-generic_4.9.10-040910.201702141931_amd64.deb 查看当前系统中都有哪些内核: dpkg -l | grep linux-image 删除旧的内核，我这里的旧内核版本是3.13，所以执行: apt-get purge .*3.13.*，需要注意的是，虽然大家安装的是同一个实例，但是内核版本不一定相同，大家一定要自行区分，上面的命令查看到的大部分相同的数字，就是版本号，只需要把3.13改成自己的版本号就可以了。剩下的.*是正则表达式匹配全部，放心大胆的删。 步骤4完成后再执行步骤3会发现只剩下4.9.10的内核了 更新引导： update-grub 重启: reboot 编辑/etc/sysctl.conf， 在文件末尾加上下面两行 12net.core.default_qdisc=fqnet.ipv4.tcp_congestion_control=bbr 保存退出后执行sysctl -p使配置生效 .执行lsmod | grep bbr, 如果看到tcp_bbr则说明启用成功 上面的步骤都经过测试，大家不要害怕，复制回车就可以了，有的安装和删除需要输入y来确认，还有一点就是内核版本号不一定一样，但是大家如果都跟我一样选择的是Ubuntu的14.04 x64 应该是一样的。 至此，大家已经完全部署成功并且使用了bbr加速，大家体验非一般的感觉吧。 谷歌浏览器安装插件为了方便使用和切换代理，以便国内网站可以不用代理访问： 大家自行前往谷歌应用商店安装浏览器插件：SwitchyOmega 然后自己配置： 点安装好的插件，选择选项，然后新建： 名字随便起，先新建一个代理服务器。 点了确定以后，代理协议选择SOCKS5，代理服务器输入127.0.0.1，端口1080。 然后再新建一个自动切换模式，默认使用直接连接，然后点一下浏览器右上角的小图标，选择你刚刚创建的自动切换的模式，就可以开始访问网站了~ 首先访问任意被墙网站，选择右上角的小图标，点击添加条件： 情景模式选择你刚才新建的代理服务器的名称，点击添加条件，就可以了~ 后记感谢大家的支持，本文原创作者：秋名山车神 转载请注明出处，大家有任何的问题，都可以通过我博客上的联系方式与我取得联系。 大家如果觉得本文对你有帮助，可以点击下方的赞来小额打赏一下~ END","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"http://www.cheshen.wiki/tags/Shadowsocks/"},{"name":"bbr","slug":"bbr","permalink":"http://www.cheshen.wiki/tags/bbr/"},{"name":"vultr","slug":"vultr","permalink":"http://www.cheshen.wiki/tags/vultr/"},{"name":"科学上网","slug":"科学上网","permalink":"http://www.cheshen.wiki/tags/科学上网/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"Ubuntu安装postgresql","slug":"Ubuntu安装postgresql","date":"2017-03-29T14:49:10.000Z","updated":"2017-04-15T06:10:01.917Z","comments":true,"path":"2017/03/29/Ubuntu安装postgresql/","link":"","permalink":"http://www.cheshen.wiki/2017/03/29/Ubuntu安装postgresql/","excerpt":"环境：Ubuntu-16.04-64bit 首先更换中科大的Ubuntu源： 网址：https://mirrors.ustc.edu.cn/help/ubuntu.html","text":"环境：Ubuntu-16.04-64bit 首先更换中科大的Ubuntu源： 网址：https://mirrors.ustc.edu.cn/help/ubuntu.html 直接编辑 /etc/apt/sources.list 文件（需要使用 sudo）。以下是 Ubuntu 16.04 参考配置内容： 12345678910111213# 默认注释了源码仓库，如有需要可自行取消注释deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 参考命令： 注意是在/etc/apt/目录下，一下命令都要使用root账户操作，或加sudo。 mv sources.list sources.list.back vim sources.list 然后粘贴上面的内容 apt-get update 一切无误没有报错继续进行，报错先排查错误，不行就把sources.list.back文件重新恢复回去。 apt-get install postgresql 稍等一会，提示安装完成： 输入 sudo -i -u postgres psql 然后进入postgresql的命令行界面 看到命令行显示postgres=#，说明我们进入了postgresql的命令行界面 接着输入 \\password postgres 提示我们输入一个新的密码 Enter new password: 随便输入你的密码Enter it again: 再次输入你的密码 回车以后就可以了 然后输入\\q退出命令行界面，再输入exit退出到系统用户界面。 接着可以在windows上安装Python项目所需要的依赖，首先新建虚拟环境： 123virtualenv --no-site-packages --python=C:\\Dream\\Python\\Python27\\python.exe xuemc如果没有安装virtualenv，需要先进行安装：pip install virtualenv 使用pip安装项目依赖的环境： pip install -r requirement.txt -i https://pypi.doubanio.com/simple/ 此处我们使用豆瓣的镜像，速度会提升很多 如果在Linux安装过程中报错，请尝试安装下面的依赖包 sudo apt-get install libxml2-dev libxslt1-dev python-dev sudo apt-get install libpq-dev sudo apt-get install libxml2 sudo apt-get install libjpeg-dev 如果还不行，可以自行查找错误","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/tags/Linux/"},{"name":"postgresql","slug":"postgresql","permalink":"http://www.cheshen.wiki/tags/postgresql/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"Linux 进程管理工具：supervisor","slug":"Linux 进程管理工具：supervisor","date":"2017-03-29T14:49:10.000Z","updated":"2017-04-15T06:09:37.218Z","comments":true,"path":"2017/03/29/Linux 进程管理工具：supervisor/","link":"","permalink":"http://www.cheshen.wiki/2017/03/29/Linux 进程管理工具：supervisor/","excerpt":"supervisor简介在Linux服务器中，有时候我们需要一个进程需要可靠的在后台运行，并且能够监控进程状态，在意外结束时能够自动重启等。此时就可以使用supervisor。 supervisor 是使用Python开发的一套通用的进程管理程序，能够将一个普通的命令行进程变成后台的守护进程，并且监控进程的状态，异常退出时能够自动重启。","text":"supervisor简介在Linux服务器中，有时候我们需要一个进程需要可靠的在后台运行，并且能够监控进程状态，在意外结束时能够自动重启等。此时就可以使用supervisor。 supervisor 是使用Python开发的一套通用的进程管理程序，能够将一个普通的命令行进程变成后台的守护进程，并且监控进程的状态，异常退出时能够自动重启。 安装supervisor在Ubuntu中可以使用apt-get来安装： 1sudo apt-get install supervisor 如果安装缓慢，可以更换中科大的源： https://mirrors.ustc.edu.cn/help/ubuntu.html 配置安装完成以后，我们需要编写一个配置文件，让supervisor来管理它。每个进程的配置文件都可以单独拆分，放在/etc/supervisor/conf.d/目录下，以.conf作为扩展名。 1234# 首先进入/etc/supervisor/conf.d目录/etc/supervisor/conf.d# 使用supervisor自带的命令生成模板echo_supervisord_conf &gt; foo.conf 编辑模板，在开头添加以下内容： 12[program:foo]command=/bin/cat [program:app] ： 定义进程app command ： 命令 directory ： 进程的当前目录 user ： 进程运行的用户身份 详细配置说明： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071;*为必须填写项;*[program:应用名称][program:cat];*命令路径,如果使用python启动的程序应该为 python /home/test.py, ;不建议放入/home/user/, 对于非user用户一般情况下是不能访问command=/bin/cat;当numprocs为1时,process_name=%(program_name)s;当numprocs&gt;=2时,%(program_name)s_%(process_num)02dprocess_name=%(program_name)s;进程数量numprocs=1;执行目录,若有/home/supervisor_test/test1.py;将directory设置成/home/supervisor_test;则command只需设置成python test1.py;否则command必须设置成绝对执行目录directory=/tmp;掩码:--- -w- -w-, 转换后rwx r-x w-xumask=022;优先级,值越高,最后启动,最先被关闭,默认值999priority=999;如果是true,当supervisor启动时,程序将会自动启动autostart=true;*自动重启autorestart=true;启动延时执行,默认1秒startsecs=10;启动尝试次数,默认3次startretries=3;当退出码是0,2时,执行重启,默认值0,2exitcodes=0,2;停止信号,默认TERM;中断:INT(类似于Ctrl+C)(kill -INT pid),退出后会将写文件或日志(推荐);终止:TERM(kill -TERM pid);挂起:HUP(kill -HUP pid),注意与Ctrl+Z/kill -stop pid不同;从容停止:QUIT(kill -QUIT pid);KILL, USR1, USR2其他见命令(kill -l),说明1stopsignal=TERMstopwaitsecs=10;*以root用户执行user=root;重定向redirect_stderr=falsestdout_logfile=/a/pathstdout_logfile_maxbytes=1MBstdout_logfile_backups=10stdout_capture_maxbytes=1MBstderr_logfile=/a/pathstderr_logfile_maxbytes=1MBstderr_logfile_backups=10stderr_capture_maxbytes=1MB;环境变量设置environment=A=&quot;1&quot;,B=&quot;2&quot;serverurl=AUTO 启动如果编辑默认的supervisor.conf，则需要重启supervisor使配置文件生效： 1supervisorctl reload 然后运行下面的命令启动进程： 1supervisorctl start foo 如果运行出现如下错误： 1unix:///var/run/supervisor.sock no such file 可以运行下面的命令，然后再次启动： sudo touch /var/run/supervisor.socksudo chmod 777 /var/run/supervisor.socksudo service supervisor restart 看到如下信息，说明运行成功： foo: started 也可以输入12345678910&gt; foo RUNNING pid 6665, uptime 0:08:08在supervisor的控制台输入help可以获取帮助信息，输入status可以获取当前运行的进程信息，输入exit可以退出supervisor的控制台界面。## 关闭使用下面的命令就可以关闭supervisor启动的进程： supervisorctl stop foo123456789101112可以看到输出信息：&gt; foo: stopped## 常用命令&gt;更新新的配置到supervisord&gt;&gt; supervisorctl update1234&gt;&gt;重新启动配置中的所有程序&gt;&gt; supervisorctl reload 1234&gt;&gt;启动某个进程(program_name=你配置中写的程序名称)&gt;&gt; supervisorctl start program_name 1234&gt;&gt;查看正在守候的进程(同时进入控制台)&gt;&gt; supervisorctl 1234&gt;&gt;停止某一进程 (program_name=你配置中写的程序名称)&gt;&gt; pervisorctl stop program_name 1234&gt;&gt;重启某一进程 (program_name=你配置中写的程序名称)&gt;&gt; supervisorctl restart program_name 1234&gt;&gt;停止全部进程&gt;&gt; supervisorctl stop all``` 更多内容可以参考：supervisor官方文档","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.cheshen.wiki/tags/Linux/"},{"name":"supervisor","slug":"supervisor","permalink":"http://www.cheshen.wiki/tags/supervisor/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"Python装饰器进阶之一","slug":"Python装饰器进阶之一","date":"2017-03-12T10:22:31.000Z","updated":"2017-04-15T06:09:46.084Z","comments":true,"path":"2017/03/12/Python装饰器进阶之一/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/Python装饰器进阶之一/","excerpt":"先看例子网上有很多装饰器的文章，上来说半天也没让人看明白装饰器到底是个什么，究竟有什么用，我们直接来看几个例子。 Python递归求斐波那契数列 12345def fibonacci(n): if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci(50)) 这是一个很常见的求斐波那契数列的例子，但是这其中有非常多的重复计算。","text":"先看例子网上有很多装饰器的文章，上来说半天也没让人看明白装饰器到底是个什么，究竟有什么用，我们直接来看几个例子。 Python递归求斐波那契数列 12345def fibonacci(n): if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci(50)) 这是一个很常见的求斐波那契数列的例子，但是这其中有非常多的重复计算。 如：我们要计算第10位数字是多少，就要先计算出第9位数字是多少，并且是从0计算到9。此时我们已经计算过0-9位数字的值，甚至已经知道第10位数字的值，但是当计算第11位的时候却又要重复一遍。也就是说我们如果计算第50位数字是多少，就要先计算0-1,0-2,0-3 … 0-48,0-49,0-50。数字越大，重复的计算就越多。上面的程序有兴趣的可以运行一下，我等待了五分钟没有出结果就强行在任务管理器关闭了。 略微修改一下 12345678910111213141516# 增加一个缓存字典def fibonacci(n, cache=None): # 第一次没有任何缓存，初始化字典 if cache is None: cache = &#123;&#125; # 如果n这个数字，是我们已经计算过的，就不需要再去递归从头计算了 if n in cache: return cache[n] if n &lt;= 1: return 1 # 如果缓存没有，就把它增加到缓存中去 cache[n] = fibonacci(n - 1, cache) + fibonacci(n - 2, cache) return cache[n]print(fibonacci(50)) 运行结果： 20365011074[Finished in 0.1s] 前面运行五分钟没有任何结果，而简单修改以后仅仅用了0.1秒，可见重复计算对性能的影响用几何倍数称呼都不为过。 思考： 这种重复计算的问题，在我们的项目中是非常常见的，特别是一些计算概率的方法，都需要重复计算。那么我们总不能每个方法都这样改写一次吧？那样我们的项目中会包含大量的冗余代码，不利于我们的维护，也违背了我们高内聚，低耦合的编程思想。那我们能否实现，只用写一个增加缓存的方法，然后其他的方法我们都使用这个方法来装饰它，让它拥有这个功能。 实现思路： 写一个方法假设方法名为add_cache，该方法拥有缓存 add_cache接收一个参数，参数就是原方法的对象 在add_cache方法内部，有一个wrap方法，该方法就接收原来fibonacci方法的参数 wrap方法首先判断参数是否在缓存中，如果在，就直接返回缓存中的值 如果不在缓存中就调用原来的fibonacci方法计算然后把值保存在缓存中 在add_cache中返回新的wrap方法的对象 举个栗子 12345678910111213141516171819202122232425262728# 装饰方法def add_cache(func): cache = &#123;&#125; # 因为方法可能不是都只有一个参数，所以我们使用这种形式可以接收任意个参数 # wrap可以随便起名的，还有add_cache都是随便起名字不是固定的 def wrap(*args): # 如果这些参数不在cache中 if args not in cache: # 调用原方法，并且把这些参数对应的值存储在cache中 # 需要注意的是，传递给原方法我们要把元组形式的args拆分成单个参数 cache[args] = func(*args) # 在cache中就直接返回 return cache[args] # 我们需要把新的方法对象返回回去，这样用户调用add_cache传递旧的方法就能得到新的方法对象 return wrap# 计算斐波那契的方法def fibonacci(n): if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)\"\"\" 调用装饰方法，获得新的增加了功能的对象，通常新方法名保持和原方法名一致，这样原来的业务逻辑不需要做任何修改\"\"\"fibonacci = add_cache(fibonacci)# 需要注意的是，Python的数值也是有长度限制的，在Win10x64计算机上，最高可以计算第332位print(fibonacci(50)) 看完上面的例子以后，有人可能会说：这不是忽悠人呢？你以为我是新手啊，不知道什么是装饰器吗？装饰器我看人家都是用@符号后面跟个名字，然后写在方法上就可以了。 我想说，之所以能够实现@符号装饰，是因为Python给我们提供了这样的便利，再来看上面的例子： 12345678910111213141516def add_cache(func): cache = &#123;&#125; def wrap(*args): if args not in cache: cache[args] = func(*args) return cache[args] return wrap# 装饰fibonacci方法，只用一个@符号，后跟自己写的装饰方法即可@add_cachedef fibonacci(n): if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)# 此时这个fibonacci实际上已经被增加了新的功能print(fibonacci(50)) 同样能够实现之前的功能。 提醒：我之所以不厌其烦的复制重复代码，并且一行一行删除掉已经写过的注释，就是希望能加深大家的印象，能把别处学来的东西，真正理解，应用到工作中，变成自己的东西。 至此，我相信大家已经明白什么是装饰器了。所谓装饰器，就是给我们原来非常单调，没有某些功能的方法，增加一些功能，就跟我们玩游戏给人物带装备一样。这么想是不是非常容易理解了。 代码我在Python2.x和3.x都测试过没问题 废话不想说那么多，希望大家好好学习，工资蹭蹭往上涨。 by. 秋名山车神 END","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"装饰器","slug":"装饰器","permalink":"http://www.cheshen.wiki/tags/装饰器/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"Python装饰器进阶之二","slug":"Python装饰器进阶之二","date":"2017-03-12T10:21:05.000Z","updated":"2017-04-15T06:09:48.877Z","comments":true,"path":"2017/03/12/Python装饰器进阶之二/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/Python装饰器进阶之二/","excerpt":"保存被装饰方法的元数据什么是方法的元数据 举个栗子 1234def hello(): print('Hello, World.')print(dir(hello))","text":"保存被装饰方法的元数据什么是方法的元数据 举个栗子 1234def hello(): print('Hello, World.')print(dir(hello)) 结果如下： 1['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__'] 其中： 1234567__name__: 代表方法的名字__doc__: 代表方法的字符串文档(实际上就是&quot;&quot;&quot;...&quot;&quot;&quot;这种形式的注释)__moudle__: 方法所属模块的名字__dict__: 属性字典(这个属性在面向对象编程时很重要，用好了能大大节约Python内存的开支)__defaults__: 方法参数中，默认参数的值(实际上Python方法的默认参数是创建方法对象的时候就存储在这里的)...等等 以下面一个为例： 123456789101112def hello(numa, numb=1, numc=[]): \"\"\" Print numa, numb, numc. \"\"\" print(numa, numb, numc) return Trueprint(hello.__name__)print(hello.__doc__)print(hello.__module__)print(hello.__dict__)print(hello.__defaults__) 结果如下： 12345678hello Print numa, numb, numc. __main__&#123;&#125;(1, [])[Finished in 0.1s] 我们可以看到，123456789我们给方法增加一个属性：```pythondef hello(): print(&apos;Hello, World.&apos;)hello.name = &apos;XiaoMing&apos;print(hello.__dict__) 结果如下： 1&#123;&apos;name&apos;: &apos;XiaoMing&apos;&#125; 甚至我们还可以这样： 12345def hello(): print('Hello, World.')hello.__dict__['name'] = 'XiaoMing'print(hello.name) 结果如下： 1XiaoMing 同样的，我们的12345678```pythondef hello(numa, numb=1, numc=[]): print(numa, numb, numc)# 一共两个元素，下标1的元素就代表了我们的numc所对应的列表hello.__defaults__[1].append(&apos;Hello&apos;)hello(100) 结果如下： 1100 1 [&apos;Hello&apos;] 所以，在我们方法的默认参数上面，应该避免使用数组这种可变类型的数据结构。因为Python本身把1234567891011121314151617181920212223242526272829303132说了这么多废话，没有进入主题，来看装饰器对方法元数据的影响，上一章的例子：```pythondef add_cache(func): &quot;&quot;&quot; This add_cache &quot;&quot;&quot; cache = &#123;&#125; def wrap(*args): &quot;&quot;&quot; This wrap &quot;&quot;&quot; if args not in cache: cache[args] = func(*args) return cache[args] return wrap@add_cachedef fibonacci(n): &quot;&quot;&quot; This fibonacci &quot;&quot;&quot; if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)# 实际上返回的对象是wrap方法的对象，所以得到的也是wrap方法的元数据print(fibonacci.__name__)print(fibonacci.__doc__) 结果如下： 123wrap This wrap 如何保存被装饰方法的元数据不被改变这样就存在一个问题，我们的方法被装饰以后，原来的某些东西，我们无法访问了，这肯定是不行的，那我们必须想办法能够在装饰以后还保持某些元数据是原来方法的元数据。 简单思考以后我们可以这样做： 12345678910111213141516171819202122232425262728def add_cache(func): \"\"\" This add_cache \"\"\" cache = &#123;&#125; def wrap(*args): \"\"\" This wrap \"\"\" if args not in cache: cache[args] = func(*args) return cache[args] # 返回之前，我们修改这个对象的元数据让它等于原方法的元数据 wrap.__name__ = func.__name__ wrap.__doc__ = func.__doc__ return wrap@add_cachedef fibonacci(n): \"\"\" This fibonacci \"\"\" if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci.__name__)print(fibonacci.__doc__) 结果和我们设想的一样： 123fibonacci This fibonacci 虽然是实现了我们的目的，但是这么做非常的不优雅，有没有比较优雅的做法呢。 我们可以使用Python标准库functools下的update_wrapper来实现： 123456789101112131415161718192021222324252627282930from functools import update_wrapperdef add_cache(func): \"\"\" This add_cache \"\"\" cache = &#123;&#125; def wrap(*args): \"\"\" This wrap \"\"\" if args not in cache: cache[args] = func(*args) return cache[args] # 使用update_wrapper来进行替换 update_wrapper(wrap, func, assigned=('__name__',), updated=('__dict__',)) return wrap@add_cachedef fibonacci(n): \"\"\" This fibonacci \"\"\" if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci.__name__)print(fibonacci.__doc__) 结果如下： 123fibonacci This wrap 解析： 123456789101112131415update_wrapper: 第一个参数：代表装饰方法 第二个参数：代表被装饰方法 assigned：代表那些属性是需要替换的，不写的就代表不替换。(可以省略不写assigned=) updated：代表哪些属性需要合并，因为原方法有一些属性，装饰方法也有一些属性，所以他们两个里面的内容，需要合并在一起。(同样可以省略不写updated=)需要注意的是呢，update_wrapper中的assigned和updated都有一个默认的参数，来看一下这个方法的源代码：WRAPPER_ASSIGNMENTS = (&apos;__module__&apos;, &apos;__name__&apos;, &apos;__qualname__&apos;, &apos;__doc__&apos;, &apos;__annotations__&apos;)WRAPPER_UPDATES = (&apos;__dict__&apos;,)def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES):所以，即使我们不指定后两个参数，也是可以实现我们的需求的。 还有一种更方便的做法，Python为我们提供了一个装饰器：1234567891011121314151617181920212223242526272829303132```pythonfrom functools import wrapsdef add_cache(func): &quot;&quot;&quot; This add_cache &quot;&quot;&quot; cache = &#123;&#125; # 使用装饰器来保存被装饰方法的元数据 @wraps(func) def wrap(*args): &quot;&quot;&quot; This wrap &quot;&quot;&quot; if args not in cache: cache[args] = func(*args) return cache[args] return wrap@add_cachedef fibonacci(n): &quot;&quot;&quot; This fibonacci &quot;&quot;&quot; if n &lt;= 1: return 1 return fibonacci(n - 1) + fibonacci(n - 2)print(fibonacci.__name__)print(fibonacci.__doc__) 结果如下： 123fibonacci This fibonacci 实际上在@wraps()这个装饰器内部，使用的就是update_wrapper()方法。 END","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"装饰器","slug":"装饰器","permalink":"http://www.cheshen.wiki/tags/装饰器/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"精通Python爬虫-02-初遇","slug":"精通Python爬虫-02-初遇","date":"2017-03-12T10:21:05.000Z","updated":"2017-04-15T06:09:43.326Z","comments":true,"path":"2017/03/12/精通Python爬虫-02-初遇/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/精通Python爬虫-02-初遇/","excerpt":"声明： 本系列文章原创于慕课网，作者秋名山车神，任何人不得以任何形式在不经作者允许的情况下，进行任何形式的印刷以及销售，转载需注明出处及此声明。 本系列文章更新至少每周一更，将涉及Python爬虫基础，Requests，Scrapy等主流爬虫技术。同时会介绍图片验证码，语音验证码的识别以及我自己设计的一个高并发可扩展易维护的集群爬虫架构。 对文章有任何问题请在下面留言，我会不定期的回复大家。 人非圣贤，如果文章有错别字请大家自行区分或指正出来，我将不定期修改错误的地方。 本系列能否持久更新下去离不开大家的支持与鼓励，以及对原创版权的尊重。","text":"声明： 本系列文章原创于慕课网，作者秋名山车神，任何人不得以任何形式在不经作者允许的情况下，进行任何形式的印刷以及销售，转载需注明出处及此声明。 本系列文章更新至少每周一更，将涉及Python爬虫基础，Requests，Scrapy等主流爬虫技术。同时会介绍图片验证码，语音验证码的识别以及我自己设计的一个高并发可扩展易维护的集群爬虫架构。 对文章有任何问题请在下面留言，我会不定期的回复大家。 人非圣贤，如果文章有错别字请大家自行区分或指正出来，我将不定期修改错误的地方。 本系列能否持久更新下去离不开大家的支持与鼓励，以及对原创版权的尊重。 urllib简介 首先需要说明的是，本系列教程，全部采用Python3.5作为开发环境，因为我不想做一些影响Python3发展的事情，如非必要，请使用Python3。 urllib是Python提供的一个用来访问网络的库，在Python3中有了较大的改动，首先最明显的就是整合了urllib2和urllib，使用起来更加的明了简单。 第一个请求123456789#!/usr/bin/env python# -*- coding: utf-8 -*-# 引入urllib下的request模块import urllib.request# 使用urlopen发送请求，并获得响应response = urllib.request.urlopen('http://www.imooc.com')print(response.read()) urllib.request模块：包含了跟请求相关的方法。 urlopen：可以根据链接或Request对象来发送请求，并将结果返回为一个HTTPResponse对象。结果对象包含一个read方法，可以输出获取到的HTML代码。 使用Request对象12345678910#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.request# 创建一个Request对象req = urllib.request.Request('http://www.imooc.com')# 使用Request对象发送请求response = urllib.request.urlopen(req)print(response.read()) 和上面有所不同的是，这里我们使用了Request方法来发送请求，这里或许看不出什么差异，我们将在下个案例中看到他们的区别。 发送POST请求123456789101112131415161718#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.parsepost_value = &#123; 'keyword': '大数据', 'pageCount': '1'&#125;# 把dict对象转换为请求的url参数字符，并按照utf-8转换为字节post_data = urllib.parse.urlencode(post_value).encode('utf-8')# 发送携带参数的POST请求req = urllib.request.Request('http://www.iimedia.cn/do_search.jsp', data=post_data)response = urllib.request.urlopen(req)print(response.read()) urllib.request.Request在Python3中，必须接受一个字节类型的data，这是和Python2不同，需要区分。和requests这种库不同，Python的urlopen方法，会根据有没有携带data参数来决定是发送GET请求还是POST请求。 再试试带参数的GET请求1234567891011121314#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.parseurl = 'http://www.imooc.com/search/course'get_value = &#123;'words': 'Python', &#125;get_data = urllib.parse.urlencode(get_value)# 拼装后的URL就是http://www.imooc.com/search/course?words=Pythonreq = urllib.request.Request(url + '?' + get_data)response = urllib.request.urlopen(req)print(response.read()) 欺骗的大师我们来思考一个问题，那就是类似于腾讯，百度，乃至慕课网。愿意别人通过爬虫来获取网站上的一些数据吗？我想这种问题不用回答也知道结果，自然是不愿意。那么服务器是如何知道到底是什么在访问它呢？答案是通过请求的数据包中，一个叫做user-agent的参数来区分的，我们通过浏览器的开发者工具可以轻松的找到，如果不知道怎么使用的，可以参考我在慕课网的课程浏览器开发者工具使用技巧。 我们只需要使用真正的浏览器访问一下网站，然后在开发者工具中找到这个参数，把里面的内容复制下来。 例如我的是： Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36 可以看到，这里面包含了我的浏览器版本以及内核版本，系统的版本和位数等等。 这就像给我们的爬虫披上了一层伪装的外衣一样，可以悄无声息的渗透到我们想去的地方。 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestheaders = &#123;'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36'&#125;url = 'http://www.imooc.com'# 给headers参数赋值req = urllib.request.Request(url, headers=headers)response = urllib.request.urlopen(req)print(response.read()) 通过urllib的源码，我们可以看到，urllib.request.Request方法接收的参数： 12&gt; self, url, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None&gt; data和headers参数，如果我们不指定，默认都是为空的。 异常的处理异常的处理，对于任何一个语言任何一个程序都是非常重要的，它意味着我们的程序在遇到错误以后需要如何处理。那么同样的，为了我们的爬虫不轻易的就遇到异常停止，我们需要对一些异常进行操作。 URLError这是urllib内的一个异常类，正如其名，通常在遇到URL链接有问题时，会抛出这种异常，比如下面的代码： 12345678#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.error# 注意这里的URL地址，我们故意写成htturllib.request.urlopen('htt://www.imooc.com') 运行上面的代码，得到一个错误： urllib.error.URLError: 那么我们如何捕获这个异常，在遇到这种问题时，不要让我们的程序崩溃呢？ 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.request# 所有urllib异常的类，在Python3中都移植到了urllib.error里面import urllib.errortry: urllib.request.urlopen('htt://www.imooc.com')except urllib.error.URLError as e: print(e.reason) 运行上面的程序，我们会得到一个输出信息： unknown url type: htt 可以看到，这个内容，就是前面我们输出的 urllib.error.URLError: 尖括号里面的内容，信息被存储在URLError对象里的reason属性，它就说明了导致异常的原因。 上面是我们协议写错，这种情况在真实的爬虫环境中，几乎不会遇到，但是我们常遇到的就是URL访问地址不可达，什么情况会导致这种现象发生？比如有一个网站里面有一个链接指向一个地址，但是那个地址的域名到期了，域名所有者没有续费，那这个域名现在就属于一个不可访问的地址了，我们来模拟这种情况，来看一下会报出什么异常信息。 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.errortry: # 这个域名显然不会有人注册，不排除有人看了教程以后注册这个域名... urllib.request.urlopen('http://www.imooc1imooc2imooc3.com')except urllib.error.URLError as e: print(e.reason) 上面的代码运行会输出以下信息： [Errno 11001] getaddrinfo failed 此处我们明显的发现，多了一个中括号，里面有一个Errno是11001。像这样的错误码还有很多，大家带Errno可以在网上搜索，也可以根据后面的错误信息自己去判断。 HTTPError刚才我们说的都是URL上的一些错误，那么我们在HTTP请求的时候一定也会遇到很多的问题，比如常见的我们访问的页面不存在。需要注意的是，页面不存在不代表我们的请求没有发到对方的服务器，而是发到对方的服务器以后，对方的服务器没有找到我们要访问的网页，给我们返回一个错误码。这和上面的根本都找不到对方的服务器，有本质上的区别。 那么我们来看一下不捕获异常访问一个不存在的页面会怎样： 1234567#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.request# 显然慕课网目前没有cheshen.html这个页面urllib.request.urlopen('http://www.imooc.com/cheshen.html') 运行以后，得到我们期望的异常： urllib.error.HTTPError: HTTP Error 404: Not Found 其中HTTP Error 就是错误编号，这里是404，冒号后面是错误原因，意思是没有找到。 这些编号有很多，大家可以参考百度百科给出的资料：HTTP Error。 相比URLError，HTTPError更容易产生，也更容易让我们的程序变得脆弱不堪，所以没啥说的，捕获异常： 1234567891011#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib.requestimport urllib.errortry: urllib.request.urlopen('http://www.imooc.com/cheshen.html')except urllib.error.HTTPError as e: print(e.reason) print(e.code) 运行以后输出了： Not Found404 不用我说，大家也知道reason代表错误信息，code代表错误代码。 而我们如果修改上面的代码： 12&gt; print(type(e.code))&gt; 就会看到 这说明code是一个int类型的数值，我们可以在代码中进行比较来判断我们是遇到了哪种错误，以决定接下来我们的爬虫如何工作。","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.cheshen.wiki/tags/爬虫/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"精通Python爬虫-01-不断前行的蜘蛛","slug":"精通Python爬虫-01-不断前行的蜘蛛","date":"2017-03-12T10:21:05.000Z","updated":"2017-04-15T06:09:40.375Z","comments":true,"path":"2017/03/12/精通Python爬虫-01-不断前行的蜘蛛/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/精通Python爬虫-01-不断前行的蜘蛛/","excerpt":"声明： 本系列文章原创于慕课网，作者秋名山车神，任何人不得以任何形式在不经作者允许的情况下，进行任何形式的印刷以及销售，转载需注明出处及此声明。 本系列文章更新至少每周一更，将涉及Python爬虫基础，Requests，Scrapy等主流爬虫技术。同时会介绍图片验证码，语音验证码的识别以及我自己设计的一个高并发可扩展易维护的集群爬虫架构。 对文章有任何问题请在下面留言，我会不定期的回复大家。 人非圣贤，如果文章有错别字请大家自行区分或指正出来，我将不定期修改错误的地方。 本系列能否持久更新下去离不开大家的支持与鼓励，以及对原创版权的尊重。","text":"声明： 本系列文章原创于慕课网，作者秋名山车神，任何人不得以任何形式在不经作者允许的情况下，进行任何形式的印刷以及销售，转载需注明出处及此声明。 本系列文章更新至少每周一更，将涉及Python爬虫基础，Requests，Scrapy等主流爬虫技术。同时会介绍图片验证码，语音验证码的识别以及我自己设计的一个高并发可扩展易维护的集群爬虫架构。 对文章有任何问题请在下面留言，我会不定期的回复大家。 人非圣贤，如果文章有错别字请大家自行区分或指正出来，我将不定期修改错误的地方。 本系列能否持久更新下去离不开大家的支持与鼓励，以及对原创版权的尊重。 爬虫的定义爬虫就是通过模拟人类使用浏览器来访问网页的过程，通过一个起始URL地址不断的从请求到的HTML中寻找新的URL地址，如此循环下去，直到我们的目的达成。 什么是URL和HTMLURLURL(Uniform Resource Locator)又叫统一资源定位符。通俗的讲，每一个URL都代表一个资源，而这个资源是存储在不同的计算机上，我们使用固定的协议，主机名，端口号，对应的路径以及文件名这样的格式。就可以通过浏览器来访问到存放在某一个主机上面的资源。 如：http://www.imooc.com:80/static/img/index/logo-newyear.gif 这就是一个URL地址，它所代表的的含义就是，使用http协议来访问www.imooc.com这个主机，和这个主机的80端口进行通信，找到static目录下的img目录下的index目录下的logo-newyear.gif资源。这个URL就代表了唯一的一个资源，无论是我还是你来访问，请求到的都是这一个资源。所以叫做，统一资源定位符。 HTMLHTML(HyperText Markup Language)又叫做超文本标记语言。文本我们都知道，我们最简单的TXT文档，就是一个文本，那么什么是超文本呢？我们可不可以理解为是一种比文本更加强大的东西？因为我们的TXT文档连最基本的针对某个字符进行加粗或者插入一个图片都做不到，所以我们需要一种更加强大的文本，那就是超文本。 所以HTML不仅仅可以包含文字，还可以包含程序，视频，音频，图片，链接，等等。它具有一种独特的书写格式，简单易学，并且体积较小，容易阅读，可以在互联网进行低带宽传输，并且能够很好的被其他程序解析，比如我们的浏览器。有些人看到前面可能会问：Word文档也可以包含视频音乐和图片啊，为什么Word不叫超文本呢？这个问题非常好，因为Word文档设计本身就不是让它在互联网进行传输的，我们都知道互联网传输什么最重要？那就是速度，Word文档不仅体积大，而且它的编码还不是采用的字符的编码形式，而是采用微软特有的形式进行编码，我们需要依靠特定的软件，比如Office才能编辑这种文档。而不像我们的HTML，他可以使用最原始的文本文档进行编辑，它在传输的时候就是最简单的字符，可以被任何其他程序轻易的读取。 当我们在使用浏览器访问一个HTML文件的时候，服务器就会把这个文件中包含的字符传输给我们的浏览器，浏览器获取到这个文件以后会把里面包含的视频，图片，样式，音频等等统统请求过来，然后根据里面当初大家规定好的代码标签来将页面漂亮的显示出来，而不是一个原始的代码文本。 如下图，这是慕课网首页经过浏览器渲染后的样子： 我们再来看一下没有经过渲染的样子： 是不是非常的难看，虽然有前端基础的同学能够看出他们代表的意思，但是你能够在脑海中想象出这么漂亮的一个页面吗？恐怕非常困难吧，而我们的浏览器并没有修改任何的东西，只是把当初定义HTML语言时候规定的样式给展现了出来。那么也就是说，这其实是浏览器搞的鬼，实际上服务器返回的还是上面的没有渲染过的代码。 那么既然浏览器是一个程序，它能够发送请求来获取一个URL地址对应的资源，我们能不能够也写一个类似的程序，但是我们不需要去渲染漂亮的页面，我们只需要从HTML代码中获取一些我们感兴趣的东西就可以了。于是，爬虫技术应运而生。 不断前行的蜘蛛任何事情它一开始出现的目的，一定是为了解决某些问题的，爬虫也不例外。在互联网开始之初，人们建立了许多的网站，我们都知道服务器其实就是一个计算机而已，它也拥有IP地址。我们访问一台服务器的时候，其实访问的就是它的IP地址，但是IP地址并不好记啊，所以人们发明了域名，域名就很好记了。比如说：www.imooc.com，www.baidu.com，www.qq.com。但是随之而来的问题就出现了，这么多的网站，我不可能每个域名都记住啊，你让我记住十几个，甚至是天赋过人，记住几百个，但是其他更多的域名怎么办呢。如果我想找到一个音乐网站，我该怎么找呢。 这时，就有人想，能不能做一个程序，我让它把世界上所有的网站都找到，然后大家都在自己网站的HTML代码里加入一个特殊的标记，如果你这个网站主要是音乐，你就在里面写上音乐还有其他跟音乐相关的关键词，我的程序就通过分析你们这些页面里包含的东西还有你们的域名存储在我的服务器里，而我来建一个网站。这个网站什么都没有，只有一个搜索框，别人想找一个音乐网站就在框里输入音乐两个字，点搜索我就把你的域名给别人显示出来，这样所有人都只用记住我的网站域名就可以了，其他的根本不用记。 到这里，可能很多人都明白了，这就是我们的搜索引擎。没错，爬虫的最初目的竟然是为了解决人们记不住互联网上众多的域名而诞生的。但是随着大数据和人工智能时代的到来，数据显得越来越重要，谷歌，百度，腾讯，凭什么他们能够屹立在互联网行业的最巅峰？那就是因为他们掌握的数据量太恐怖了，百度谷歌每天通过人们搜索的关键词就可以判断出全世界的一个趋势，他们知道人们对什么感兴趣。包括腾讯，庞大的用户群体，空间，等等。通过人物之间的关系，以及各种动态就可以分析出某些群体他们感兴趣的产品。 21世纪什么最重要？产品。我们来看滴滴打车等软件就可以知道，一个好的产品可以让一个普通人身价过亿。那么如何做好一个产品，自然是庞大的数据分析。根据不完全统计，各大招聘网站中数据挖掘工程师的工资不断的飙升，并且稳居IT行业前列。并且在2016年出现了震惊世界的一件事，那就是国际围棋大师，李世石大战谷歌人工智能阿尔法狗，最终败给了阿尔法狗。 这件事再次让人们重新思考人工智能是否可行，但是无论怎样，人工智能技术绝对离不开庞大的数据量，那么这些数据如何获取，就完全依靠我们的爬虫程序。越来越多的人投身这个行业，越来越多的爬虫进入了这个庞大的互联网，它们目的明确，不断的顺着网络寻找下一个目标，像一个不知疲倦的蜘蛛，永远前行。","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://www.cheshen.wiki/tags/爬虫/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"Python多线程之threading.Thread","slug":"Python多线程之threading.Thread","date":"2017-03-12T10:21:05.000Z","updated":"2017-04-15T06:09:51.451Z","comments":true,"path":"2017/03/12/Python多线程之threading.Thread/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/Python多线程之threading.Thread/","excerpt":"并行和串行串行所谓串行，就好比我们走路一样，一条马路，一次只能过一辆车，这样速度就会很受限制。 并行理解了串行，并行就更好理解了，就是好多条路。路越多，车流量就越大。","text":"并行和串行串行所谓串行，就好比我们走路一样，一条马路，一次只能过一辆车，这样速度就会很受限制。 并行理解了串行，并行就更好理解了，就是好多条路。路越多，车流量就越大。 多线程就是并行的一种。当然，实际发生在计算机内部的时候，并不能单纯的理解为多了一条路。因为我们的计算机一个CPU核心，同时只能处理一个任务。在CPU只有一个核心的情况下，多线程我们就可以理解为开辟出了许多条道路，但是我们的出口只有一个。每条路上面的车都会你争我抢谁也不让，哪条路抢到了通行权这条路上的汽车就会赶快通过，直到下条路抢到通行权，其他路上的汽车都会进入等待状态。实际发生在计算机内部的时候，线程之间的切换都是毫秒级的，所以人的无法感觉出来线程之间有等待的，在人看来所有的线程都是同时运行的。使用多线程，可以大大的增加程序的性能和效率。 Python标准库threading.Thread线程创建1. 使用Thread类创建123456# 导入Python标准库中的Thread模块from threading import Thread# 创建一个线程t = Thread(target=function_name, args=(function_parameter1, function_parameterN))# 启动刚刚创建的线程t.start() function_name: 需要线程去执行的方法名 args: 线程执行方法接收的参数，该属性是一个元组，如果只有一个参数也需要在末尾加逗号。 2. 使用继承类创建123456789101112131415161718from threading import Thread# 创建一个类，必须要继承Threadclass MyThread(Thread): # 继承Thread的类，需要实现run方法，线程就是从这个方法开始的 def run(self): # 具体的逻辑 function_name(self.parameter1) def __init__(self, parameter1): # 需要执行父类的初始化方法 Thread.__init__(self) # 如果有参数，可以封装在类里面 self.parameter1 = parameter1# 如果有参数，实例化的时候需要把参数传递过去t = MyThread(parameter1)# 同样使用start()来启动线程t.start() 线程等待在上面的例子中，我们的主线程不会等待子线程执行完毕再结束自身。可以使用Thread类的join()方法来子线程执行完毕以后，主线程再关闭。 1234567891011121314from threading import Threadclass MyThread(Thread): def run(self): function_name(self.parameter1) def __init__(self, parameter1): Thread.__init__(self) self.parameter1 = parameter1t = MyThread(parameter1)t.start()# 只需要增加一句代码t.join() 上面的方法只有一个线程，如果有多个线程，可以把每个线程放在一个数组中。 123456789thread_list = []for i in range(1, 11): t = MyThread(parameter1) thread_list.append(t) t.start()# 在这里统一执行线程等待的方法for t in thread_list: t.join() CPU密集型操作和IO密集型操作CPU密集型操作在我们的计算机中，需要大量用到CPU计算的事情，我们称为CPU密集型操作。 如，我们计算9的一亿次方，这种大型的运算，或者是进行文件格式的转换，这些都是属于CPU密集型操作。 注意：上面的运算会消耗很长的计算时间，有兴趣可以从小到大慢慢尝试一下 IO密集型操作所谓IO密集型操作，就是涉及到大量的输入输出，比如频繁的数据库访问，频繁的web服务器访问，这种情况都属于IO密集型操作。 不幸的GIL线程同步我们都知道，多线程最大的一个问题就是线程之间的数据同步问题。在计算机发展过程中，各个CPU厂商，为了提升自己的性能，引入了多核概念。但是多个核心之间如果做到数据同步让所有人都花费了很多的时间和金钱，甚至最后消耗了CPU很多的性能才得以实现。 Python是如何做的？了解Python的朋友都知道，Python默认的实现是CPython，而CPython使用的是C语言的解释器。而由于历史原因，CPython中不幸的拥有了一个在未来非常影响Python性能的因素，那就是GIL。GIL全称Interpreter Lock```，又叫全局解释器锁。GIL是[计算机程序设计语言](http://baike.baidu.com/view/2561555.htm)[解释器](http://baike.baidu.com/view/592974.htm)用于[同步](http://baike.baidu.com/view/54180.htm)[线程](http://baike.baidu.com/view/1053.htm)的工具，而CPython中正是支持了GIL的特性，使得Python的解释器同一时间只能有一条线程运行，一直等到这个线程执行完毕释放了全局锁以后，才能有其他的线程来执行。也就是说，CPython本身实际上是一个单线程语言，甚至在多核CPU上面使用CPython的多线程反而性能不如单线程高。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273人们对于GIL还存在很大的误解，GIL只存在于Python中的CPython，使用Jython或者PyPy则不存在这个问题。&gt; - Python的线程是操作系统线程。在Linux上为pthread，在Windows上为Win thread，完全由操作系统调度线程的执行。一个python解释器进程内有一条主线程，以及多条用户程序的执行线程。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。&gt; - Python解释器进程内的多线程是合作多任务方式执行。当一个线程遇到I/O任务时，将释放GIL。计算密集型（CPU-bound）的线程在执行大约100次解释器的计步（ticks）时，将释放GIL。计步（ticks）可粗略看作Python虚拟机的指令。计步实际上与时间片长度无关。可以通过sys.setcheckinterval()设置计步长度。&gt; - 在单核CPU上，数百次的间隔检查才会导致一次线程切换。在多核CPU上，存在严重的线程颠簸（thrashing）。#### 为什么CPython中使用了GIL我们都知道计算机一开始只是单核的，在那个年代人们并不会想到多核这种情况，于是为了应对多线程的数据同步问题，人们发明了锁。但是如果自己来写一个锁，不仅耗时耗力，而且还会隐藏许多未知的BUG等问题。于是在这样的大背景下，Python社区选择了最简单粗暴的方式，实现GIL，这样做有以下几点好处：&gt; 1. 可以增加单线程程序的运行速度（不再需要对所有数据结构分别获取或释放锁）&gt; 2. 容易和大部分非线程安全的 C 库进行集成&gt; 3. 容易实现（使用单独的 GIL 锁要比实现无锁，或者细粒度锁的解释器更容易）但是令Python社区没想到的是，CPU乃至计算机发展的如此迅速，双核，四核，甚至多CPU计算机的出现，让Python在很长一段时间内背负着运行效率低下的称号。而当Python社区和众多的Python库作者回过头想修改这些问题的时候却发现，代码与代码之间牢牢的依赖于GIL，面对庞大的绕成一团的线，也只能抽丝剥茧般的慢慢剔除。#### Python的新生值得庆幸的是，虽然我们不知道这一过程用了多久，但是在Python3.2中开始使用了全新的GIL，将大大的提升CPython的性能。#### 那Python3.2以下版本的多线程有什么用？很多人提到Python就想到爬虫，因为爬虫在某些程度上来说，Python的缺点完全不存在，而且还成了优点。我们来分析一下爬虫的运行过程：&gt; 1. 发送请求&gt; 2. 等待服务器响应&gt; 3. 收到服务器响应数据&gt; 4. 解析我们来看一下，以当前的计算机配置来说，对爬虫获取到的数据来进行解析处理的话，可能只需要几毫秒甚至更短的时间就能完成。那么一个爬虫程序最影响性能的地方在哪里？是IO操作。没错，我们的爬虫发出请求以后要等待对方的服务器来响应，这一过程是最耗时的，有时可能会需要一两秒的时间。此时，我们就可以在请求发送出去以后，立刻释放我们的全局锁，然后让下一个线程执行。直到某一个线程的响应回来以后消耗几毫秒处理数据，然后再次开始发送请求，而由于同一时间只有一条线程运行不需要考虑其他的问题，所以性能也会大大的提升。及时在爬虫上使用了真正意义的多线程，无非就是在解析数据的时候多几个线程来处理罢了。那么0.2毫秒和0.02毫秒，乃至无限至今于0毫秒的时间，他们之间的区别又是什么呢？同样都是人类无法分辨出来的差距，而我们又要对线程进行大量的安全性的处理，得不偿失。### 线程间通信在了解了线程以后，我们可能需要在多个线程之间通信。实现这一点，我们可以声明一个全局的存储对象，所有的线程都调用这一个对象来进行数据的存和取，这样就可以做到线程间的通信。我们使用传统的列表或元组都是可以的，但是列表和元组他们都是线程不安全的存储结构，我们需要自己加锁来保证线程安全。或者我们可以直接使用Python内置的线程安全的存储结构，Queue。Queue的使用如下：```python# Python2.xfrom Queue import Queue# Python3.ximport queue# Python2.xq = Queue()# Python3.xq = queue.Queue()# 存储一个元组到Queue中q.put((1, &apos;a&apos;))# q.get()每次获取一个数据，使用下面这种方式可以直接拆分元组int_data, str_data = q.get() 注意：Queue每次获取数据以后都会把获取的数据删除从内部，所以不用担心获取到重复的数据。使用q.queue属性，可以得到里面所有的数据，返回的是一个deque对象。 线程事件通知有时我们希望让某一个线程进入等待状态来进行一些其他的处理，当我们某些事情处理完成以后，再唤醒线程，让它从刚才停止的地方继续运行。使用标准库下面的Threading.Event就可以实现。 休眠事件：wait() 唤醒事件：set() 清除事件：clear() 12345678910111213141516171819from threading import Event, Thread# 接收一个Event对象def test_event(e): print('run...') # 让这个线程进入睡眠状态 e.wait() # 当线程被唤醒以后，会输出下面的语句 print('end...')e = Event()t = Thread(target=test_event, args=(e,))# 这里会看到输出了 run...t.start()print('Set Event...')# 唤醒线程会看到 end...e.set() 上面程序最终运行结果为： run…Set Event…end… 注意：当我们程序在一起运行周期内，重复调用e.wait()，第二次调用就无法让线程进入休眠状态了，需要调用e.clear()清除以后，才能再次进入休眠状态。 123456789101112131415161718192021from threading import Event, Threaddef test_event(e): print('run...') e.wait() # 为了重复使用，需要加上e.clear() # e.clear() print('end...')e = Event()t = Thread(target=test_event, args=(e,))t.start()# 第一次成功休眠print('Set Event1...')e.set()t = Thread(target=test_event, args=(e,))t.start()# 第二次休眠失败print('Set Event2...')e.set() 不去掉e.clear()的注释，根据线程的切换顺序，可能得到各种输出结果，可以自己多次尝试看看有什么不同的结果。 去掉e.clear()的注释以后，输出结果如下： run…Set Event1…end…run…Set Event2…end… 守护线程在多线程环境中，我们有多个继承了Thread的类，他们之间相互调用。假设我们此时有一个MyThread的类，它是为其他线程服务的。现在，其他线程的所有操作已经全部完成了，而我们的MyThread的run方法里面有一个死循环，我们怎么在其他线程都完成工作，停止了以后，停止我们的MyThread类中的死循环？ 123456789101112from threading import Threadclass MyThread(Thread): def run(self): while True: # 控制其他各个线程的代码 pass def __init__(self): Thread.__init__(self) # 设置守护线程 self.setDaemon(True) 在12345678910111213141516171819202122232425### 创建线程本地数据有些场景下，我们希望每个线程，都有自己独立的数据，他们使用同一个变量，但是在每个线程内的数据都是独立的互不干扰的。我们可以使用threading.local()来实现：```pythonimport threadingL = threading.local()L.num = 1# 此时操作的是我们当前主线程的threading.local()对象，输出结果为1print(L.num)def f(): print(L.num)# 创建一个子线程，去调用f()，看能否访问主线程中定义的L.numt = threading.Thread(target=f)t.start()# 结果提示我们：# AttributeError: &apos;_thread._local&apos; object has no attribute &apos;num&apos; 对上面的稍作修改： 1234567891011121314151617import threadingL = threading.local()L.num = 1# 此时操作的是我们当前主线程的threading.local()对象，输出结果为1print(L.num)def f(): L.num = 5 # 这里可以成功的输出5 print(L.num)# 创建一个子线程，去调用f()，看能否访问主线程中定义的L.numt = threading.Thread(target=f)t.start()# 主线程中的L.num依然是1，没有发生任何改变print(L.num) 程序运行结果为： 151 由此可见，threading.local()创建的对象中的属性，是对于每个线程独立存在的，它们相互之间无法干扰，我们称它为线程本地数据。 by. 秋名山车神 site: 慕课网 END","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://www.cheshen.wiki/tags/线程池/"},{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"多线程","slug":"多线程","permalink":"http://www.cheshen.wiki/tags/多线程/"},{"name":"Thread","slug":"Thread","permalink":"http://www.cheshen.wiki/tags/Thread/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"Python多线程----线程池","slug":"Python多线程----线程池","date":"2017-03-12T10:21:05.000Z","updated":"2017-04-15T06:09:34.166Z","comments":true,"path":"2017/03/12/Python多线程----线程池/","link":"","permalink":"http://www.cheshen.wiki/2017/03/12/Python多线程----线程池/","excerpt":"需求：假设我们现在有一个多线程项目，每有一个用户连接进来，我们的服务器就会创建一个线程。而我们的服务器最多能够承载100个线程，再多就会崩溃。为了防止恶意用户伪装真实用户构建大量的访问来让我们的服务器崩溃，现在需要对线程数量进行限制，一共只有100个线程，并且当一个用户访问结束以后线程会自动归还，等待下一个用户访问。如果100个线程全部被占用则101个用户进入阻塞时间，直到某一个用户退出，线程得到释放，101个用户才能被通行。","text":"需求：假设我们现在有一个多线程项目，每有一个用户连接进来，我们的服务器就会创建一个线程。而我们的服务器最多能够承载100个线程，再多就会崩溃。为了防止恶意用户伪装真实用户构建大量的访问来让我们的服务器崩溃，现在需要对线程数量进行限制，一共只有100个线程，并且当一个用户访问结束以后线程会自动归还，等待下一个用户访问。如果100个线程全部被占用则101个用户进入阻塞时间，直到某一个用户退出，线程得到释放，101个用户才能被通行。 不难看出上面的需求，类似我们MySQL的连接池。既然如此，我们的Python也应该有一个线程池，并且这种问题非常的常见，肯定已经有现成的库以供我们使用。今天我们就来看一下Python标准库中from concurrent.futures下的ThreadPoolExecutor。 第一个例子 123456789101112131415# 首先导包from concurrent.futures import ThreadPoolExecutor# 创建线程池executor = ThreadPoolExecutor(10)# 测试方法def test_function(num1, num2): print(num1, num2) return num1 + num2# 第一个参数为具体的方法，后面为方法的参数future = executor.submit(test_function, 1, 2)# future的result()方法可以获取到函数的执行结果print(future.result()) 执行结果： 1 23 ThreadPoolExecutor(pool_count): pool_count代表创建线程的数量，会返回一个该线程池的执行者对象，这个对象的submit()方法和map()方法，能够使用线程池中的线程来执行我们指定的方法，并且返回一个Future对象。Future对象的result()方法，可以获取我们方法执行的结果。如果方法一直没有返回或执行完毕，则result()方法会进入阻塞状态，直到我们的方法返回或执行完毕。 使用map()方法批量执行 1234567891011121314151617181920212223from concurrent.futures import ThreadPoolExecutorexecutor = ThreadPoolExecutor(10)def test_function(num1, num2): print(num1, num2) return num1 + num2\"\"\" executor.map(function, 参数1_list, 参数2_list, 参数n_list) 参数1_list: 代表方法第一个参数的列表 参数2_list: 代表方法第二个参数的列表 如： executor.map(test_function, [1, 2], [5, 5]) 代表，执行test_function方法，第一个线程的参数为1和5，第二个线程的参数为2和5。 线程1：test_function(1, 5) 结果为1 + 5 = 6 该方法返回的是一个可迭代的对象，里面直接包含了每个方法执行的结果，不需要调用result()方法。 详情：https://docs.python.org/3/library/concurrent.futures.html\"\"\"result_iterators = executor.map(test_function, [1, 2], [5, 5])for result in result_iterators: print(result) 执行结果： 1 52 567 尝试一下所有线程都被占用的情况 12345678910111213141516171819202122import timefrom concurrent.futures import ThreadPoolExecutor# 方便测试创建三个线程executor = ThreadPoolExecutor(3)def test_function(num1, num2): print(num1, num2) # 方法休眠十秒 time.sleep(10) return num1 + num2# 使用三个线程，占用线程池全部线程# 由于我们的结果是十秒后返回，所以这里也会被阻塞，十秒后才会收到结果result_iterators = executor.map(test_function, [1, 2, 3], [5, 6, 7])for result in result_iterators: print(result)# 到这里很显然前面三个线程都在使用中，10秒后才能得到执行future = executor.submit(test_function, 4, 8)print(future.result()) 执行结果： 1 52 63 768104 812[Finished in 20.2s]","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"http://www.cheshen.wiki/tags/线程池/"},{"name":"Python","slug":"Python","permalink":"http://www.cheshen.wiki/tags/Python/"},{"name":"多线程","slug":"多线程","permalink":"http://www.cheshen.wiki/tags/多线程/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"python选择排序","slug":"python选择排序","date":"2016-10-27T12:21:49.000Z","updated":"2017-04-15T06:09:30.785Z","comments":true,"path":"2016/10/27/python选择排序/","link":"","permalink":"http://www.cheshen.wiki/2016/10/27/python选择排序/","excerpt":"算法+数据结构=编程 算法实际上是依托于数据结构的，没有数据结构就没有算法。 以下代码在Python3.5上正常运行，转载请注明出处。 By.秋名山车神","text":"算法+数据结构=编程 算法实际上是依托于数据结构的，没有数据结构就没有算法。 以下代码在Python3.5上正常运行，转载请注明出处。 By.秋名山车神 O(n^2)级别的排序算法选择排序将一个列表：10, 9, 8, 7, 6, 5, 4, 3, 2, 1 进行从小到大排序： 普通实现1234567891011121314151617181920# arr为待排序的列表# 在从0到n之间进行排序def selection_sort(arr, n): for i in range(n): # 假定i的位置是最小值 minIndex = i for j in range(i+1, n): if arr[j] &lt; arr[minIndex]: minIndex = j # 交换arr[i] 和 arr[minIndex]的值 arr[i], arr[minIndex] = arr[minIndex], arr[i] return arrif __name__ == '__main__': # 生成测试数据 a = [10,9,8,7,6,5,4,3,2,1] selection_sort(a, 10) for i in a: print(str(i), end = \" \") print() 自定义类型排序Student.py12345678910111213141516class Student(object): def __init__(self, name, score): self.name = name self.score = score # 重载小于运算符 def __lt__(self, otherStudent): # 类似其他语言的三元运算符，如果分数相等则比较名称 return (self.score &lt; otherStudent.score if self.score != otherStudent.score else self.name &lt; otherStudent.name) # 只比较分数 # return self.score &lt; otherStudent.score # 当使用print打印一个对象的时候，按照这种格式显示 def __repr__(self): return \"Student: \" + self.name + \" \" + str(self.score) main.py1234567891011121314151617181920212223242526272829303132333435363738394041from Student import Studentdef selection_sort(arr, n): for i in range(n): # 假定i的位置是最小值 minIndex = i for j in range(i+1, n): if arr[j] &lt; arr[minIndex]: minIndex = j # 交换arr[i] 和 arr[minIndex]的值 arr[i], arr[minIndex] = arr[minIndex], arr[i] return arrif __name__ == '__main__': # 测试模板函数，传入整型列表 a = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] selection_sort( a , 10 ) for i in a: print(str(i), end = \" \") print() # 测试模板函数，传入浮点数列表 b = [4.4, 3.3, 2.2, 1.1] selection_sort(b,4) for i in b: print(str(i), end = \" \") print() # 测试模板函数，传入字符串列表 c = [\"D\", \"C\", \"B\", \"A\"] selection_sort(c,4) for i in c: print(str(i), end = \" \") print() # 测试模板函数，传入自定义结构体Student列表 d = [Student(\"D\", 80), Student(\"C\", 100), Student(\"B\", 95), Student(\"A\", 95)] selection_sort(d,4) for i in d: print(str(i)) print() 或许我们可以更灵活SortTestHelper.py12345678910111213141516171819import randomimport timeclass SortTestHelper(object): def generate_random_array(n, rangeL, rangeR): assert rangeL &lt;= rangeR arr = [None for _ in range(n)] random.seed(int(time.time())) for i in range(n): arr[i] = random.randint(rangeL, rangeR) % (rangeR - rangeL + 1) + rangeL return arr def print_array(arr): for o in arr: print(o, end = \" \") print() main.py123456789101112131415161718192021222324252627282930313233343536from SortTestHelper import SortTestHelper\"\"\" Python的每一个数字都被描述为一个不可变对象 它需要不断的创建对象，修改引用，垃圾回收，等等一系列操作 所以它不像其他语言那样能够快速操作庞大的千万次的数值运算 Python社区为了弥补这一缺点，使用C语言实现了排序功能\"\"\"def selection_sort(arr, n): for i in range(n): minIndex = i for j in range(i+1, n): if arr[j] &lt; arr[minIndex]: minIndex = j arr[i], arr[minIndex] = arr[minIndex], arr[i] return arrif __name__ == '__main__': N = 10000 arr = SortTestHelper.generate_random_array(N, 0, 10000) \"\"\" 我为什么要这么做？ 1. Python社区不希望程序员自己再造轮子 2. 前面我们已经使用模仿C++的算法实现过了 3. 这正是Python最大的魅力之所在 4. 人生苦短，我用Python 我想降序排列？ arr.sort(reverse = True) 干杯！ \"\"\" arr.sort() # Python的特点导致操作数字会特别的慢 # selectionSort(arr, N) print(arr) 可以增加一个消耗时长测试的方法SortTestHelper.py1234567891011121314151617181920212223242526272829303132import randomimport timeclass SortTestHelper(object): def generate_random_array(n, rangeL, rangeR): assert rangeL &lt;= rangeR arr = [None for _ in range(n)] random.seed(int(time.time())) for i in range(n): arr[i] = random.randint(rangeL, rangeR) % (rangeR - rangeL + 1) + rangeL return arr def is_sort(arr, n): for i in range(n - 1): if arr[i] &gt; arr[i+1]: return False return True def test_sort(sort_name, sort_def, **kwargs): arr = kwargs.get(\"arr\") n = kwargs.get(\"n\") start_time = time.time() sort_def(arr, n) # 十万个数字的级别测试需要非常久的时间，建议使用Python内置函数测试十万级别 # 是不是被内置函数的效率惊呆了？ # arr.sort() # end_time = time.time() assert SortTestHelper.is_sort(arr, n) # python标准建议我们使用format来替换字符串，而不是%。 print(\"&#123;:.6f&#125; s\".format(end_time - start_time)) main.py123456789101112131415161718from SortTestHelper import SortTestHelperdef selection_sort(arr, n): for i in range(n): minIndex = i for j in range(i+1, n): if arr[j] &lt; arr[minIndex]: minIndex = j arr[i], arr[minIndex] = arr[minIndex], arr[i] return arrif __name__ == '__main__': n = 10000 arr = SortTestHelper.generate_random_array(n, 0, n) # 可以看到Python操作大量数值类型是如此耗时 SortTestHelper.test_sort(\"fun1\", selection_sort, arr=arr, n=n)","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www.cheshen.wiki/tags/算法/"},{"name":"算法入门","slug":"算法入门","permalink":"http://www.cheshen.wiki/tags/算法入门/"},{"name":"python算法","slug":"python算法","permalink":"http://www.cheshen.wiki/tags/python算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://www.cheshen.wiki/tags/数据结构/"},{"name":"选择排序","slug":"选择排序","permalink":"http://www.cheshen.wiki/tags/选择排序/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"如何成为一名程序员？","slug":"如何成为一名程序员？","date":"2016-10-22T09:59:17.000Z","updated":"2017-04-15T06:08:27.409Z","comments":true,"path":"2016/10/22/如何成为一名程序员？/","link":"","permalink":"http://www.cheshen.wiki/2016/10/22/如何成为一名程序员？/","excerpt":"为什么会有这篇文档？之前有幸看过Eric Raymond(埃里克·史蒂文·雷蒙德)写的一篇文章《如何成为一名黑客》，感觉像黑夜里的灯塔一样，能够给人很多的启迪。在计算机这条道路上，无论是程序员，黑客，网管，还是其他任何相关的角色，有一个老司机带你，能让你看清自己的方向，不至于迷失自我。记得在初二那一年因为老师的一句很看不起人的话，走上了编程这条路。高中，大学，不断的更换自己所学的语言。这期间我学习了VB，Java，Perl，Python，C#，C，C++，汇编，原因就是因为自己不知道该学什么好，究竟应该学什么才是对的，怎么样才能更好的在编程这条路走的更远，我学习VB的时候看到别人说Java如何的厉害，学Java的时候又听别人说Java不能做大型游戏和操作系统…那一刻我是真的迷茫了。这是我下定决定要写这篇手记的初衷，我不奢望它能成为像《如何成为一名黑客》这样被人称为黑客入门宝典的文章，只希望能让看到这篇手记的你，不再迷茫。","text":"为什么会有这篇文档？之前有幸看过Eric Raymond(埃里克·史蒂文·雷蒙德)写的一篇文章《如何成为一名黑客》，感觉像黑夜里的灯塔一样，能够给人很多的启迪。在计算机这条道路上，无论是程序员，黑客，网管，还是其他任何相关的角色，有一个老司机带你，能让你看清自己的方向，不至于迷失自我。记得在初二那一年因为老师的一句很看不起人的话，走上了编程这条路。高中，大学，不断的更换自己所学的语言。这期间我学习了VB，Java，Perl，Python，C#，C，C++，汇编，原因就是因为自己不知道该学什么好，究竟应该学什么才是对的，怎么样才能更好的在编程这条路走的更远，我学习VB的时候看到别人说Java如何的厉害，学Java的时候又听别人说Java不能做大型游戏和操作系统…那一刻我是真的迷茫了。这是我下定决定要写这篇手记的初衷，我不奢望它能成为像《如何成为一名黑客》这样被人称为黑客入门宝典的文章，只希望能让看到这篇手记的你，不再迷茫。 什么是程序员？程序员在外行人看来，可能是一个带着厚镜片眼睛，满脸的胡茬，大T恤，人字拖，双眼无光，整天坐在电脑前噼里啪啦的敲代码，凡是电脑相关的问题，他都要会。 其实并不是那样的，从计算机诞生之初，世界上第一台计算机出现的那一刻，就意味着世界上已经有了第一批程序员。如果非要我说程序员是什么的话，我只能说，计算机就像无所不能的阿拉丁神灯，而程序员则懂得如何与它交流沟通的办法，在网络的世界中，如果说骇客是破坏神，那么程序员就是创世神。(ps:这里不用黑客是因为，传统意义的黑客，像侠客一样，他们不会做无意义的破坏，他们只是乐于追求技术的巅峰和分享自己的技术。) 程序员可以创造任何你所能想到的程序，任何不可思议的东西，任何在别人看来魔幻的东西，程序员都能通过不断的超越自我来一一实现，虚拟现实和人工智能技术的突破，已经说明了这一切。有很多人认为自己是程序员，我想说不，其实你不是，你只是一个码农。而有很多人自嘲自己是码农，其实他们才是真正的程序员。 程序员和码农真正的区别在于，码农只会每天无休止的工作，今天重复昨天的任务，明天复制今天的生活。一年又一年，一个项目又一个项目，同样的框架，同样的配置文件，同样的结构，甚至同样的接口和底层代码。每天他们所做的就是Ctrl+C，Ctrl+V。甚至，从来不去关心技术，也不会去分享自己的技术，他们闭门造车，生怕自己的技术被公司的新人，被其他的同行学去。自己写的项目要里三层外三层的绕来绕去，防止别人偷窃自己的代码。 而程序员，他们乐于分享，追求技术的巅峰，不断超越自我。码农所关心的是如何尽快完成一个项目，程序员关心的是如何让一个项目更加的优雅稳健。 程序员的态度 这个世界充满了问题，等待我们去解决。 不要重复的制造轮子 崇尚自由 编程使人快乐 乐于分享正如你所看到的，程序员的态度和黑客的态度惊人的相似。实际上程序员和黑客之间并没有太多的不同之处，首先他们都是编程高手，只不过他们所专注的领域不同，黑客研究的是如何让软件拥有更强大的破坏力，而程序员所研究的是软件如何承载更高的并发，如何去抵挡黑客的攻击。 和所有创造性的艺术一样，成为大师的最有效方法，就是模仿大师的精神——智力上的模仿还不够，还要从感情上进行模仿。修行之道：关注大师的言行，跟随大师的举动，和大师一并修行，领会大师的意境，成为真正的大师。引用自《如何成为一名黑客》 1. 这个世界充满了问题，等待我们去解决。程序员就是为解决问题而生的，如果这个世界不存在任何问题，那么就不需要程序员。当人们需要通讯，需要沟通的时候，诞生了MSN，QQ，Skype。当人们需要社交的时候诞生了FaceBook。当人们需要网络购物的时候，诞生了亚马逊，天猫。就和所有先有鸡还是先有蛋的问题一样，到底是什么先需要网络通讯后诞生的通讯软件，还是先有的通讯软件，后来人们才适应了网络通讯。这些问题，人们不得而知，但是上面提到的每一个人，他们如今都在福布斯富豪榜位列前茅。你所发现的问题，或者你所要解决的问题，他的受众面有多广，那么你对于人类的贡献就有多大，而你的名字也会被篆刻在历史的丰碑上。这个世界拥有无数的问题，即使百度，腾讯，阿里，拿掉了所有的技术，依然有无数的问题等待我们去发现，去解决。你要相信，即使是谷歌的产品经理，也不如一个专修平房漏水的大爷更了解他所在行业的问题。从你最熟悉的环境出发，发现问题，并解决它。 2. 不要重复的制造轮子对于已有的东西，程序员不会去重复的创造它，除非之前的东西非常的差。如果他是一个开源项目，应当提出你的修改意见，或直接贡献你的代码。除非它毫无亮点可言，否则你不需要重复制造轮子的过程。要相信一句话，最出色的程序员，也不如一个社区的人共同努力所创造出来的产品完美。你应当将时间和精力放在更有意义和价值的事情上。 3. 崇尚自由如果你跟我说，程序员是没有自由的，那么我想你可能是在生活的压力下迷失了自我。自由并非是来去自如，而是你的工作岗位可以由你自己去支配，你可以选择是在天台或者坐在滑滑梯上，甚至是在家里办公。要记住一句话，自由永远是属于强者的，为了追寻自由，你必须不断的突破和超越自我。还要记住自由并非是不工作，事实上如果能够处在一家伟大的公司，和一群伟大的人共事，那将是一件非常令人愉快的事情。 4. 编程使人快乐你是否每天上班以后，打开电脑和你的编程工具以后，就开始了自己一天的工作，浑浑噩噩直到吃午饭。下午继续重复这一过程，日复一日，你已经忘记了你的初心，忘记了你一开始学习编程时的那种激情和梦想。没错，并非每个人都有梦想，也并非每一个梦想都可以实现，更不是说每一个程序员都要去实现自己的梦想。我认为，程序员最大的梦想就是快乐的编程。试想一下，在一天的清晨，一杯青柠檬茶和一个机械键盘，听着你所喜欢的音乐，跟着欢快的节拍敲打着。就好像多年前的那个深夜，一个人，一架钢琴，一轮明月，一杯苦酒，造就了永世流传的月光交响曲。 5. 乐于分享如果你觉得程序员都应当牢牢地保护好自己的代码，那么绝对不会有今天的Github这种开源项目托管的网站。更不会有一个个流传至今还被人使用着的项目，可能有人会说某些著名的产品都没有开源。相信我，他们不开源是因为他们的代码写的太烂，如果被别人看到就没有人敢使用他们的产品了。一个人，一个团队，一个公司的力量，绝对比不上全世界的程序员。计算机之所以发展的如此迅猛，就是有无数的乐于分享的你们，这些分享并非仅限于你某个项目的源码，也可以是一篇文章，甚至是一次回答，这对于你来说，都是分享，这一过程将使你得到快乐，并获得行业其他人的认同。 程序员的基本技能 学习如何编程 学会使用互联网 能够看懂英语 1. 学习如何编程如果你是一个新手，对于编程一无所知，恭喜你，你将在这里找到你的路。如果你是一个入门者，对于编程略有了解，恭喜你，你将在这里坚定你的路。如果你是一个老鸟，对于编程早已融会贯通，同样恭喜你，你将在这里成为开拓者。 在过去的几年里，我学习了多门编程语言，我发现其实他们都大同小异，一旦你掌握其中一门，想学习其他任何一门都会很容易，是真的非常的容易，我可以毫不客气的说，你可以一周之内就学会别的语言。除非你并没有真正的掌握编程的思想，我们总是强调思想，这就像小说中的法则一样，领悟其中一门法则，再去领悟其他法则，可能还不是特别的快，但是参考起来还是比新手要快。但是一旦领悟了法则的本质，那么再领悟其他任何一门法则都会很轻松。你并不需要苦恼你不理解这些，放松你的心态，学习和工作中，一切都会水到渠成。 编程语言众多，条条大路通罗马，忘记你在任何位置看到的任何关于某个语言不好的地方，也忘记你看到的任何关于某个语言的优势，那些都是毫无意义的。实际上你点开任何一个语言的官网，他总有一个与其他语言的对比图，对比的结果它总是比其他语言更有优势，那么这些毫无意义的评价又有什么价值呢。 即使是世界上人口最少的冰岛，那里的人民使用他们独有的语言，依旧能够快乐幸福的生活着。 不管我下面说了什么，如果你已经决定或者正在学习一门语言的话，坚定的走下去，如果今天因为我的话而放弃你目前的所学，你还是趁早离开这个行业吧。如果你还没有选择一门语言，那么你或许可以参考我的建议。 在我学习的多门语言中，从来没有哪一门语言能让我感到惊艳，或者说，像弹钢琴一样的写代码，Python做到了。最初接触Python是因为要写一个网络爬虫，当时看了一些参考资料就写出来了，而且代码十分的简洁，只有短短的三十多行代码。不过但是并没有太大的惊喜，只是觉得，哎呦，这个语言，不错哦。因为Java我也完全可以自己整合一个包，只用几句代码，也能完成这一切，但是当时想到这个时候，我忘记了一个很严重的问题，那就是我在自己造轮子。 Python带给我的惊喜远远不止于此，又一次偶然的机会让我使用Django(Python的一个开发网站的框架)，这一次我是彻底的被它的简单，优雅而吸引。很多人推荐初学者学习Java，C++，甚至是VB和汇编。 实际上，我曾经也经常推荐想学习编程的朋友，去学习Java，因为它没有像C++那么难以理解的东西。但是Java的面向对象的思想，足够没有编程基础的人喝一壶了，所以我不建议新手学习Java。而Python被列为黑客必须要掌握的技术之一，同样，我认为程序员也必须掌握Python。因为它真的非常的简单和强大。有人称Python为瑞士军刀，还有人称它为胶水语言，在国外很多学校都是以Python作为教学的语言。Python拥有庞大的用户群和社区，Google，NASA。所有你耳熟能详的公司，他们或多或少都在使用着Python。事实上，Perl也同样简洁，而且它对于正则表达式的支持是难以置信的，但是它的用户群体并不多，而且不够活跃，选择一个用户群体活跃的语言，将会让你语言问题时，获得更多人的帮助。 而学习编程，最好的方法就是阅读，不管是官方的文档还是别人写的教程，如果是视频教程就更好了。一开始学习的时候，不要太过于纠结底层的原理，就像你开车一样。一开始你只是学习怎么开这个车，你并不了解内部的构造，所以你不会修理它，但是随着你经验的加深，你开得多了，对它内部的了解就多了，慢慢的你也可以修理它了。 最后强调一次，坚持你目前所学的。 2. 学会使用互联网身为一个程序员，如果你不会使用互联网，那就太弱了。学会使用百度和翻墙，这对于每个程序员来说是必备的技能。 3. 能够看懂英语英语对于你来说是必要的，如果你的英语不好，你不必苦恼。编程这么难的东西，你都敢于学习它，英语又算得了的什么？26个字母分开认识，组合起来一样能够认识，更何况还可以借助翻译工具。这并非让你在学习编程之初就需要掌握英语，而是在你编程达到一种比较高的层次以后可以考虑的事情。英语可以让你和国外众多的高手交流心得，同时还可以让你参与国外大型的开源项目开发。 提高自己在编程圈中的地位 贡献开源项目 帮助测试并调试开源项目 发布有用的信息 帮助新人 和其他行业不同，程序员想要提高自己在圈中的地位，并不需要多么惊世骇俗的经历，甚至不需要多么厉害的技术。提高自己的地位，可以让你在求职或创业过程中，获得更多同行业的帮助，你的付出都会得到回报，相信我。 1. 贡献开源项目永远不要以为在Github上贡献一个项目有多么的困难，一次机缘巧合之下，我发现Python中一个很大的开源项目Requests文档中有一句代码书写错误，于是我修改了它，我的提交得到了项目管理团队的认同，他们收录了我的修改。就是这么的简单，细心和简单的英语水平，就能让你贡献一个几百万人使用的项目。甚至，你可以自己发起一个开源项目，正如我所说的，程序员都是乐于分享的，如果你发起某个项目，并且说的足够的详细，一定会有人非常乐意和你一起开发和维护这个项目的。 2. 帮助测试并调试开源项目如果你费尽心机也没有能够贡献一个开源项目的话，千万不要灰心，你还可以帮助开源项目进行测试和调试。如果发现其中的问题，可以去他们的主页提出问题，如果能够给出解决意见，那真是太好不过了。帮助测试开源项目是一件非常容易的事情，在Github任何一个项目的主页中，他都拥有当前稳定版本和测试版本以及过去版本。当前稳定版本就相当于正式版，是经过测试没有问题，发给用户使用的。测试版本就是目前正在开发的版本，修改或增加了很多新的内容，但是没有经过详细的测试，开发团队也不确定会出现什么问题，于是发出来希望有经验的开发人员能够协助他们共同去测试。 3. 发布有用的信息你还可以活跃在各大程序员社区，撰写自己的博客。慕课网，博客园，知乎，都是一个不错的选择，在那里有很多的新人，也有很多的前辈。无论发布任何的信息，都会帮助到别人。无论你是新人还是老手，都可以发布你的文章，这可以是你学习的心得体会，也可以是你面试的经历，还可以是你学习编程之路的微笑与眼泪，或是你工作中的所见所想。都会得到大家的阅读，不会有任何人会出言不逊或否定你的技术，即使写错了也不用担心，别人会指出你的错误，这样才能一直进步。永远不要担心别人指正你的错误，除非他说的是不对的。 4. 帮助新人你曾经和他们一样，永远不要忘记这句话，当新手提问一些在你看起来非常可笑的问题时，要告诉自己，曾经我和他一样。不要去嘲笑他，在解答他问题的同时，记得告诉他，如何学会排查这些问题，以及如何更好的使用搜索引擎去寻找答案。要记住，你轻蔑的回答，可能毁灭了一个和曾经的你一样有梦想的人。工作之余和假期无聊的时候，浏览一下别人的问题，选择一些回答，这都可以帮助你提升自己的技术和地位。记住，这是一件长期的事情，一天回答一百个问题，然后九十九天不回答，不如一百天每天回答一个问题，你说呢？ 最后几点疑问我需要掌握数学吗？我希望你今天能够记住我说的这几句话，程序员的工作和数学真的没有太大的关系，只要你能够了解加减乘除，大于小于这些基本的关系就足够了。就像那些年中柯景腾说的，“就算十年后我连log都不知道是什么，一样可以活的很好”。我们程序员同样如此，就算你不知道什么叫做正弦余弦，一样可以很好的编程。真正需要数学来做的工作，都是那些博士的工作，我们的任务只是改变世界而已，所以我们不需要数学的基础。当然，如果你拥有这个技能，也不会影响什么，相反它还会让你在理解程序逻辑的时候简单一些。 程序员就要会修电脑吗？没有任何人下过这个规定，修电脑是网管的任务，程序员所要思考的就是如何更优雅的工作。 程序员都很内向吗？这取决于个人，我觉得学习的同时应当不要忘记健身和娱乐，周末可以约几个朋友一起出去唱唱歌，吃个烧烤什么的。不是说某个行业的人都要内向，我身边很多同事都特别的外向，并且桃花运不断。 怎么样才能知道自己已经是一个合格的程序员了？恭喜你，当你对自己问这个问题的时候，你已经是一个合格的程序员了，接下来你所要做的就是，把你所决定的付诸行动。从今天开始，分享一个学习的小心得，回答一个小问题。请记住，这并不需要你有多么高深的技术，哪怕你今天才开始学习编程，依旧可以写出一篇文章来，向人们分享你成长的同时，还可以给其他人以帮助。程序员圈子是一个乐于分享和有爱的圈子，请分享你每一次成长的经历，一定会得到别人的赞同，而如果有人出言不逊，你不必理会，他一定是一个没有素质的人。 我需要一台高配置的电脑吗？实际上是不需要的，你只要拥有一个搭载512MB内存和单核的处理器，以及一块50G硬盘的电脑足以。当然，它可能不足以让你运行大型的开发工具，但是小型的sublime或是Vim，也是一个很不错的选择，至少他们比文本文档漂亮的多。 我的家人建议我去学习其他行业，我该去吗？再从头看一遍我们的文章，然后问自己，我想要做一个程序员吗？如果你得到的答案是确定的，那么我为你感到骄傲，无论谁的否定，都不能阻挡你在这条路走下去。你不仅不能放弃，反而要努力拼搏，拥有一片属于你的天空，让否定你的人刮目相看。而如果你得到的答案是否定的，那么我为你感到遗憾的同时，我建议你选择一个你真正喜欢的行业，即使这个行业不是程序员，我也会为你喝彩。你是一个独立存在的人，所以，你要自己决定你未来的路，不管你喜欢的职业是什么，走下去，别回头。 我该从哪里开始学习？如果你想寻找一个友好免费全面的学习平台，那么我建议你选择慕课网，这真的不是在安利什么广告，我接触过许多的学习网站，他们拥有很多的问题，比如说太多的收费内容，以及社区不够全面化。慕课网则不同，不仅有用大量的免费课程，还有便宜的实战课程，要知道的是，实战课程通常都是大型项目，看完以后对于之前基础知识的整合是非常有帮助的，而非实战内容，都是免费的。同时我也向你推荐YouTube这真的是我用过的，最棒的网站，在上面拥有你想象不到的资源。几乎你想学习任何东西都可以在上面找到别人制作的视频，并且是精心制作的视频，这一切不需要你支付任何的金钱。比较遗憾的是，大多数都是英文的视频。 如果你想要选择一本书的话，我推荐图灵社区的动物书，它是我见过的最好的编程语言书，没有之一。 同时Github，Google+和stackoverflow也是非常好的，能够帮助你成长的平台，但是这三个平台都需要有一定的英文基础。其中Github能够和许多开源项目的作者面对面交流，而Google+则拥有很多的社区，能够找到你所学习语言的社区，并且其中有很多的大神，至于stackoverflow则号称如果它里面都没人能解决的问题，那你的问题一定是无法解决的，可想而知它的魅力之所在。 人工智能会让我丢失工作吗？至少，在我们活着的时候，不需要担心这个问题。人类的大脑又岂是简单的算法能够完成的？ 开源是否会让我得不到任何的收入？我想这个问题，Linux之父从来没有担心过，因为他一份简历投去任何一家公司，上面只需要写一行字：我创造了Linux。他所得到的工资恐怕是数以千万而且还有公司的股权，这难道不比一个收费软件赚得多吗？更何况他得到的远不止于此。 我已经年纪很大了，现在学习是不是晚了？从来没有人给程序员入门限定一个年龄，以前没有，现在没有，未来更不会有。 我需要多久才能掌握？这取决于你的努力程度和你的聪明程度，虽然我不想提到这个问题，但是我不得不说，聪明才智也是一个重要因素。值得庆幸的是，我们大部分人的智商都是差不多的，只有个别智商超群的人，那是他们的天赋。我们只要付出更多的努力，同样可以超过他，勤能补拙不是说着玩的。通常情况，能在半年内使用一门语言进行开发，两年内能够对一门技术有非常高的了解。但是真的想在这个行业达到令人尊敬的地位，你需要一生去学习。 最后说几句 永远不要嘲笑新手 记住你的初衷 任何时候都不要忘记代码的美观 优雅高效 乐于分享 感谢能够看到最后的你，希望这篇文章，能够给你带来一些帮助，起码能让你觉得不再迷茫，我的目的就达到了。你可以将本文以文字或是链接的形式分享到任何地方。如果可以的话，我希望你能够直接分享文章的地址或者是在转载的时候加上出自哪里，以便更多的人加入我们这个大家庭。世界的未来，依靠各位去改变，记住我所说的，从现在开始行动，从码农转变为真正的程序员。从今天开始，乐于分享，快乐编程。 (注：如果有错别字，给大家带来阅读上的困难，我表示歉意，同时希望你能够指出错误的位置，以便于我来修改它。我将会在文章的底部增加上提出修改意见人的名字。多人提出同一修改，则以最先提出的人为准。) 本文由以下人员共同协作完成（排名不分先后）@秋名山车神 @qq_癫狂是一种病_03633840 @小丨小菜鸟","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"入门指南","slug":"入门指南","permalink":"http://www.cheshen.wiki/tags/入门指南/"},{"name":"程序员","slug":"程序员","permalink":"http://www.cheshen.wiki/tags/程序员/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]},{"title":"我本微末凡尘，却也心向天空","slug":"我本微末凡尘，却也心向天空","date":"2016-10-20T12:56:32.481Z","updated":"2017-04-15T06:09:25.238Z","comments":true,"path":"2016/10/20/我本微末凡尘，却也心向天空/","link":"","permalink":"http://www.cheshen.wiki/2016/10/20/我本微末凡尘，却也心向天空/","excerpt":"自信可改变未来，问谁又能做到？ 有时候总是想写点什么，但是双手放在键盘上的时候，又不知道从何说起，我有时候总是在想，我们人来到这个世界上，究竟是为了什么，为了一天天的工作？为了找一个爱自己的伴侣？这个问题曾经困扰了我很久。","text":"自信可改变未来，问谁又能做到？ 有时候总是想写点什么，但是双手放在键盘上的时候，又不知道从何说起，我有时候总是在想，我们人来到这个世界上，究竟是为了什么，为了一天天的工作？为了找一个爱自己的伴侣？这个问题曾经困扰了我很久。 记得在高中的时候，我是班上学习最差劲的几个学生，喝酒打架、翻墙上网，不知道写过多少的检查，逢年过节父母肯定不敢跟别人提起我的成绩，人生的前二十年，从来没有让自己的父母骄傲过。直到高三那一年，发生的一件事改变了我的人生轨迹，那是2011年，深圳举办大学生运动会，我们学校要选一些保安过去，一个月一千五百块钱，我也不知道为什么就同意去了，或许冥冥之中老天想要给我一次改变自己的机会。坐着严重超载的大巴，花了三十个小时，终于来到了对我来说是梦寐以求的城市：深圳。因为在这里有无数伟大的人物，有无数伟大的公司，到了以后公司简单的安排了一下，我就和另一个同学一起，被分派到福田区的一个发电站里面，在里面负责看这些设备不被人破坏，当时我是夜班。记得印象最深刻的一件事情就是，我身上只有三百块钱，旁边最便宜的是十八块钱一份的米饭，根本吃不起，于是我出去想找个超市买点泡面面包什么的，由于不知道路只能打了一个出租车，花了15块钱，到了以后买了两百块钱的方便面和面包（你们可以想象有多少），本来回去的时候想走回去省点钱，自以为自己记住了回去的路，于是走着走着迷路了，但是我记得我住的地方是福田二路的江苏大厦旁边，于是我就问别人怎么走，那是第一次让我感受到这个城市的冷漠，我问的出租车司机，他们都说不知道，最后没办法只能让一个司机把我送过去，结果转过一个路口就到了，花了13块钱。PS：那时候我的手机还是按键手机，不是安卓系统，没有百度地图。 我每一顿吃两片面包，一根香肠，有时候撕开一袋泡面，把热水倒进袋子里，直接在袋子里面吃，这属于逢年过节级别的。面包就是那种六块钱一袋里面有十几片那种，从来没吃饱过。就这样过了两个月，这两个月期间，我每天最大的爱好就是坐在楼梯上看着铁栏外面的汽车，一分钟最少过去四十辆宝马和奔驰，而且还让我看到了林肯和法拉利，第一次见到这么多的豪车，第一次见到这么高的楼，但是这里留给我的只有绝望。终于到了离开的那一天了，我走的那天站在马路边上，望着身后生活了两个月的地方，我对自己说：我一定会回来的。 回到家以后，虽然开始努力改变了，但是不幸的是，高考来了。我高中上的是中专，所以参加的也是职业高考，只能考计算机专业，当初选择中专为计算机专业就是因为喜欢玩游戏，我曾经很自豪的事情就是我玩过当时所有流行的网络游戏。高考只考了385分，选择了我们省会的一所大学，是一个三流都不如的大专，到了大学以后，我们班只有二十个人，而且他们学习都不怎样，而我高中还学过一些程序，这让我的自信心盲目的膨胀，老师的水平也很差劲，这让我更加的自大，我认为普天之下没有我不会的东西了，所以我就经常不去上课还和宿舍的一起打游戏。直到大二的时候，老师让我代表学校去参加职业技术大赛，那是我第一次感到挫败，我得了最后一名。 重新回到学校以后我开始努力的学习，但是我没有任何的方向，Java、C++、C、.NET，这些都学过，而且都学的一瓶子不满，半瓶子咣当。终于到了大二的后半年，我决定离开我的学校，我要去我心中一直向往的那个城市。 回到家里以后，家人想让我去投靠深圳的一个亲戚，让我去他的工厂里面做保安，我受够了这种生活，我说我要自己闯出一片天地来，我跟家人列举了比尔盖茨，乔布斯，马化腾这些名人的例子，家人总是说，你别想疯了。这句话伴随我十几年，我的理想总是被家人打击着，这不怪他们，因为我一直让他们失望，一直失望。但是深圳的那个亲戚想让我等几天，给我找一个好点的工作，但是我一刻也不愿意等待。又过了两周，家人终于决定让我自己来深圳闯荡。又是三十个小时的车程，我这一次有的是激动，是对自己心中承诺的兑现，那一刻我认为自己轻轻松松就能找到工作。到了深圳以后，我暂住在同学的舅舅家里，那天晚上学习到一点多，白天出去找工作，第二天找了一天的工作，一个面试官对我说：就你这样，不要工资我们都不会要你的。那一天下午五点多，一个人站在龙岗华为的旁边，我看着川流不息的车，我问自己，我可以吗… 到了六点的时候，迎来了一个房产销售公司的面试，老板让我帮他维护他们的网站，增加一些新开售楼盘的信息，同时还要跟着销售出去卖房子，当时他说一个月1900，我说给2000吧，他说行吧，反正也不在乎那一百块钱。就这样我在深圳安定了下来，从进入深圳的那一刻起，我真正明白了一件事，梦想不是靠嘴说的，是要实际行动的，我每天在公司被老板骂，还要打电话给别人推销房子，被客户骂，还要笑着去讨好别人，每天晚上六点钟下班以后独自一个人学习到十二点。后来一个朋友给我推荐了慕课网，于是我一边看网上找来的教学，一边看慕课网的各种知识点和案例，两个月，我用了两个月的时间学完了Java基础所有的部分，当时我自己写出了一个Spring的框架，当然我写的那个很简单，只是使用反射，还有Java的注解类，还有动态代理这些实现的。那个时候我已经明白了自己的不足，差的太远了，于是我再一次开始找工作了，或许别人不愿意使用没有工作经验的，我投了一百多封简历，没有接到任何电话。我再一次的灰心了，直到三天以后，我接到了一个面试电话，是南山区的一个公司，面试的过程很顺利，面试官问的所有问题我都答上了，最后技术总监问我说，那么多面试的人，我们为什么要选择一个没有经验的人呢。我想了很久，我不知道该怎么说，我说，我在印象笔记有一千多条笔记这样可以吗。那个总监看了我很久，然后当时就告诉我被录取了，试用期三千，转正五千，我当时心情的激动，无法使用语言去表达，回想起刚到深圳的时候连地铁都不会坐，还是问了保安才知道乘坐地铁。我给家里打电话说了这件事，家里人都不相信我能够找到工作。 虽然找到了工作，但是我仍然没有忘记时刻学习，依然每天到家第一件事就是打代码，我的人生除了学习就是工作。从学校出来到深圳以后，我没有一天是停止学习的，过年在家都要看一会书。那时候经常叫沙县小吃的外卖，录取成功的那一天，我跟原来的经理说我不干了，然后就走了，到现在还有一千块钱的工资在他那里没有给我。那天晚上我走在回家的路上，耳边想起了Beyond的光辉岁月，直到今天，我还非常喜欢海阔天空和光辉岁月这两首歌，它们依然激励着我。我当时告诉自己，一定要在深圳这个城市好好的活下去，而且还要活的很精彩，我当时有种这天再遮不住我眼，这地再埋不住我心的感觉。两个月以后过年回家了，但是公司由于是做在线购买彩票的，而彩票禁止在网上售卖，公司倒闭了，正好是过年前的几天公司倒闭了。那一年回家，我是火车站票回去的，站了二十多个小时，我当时告诉自己，你要记住，你今天所经历的一切都是提醒你未来的每一天不能有丝毫的松懈，同样的对深圳说了一句话，下次再来的时候我会在这里过的很好，我会坐飞机回家，于是，我去年兑现了这个承诺。 终于，第二年来到深圳以后，和朋友一起经历了短暂的创业失败以后，找到了一份月薪八千的工作，那是我第一次让自己的父母在亲戚面前抬起头。他们不怕再跟别人提起我，也不怕别人夸自己的孩子，他们也有了一点和别人谈论的资格，这份工作我一直做到了现在，也有一年多了，工资也涨到了九千，虽然跳槽以后可以拿到两万，但是我还是很感激这个当初能够信任我的公司，所以一直也没有离开，偶尔和朋友接接项目也不在乎那些钱。那一刻，让我想到了我初中的数学老师，那天她当着全班同学的面抽我一耳光，然后说如果我要有一天出息了，她倒着走路，我到今天依然记得这句话，我期待登上福布斯富豪榜那天回去看她倒着走路。 我想要说的是，每一个程序员心中，一定有一个梦想，就算不说，我们也知道这个梦是改变世界。无数伟大的公司，各种传奇的经历，我想说的是，梦想每个人都有，不同的是，有些人面对梦想他们只能远远的看着，从来不付出任何努力，我人生的前二十年就是如此。还有一种人自以为付出了一些努力，就是世界上最伟大的存在，自己不成功都是因为没有背景，都是因为各种外在因素导致的，大学的那段时间我就是如此。还有一种人，他们不畏艰险，忍受着各种的困难和挫折，他们一次又一次的跌倒，一次又一次的爬起来，他们从来不会忘记学习，因为他们明白，他们的力量还不足以承载他们的野心，现在我就是这种人，我同样相信来慕课网学习的你，也是这种人。 我们活着不是为了别的，我们只是为了让我们在乎的人可以过上更好的生活，可以让他们自豪的说出你的名字，可以让自己心爱的人可以买到世界上任何的东西，而不是自己的妻子，孩子，父母，只能看着橱窗里昂贵的奢饰品望而兴叹。有朋友问我，你是怎么学的，我告诉他说，我只是用别人打英雄联盟的时间学习罢了，他们今天玩得比我开心，未来他们只能看到那么大的天地，而我的未来又岂是一个深圳能够满足的。在硅谷有更加广阔的天地，我们的征途是星辰大海。请记住，未来的你，一定会感谢现在拼命努力的自己。看到这里或许有些人感觉很可笑，不求能让所有的人醒悟，只希望能够明白，再好玩的游戏，也没有马尔代夫的阳光沙滩和美女好玩。然而这些东西并不需要多么出色的成绩只需要年薪二十万你就可以轻松做到这些，这对你来说只不过是每天坚持过来学习罢了，一年以后你就可以实现。当然努力学习的同时，还要注意早点休息，尽量十二点以前睡觉，记得经常健身，制定一个规范的计划，每天健身多久学习多久。 当我们失去方向，不知所措的时候，唯一可以做的就是迎着风雨努力的前行，我非常喜欢一句话，我本微末凡尘，却也心向天空。送给大家，同时希望大家坚信：长风破浪会有时，直挂云帆济沧海！","categories":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}],"tags":[{"name":"励志鸡汤","slug":"励志鸡汤","permalink":"http://www.cheshen.wiki/tags/励志鸡汤/"}],"keywords":[{"name":"博客","slug":"博客","permalink":"http://www.cheshen.wiki/categories/博客/"}]}]}